{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Vincent Picard - Informatique CPGE","text":"<p>Bienvenue, ce site contient des ressources pour les cours d'informatique CPGE au lyc\u00e9e Leconte de Lisle et quelques informations sur moi.</p> <ul> <li> <p> Informatique MPI</p> <p>Ressources pour les \u00e9l\u00e8ves de MPI</p> </li> <li> <p> Informatique tronc commun</p> <p>Ressources pour les \u00e9l\u00e8ves de MP / PC / PSI</p> </li> <li> <p> \u00c0 propos de moi</p> <p>Informations et contact</p> </li> <li> <p> Liens utiles</p> <p>Quelques liens int\u00e9ressants...</p> </li> <li> <p> Configurer sa machine</p> <p>Tutos pour configurer sa machine et utiliser certains outils pratiques</p> </li> </ul> <p>Travaux en cours</p> <p>Ce site est en cours de construction.</p>"},{"location":"config/","title":"Configurer sa machine","text":"<p>Je mets \u00e0 disposition ici une liste de \"mini-tutos\" pour bien configurer sa machine pour travailler efficacement sous Linux.</p> <ul> <li> Installer et utiliser Opam</li> <li> Installer et utiliser les pages manuel</li> <li> D\u00e9bugguer son programme C avec gdb</li> </ul>"},{"location":"domino/","title":"Projet en C : construction d'une cha\u00eene de dominos par backtracking","text":"<p>Inspir\u00e9 de Sujet 0 CCINP</p>"},{"location":"domino/#1-introduction","title":"1. Introduction","text":"<p>Le but est d'\u00e9crire un programme en C qui prend en entr\u00e9e un fichier texte contenant une liste de dominos, par exemple :</p> exemple_small.txt<pre><code>2, 2\n3, 6\n1, 5\n6, 4\n6, 6\n2, 5\n1, 5\n2, 4\n</code></pre> <p>et qui produit une cha\u00eene de dominos \u00e0 partir de cette liste : <pre><code>    vincent@kimchi:~/domino : ./chainedom exemple_small.txt\n    Liste initiale :\n    [2;2][3;6][1;5][6;4][6;6][2;5][1;5][2;4]\n\n    Construction r\u00e9ussie :\n    [5;1][1;5][5;2][2;2][2;4][4;6][6;6][6;3]\n</code></pre></p> <p>Remarquer que lors de cette construction, les dominos peuvent \u00eatre retourn\u00e9s (on parlera de rotation) : par exemple ici le domino <code>[3;6]</code> a \u00e9t\u00e9 retourn\u00e9 en <code>[6;3]</code> pour aboutir \u00e0 cette solution.</p> <p>Je vous donne ici une archive contenant un squelette du projet accompagn\u00e9 d'un fichier Makefile :  LE PROJET A TELECHARGER ICI</p> <ul> <li>pour compiler le projet on tape : <code>make</code></li> <li>pour ex\u00e9cuter son programme on tape : <code>./chainedom exemple_small.txt</code> (avec le fichier que vous voulez !)</li> <li>pour nettoyer le r\u00e9pertoire (fichiers compil\u00e9s) : <code>make clean</code></li> </ul> <p>Les options de compilation peuvent \u00eatre modifi\u00e9es dans la variable <code>FLAGS</code> du fichier Makefile si vous le souhaitez.</p> <p>Le projet est organis\u00e9 en 4 unit\u00e9s :</p> <ul> <li>L'unit\u00e9 <code>domino</code>: g\u00e8re la repr\u00e9sentation d'un domino</li> <li>L'unit\u00e9 <code>liste</code>: repr\u00e9sente un ensemble de dominos sous forme de liste doublement cha\u00een\u00e9e</li> <li>L'unit\u00e9 <code>backtracking</code> : impl\u00e9mente l'algorithme de construction d'une cha\u00eene de dominos</li> <li>L'unit\u00e9 <code>parser</code> : impl\u00e9mente la lecture du fichier texte d'entr\u00e9e, j'ai cod\u00e9 cette partie pour vous il n'y a rien \u00e0 faire... Mais cela ne doit pas vous emp\u00eacher d'aller voir comment j'ai fait.</li> <li>Il y a aussi un fichier <code>main.c</code> qui contient la fonction d'entr\u00e9e de votre programme</li> </ul>"},{"location":"domino/#2-gestion-des-dominos","title":"2. Gestion des dominos","text":"<p>Les dominos seront repr\u00e9sent\u00e9s \u00e0 l'aide du type suivant (d\u00e9fini dans <code>domino.h</code>) : domino.h (extrait)<pre><code>struct domino_s {\n    int x; // Partie gauche\n    int y; // Partie droite\n};\ntypedef struct domino_s Domino;\n</code></pre></p> <p>On vous donne \u00e9galement une fonction : <pre><code>Domino domino(int x, int y);\n</code></pre> permettant de construire un domino \u00e0 partir de deux entiers.</p> <p>Question 1</p> <p>Dans le fichier <code>domino.c</code>, impl\u00e9menter la fonction <pre><code>bool domino_possible(Domino a, Domino b)\n</code></pre> testant si l'enchainement des deux dominos <code>a</code> suivi de <code>b</code> est valide. On n'autorise pas pour l'instant les rotations. Par exemple <code>[3; 6][6; 4]</code> est un encha\u00eenement valide mais <code>[1; 5][4; 5]</code> ne l'est pas.</p> <p>Question 2</p> <p>Dans le fichier <code>domino.c</code>, impl\u00e9menter la fonction <pre><code>bool domino_possible_avec_rotation(Domino a, Domino *b)\n</code></pre> qui teste si on peut encha\u00eener les dominos <code>a</code> suivi de <code>b</code>. Cette fois-ci on s'autorise la rotation du domino <code>b</code>. La fonction aura le comportement suivant :</p> <ul> <li>S'il est possible d'encha\u00eener <code>a</code> puis <code>b</code> sans rotation, on renvoie <code>true</code> et on ne modifie pas <code>b</code></li> <li>S'il est possible d'encha\u00eener <code>a</code> puis <code>b</code> en tournant <code>b</code> alors on modifie b et on renvoie <code>true</code></li> <li>Sinon on renvoie <code>false</code> sans rien modifier</li> </ul>"},{"location":"domino/#3-listes-doublement-chainees","title":"3. Listes doublement cha\u00een\u00e9es","text":"<p>Dans ce sujet on utilisera des listes doublement cha\u00een\u00e9es de dominos. Pour cela on d\u00e9finit dans <code>liste.h</code> les types suivants.</p> liste.h (extrait)<pre><code>struct maillon_s {\n    Domino d;\n    struct maillon_s *suivant;\n    struct maillon_s *precedent;\n};\ntypedef struct maillon_s Maillon;\n\nstruct liste_s {\n    Maillon *premier;\n    Maillon *dernier;\n};\ntypedef struct liste_s Liste;\n</code></pre> <p>Chaque maillon contient une valeur de type <code>Domino</code> ainsi qu'un pointeur sur le maillon suivant et le maillon pr\u00e9c\u00e9dent. Dans le cas des maillons aux extr\u00e9mit\u00e9s, ces pointeurs pourront avoir la valeur sp\u00e9ciale <code>NULL</code>.</p> <p>Une liste est une structure qui contient un lien vers le premier et vers le dernier maillon (\u00e9ventuellement \u00e9gaux) de la liste. Dans le cas de la liste vide, ces deux liens auront pour valeur <code>NULL</code>.</p> <p>On vous donne (dans <code>liste.c</code>) l'impl\u00e9mentation de la fonction : <pre><code>Liste nouvelle_liste();\n</code></pre> qui renvoie une nouvelle liste vide.</p>"},{"location":"domino/#a-ajout-et-suppression-dune-valeur","title":"A. Ajout et suppression d'une valeur","text":"<p>Question 3</p> <p>Dans cette question on souhaite ajouter un nouveau domino \u00e0 l'extr\u00e9mit\u00e9 droite d'une liste de dominos (sans tenir compte si l'encha\u00eenement est valide ou non). Cette fonction aura pour prototype : liste.h (extrait)<pre><code>void append(Liste *l, Domino d)\n</code></pre> Cette fonction devra donc modifier la liste pass\u00e9e en argument. Il faudra bien s\u00fbr allouer de l'espace m\u00e9moire dans le tas pour stocker le nouveau maillon.</p> <ol> <li>Identifier tous les cas limites pour la valeur <code>l</code>. R\u00e9fl\u00e9chir \u00e0 quels tests on pourrait \u00e9crire pour les identifier dans un programme C.</li> <li>Dans le fichier <code>liste.c</code>, impl\u00e9menter la fonction <code>append</code>.</li> </ol> <p>Question 4</p> <p>Dans cette question, on veut supprimer le maillon le plus \u00e0 droite d'une liste doublement cha\u00een\u00e9e non vide. Cette fonction aura pour prototype : liste.h (extrait)<pre><code>Domino pop(Liste *l)\n</code></pre> Cette fonction renvoie la valeur de domino qui \u00e9tait stock\u00e9e dans le maillon supprim\u00e9.</p> <ol> <li>Identifier tous les cas limites pour la valeur <code>l</code>. R\u00e9fl\u00e9chir \u00e0 quels tests on pourrait \u00e9crire pour les identifier dans un programme C.</li> <li>Dans le fichier <code>liste.c</code>, impl\u00e9menter la fonction <code>pop</code>.</li> <li>Si cela n'a pas \u00e9t\u00e9 fait, ajouter une assertion pour s'assurer de la pr\u00e9condition : la liste est non vide.</li> <li>Si cela n'a pas \u00e9t\u00e9 fait, lib\u00e9rer la m\u00e9moire occup\u00e9e par maillon supprim\u00e9.</li> </ol> <p>On vous donne (dans <code>liste.c</code>) l'impl\u00e9mentation de la fonction : <pre><code>void free_liste(Liste *l);\n</code></pre> qui effectue une s\u00e9rie d'appels \u00e0 votre fonction <code>pop</code> pour lib\u00e9rer enti\u00e8rement de la m\u00e9moire une liste.</p>"},{"location":"domino/#b-utilisation-des-liens-dansants","title":"B. Utilisation des liens dansants","text":"<p>Dans cette partie on va utiliser une petite astuce de programmation propos\u00e9e par Donald Knuth dans son algorithme des liens dansants et qui est particuli\u00e8rement utile dans le cas des algorithmes de backtracking.</p> <p>Knuth fait la remarque suivante : si on dispose d'une liste doublement cha\u00een\u00e9e \\(L\\) et que \\(m\\) est un maillon de cette liste alors l'algorithme : <pre><code>suivant(precedent(m)) &lt;- suivant(m)\nprecedent(suivant(m)) &lt;- precedent(m)\n</code></pre> supprime le maillon \\(m\\) de la liste \\(L\\). Jusque l\u00e0 rien de r\u00e9volutionnaire...</p> <p>Il ajoute ensuite : maintenant si le maillon \\(m\\) a \u00e9t\u00e9 gard\u00e9 intact (non supprim\u00e9 de la m\u00e9moire) : <pre><code>suivant(precedent(m)) &lt;- m\nprecedent(suivant(m)) &lt;- m\n</code></pre> remet la liste exactement dans son \u00e9tat pr\u00e9cedent.</p> <p>Autrement dit, ces deux mini-algos permettent de supprimer un maillon donn\u00e9, puis d'annuler cette suppression (un peu comme un undo ou Ctrl-Z). C'est particuli\u00e8rement utile dans les algorithmes de backtracking o\u00f9 on effectue une action et si la suite \u00e9choue on annule l'action et on en essaye une autre.</p> <p>Question 5</p> <p>Dans cette question, enlever provisoirement un maillon d'une liste avec la m\u00e9thode des liens dansants. Cette fonction aura pour prototype : liste.h (extrait)<pre><code>void enlever_maillon(Liste *l, Maillon *m)\n</code></pre> Les param\u00e8tres sont une liste <code>l</code> et un pointeur <code>m</code> vers l'un des maillons de la liste. Cette fonction modifiera la liste <code>l</code>, par contre elle ne modifiera pas le maillon <code>m</code>. De surcro\u00eet, elle ne lib\u00e9rera pas la m\u00e9moire allou\u00e9e pour <code>m</code> car on souhaite pouvoir le remettre dans la liste ult\u00e9rieurement.</p> <ol> <li>Identifier tous les cas particulier en fonction de <code>l</code> et de <code>m</code>. J'en ai personnellement identifi\u00e9 trois... R\u00e9fl\u00e9chir \u00e0 quels tests on pourrait \u00e9crire pour les identifier dans un programme C.</li> <li>Dans le fichier <code>liste.c</code>, impl\u00e9menter la fonction <code>enlever_maillon</code>.</li> </ol> <p>Question 6</p> <p>Dans cette question, on souhaite programmer l'annulation de la suppression d'un maillon (effectu\u00e9e en question 5) toujours d'apr\u00e8s la m\u00e9thode des liens dansants. Cette fonction aura pour prototype : liste.h (extrait)<pre><code>void remettre_maillon(Liste *l, Maillon *m)\n</code></pre> Les param\u00e8tres sont une liste <code>l</code> et un pointeur <code>m</code> vers le maillon <code>m</code> qui a \u00e9t\u00e9 supprim\u00e9 de la liste (mais conserv\u00e9 intact en m\u00e9moire).  Cette fonction modifiera la liste <code>l</code>, par contre elle ne modifiera pas le maillon <code>m</code>. </p> <ol> <li>Identifier tous les cas particulier en fonction de <code>l</code> et de <code>m</code>. J'en ai personnellement identifi\u00e9 trois... R\u00e9fl\u00e9chir \u00e0 quels tests on pourrait \u00e9crire pour les identifier dans un programme C.</li> <li>Dans le fichier <code>liste.c</code>, impl\u00e9menter la fonction <code>remettre_maillon</code>.</li> </ol>"},{"location":"domino/#4-implementation-du-backtracking","title":"4. Impl\u00e9mentation du backtracking","text":"<p>On s'attaque maintenant \u00e0 la programmation du backtracking (retour sur trace) en lui-m\u00eame. Pour cela on maintiendra en m\u00e9moire deux listes doublement cha\u00een\u00e9es :</p> <ul> <li>une liste <code>sac</code> : qui contient tous les dominos encore disponibles pour former la cha\u00eene de dominos</li> <li>une liste <code>chaine</code> : qui repr\u00e9sente la cha\u00eene de domino actuellement en cours de construction, les dominos de cette liste auront des enchainements valides</li> </ul> <p>L'algorithme est le suivant :</p> <ul> <li>Si le sac est vide : c'est gagn\u00e9</li> <li>Sinon, on parcourt les maillons <code>m</code> du <code>sac</code></li> <li>Pour chaque maillon <code>m</code> :<ul> <li>S'il est valide d'ajouter le maillon correspondant \u00e0 droite de la <code>chaine</code> (\u00e9ventuellement apr\u00e8s rotation) : on supprime (temporairement) <code>m</code> du <code>sac</code>, on ajoute le domino \u00e0 droite de la <code>chaine</code> et on recommence r\u00e9cursivement avec ce nouveau sac et cette nouvelle cha\u00eene.</li> <li>Si l'appel r\u00e9cursif a \u00e9chou\u00e9 on replace <code>m</code> dans le sac avec la m\u00e9thode des liens dansants, on enleve le domino correspondant de la <code>chaine</code> et on continue le parcours.</li> <li>Si l'appel r\u00e9cursif r\u00e9ussit, on renvoie <code>true</code> sans rien changer \u00e0 <code>chaine</code> (c'est gagn\u00e9)</li> </ul> </li> <li>Si on arrive \u00e0 la fin du parcours du sac sans jamais avoir r\u00e9ussi le backtracking alors on renvoie <code>false</code>. </li> </ul> <p>Le prototype de la fonction correspondante sera : backtracking.h (extrait)<pre><code>bool bt_chaine(Liste *sac, Liste *chaine)\n</code></pre></p> <p>Question 7</p> <p>Impl\u00e9menter dans <code>backtracking.c</code> la fonction <code>bt_chaine</code>. Pour vous aider un squelette vous est fourni.</p> <p>Question 8</p> <p>Tester votre programme sur les diff\u00e9rents jeux de tests (fichiers <code>.txt</code>). Combien de dominos r\u00e9ussissez-vous \u00e0 enchainer ? R\u00e9fl\u00e9chir \u00e0 la complexit\u00e9 de l'approche par backtracking.</p> <p>Remarque</p> <p>Il existe une m\u00e9thode beaucoup plus efficace que le backtracking, reposant sur les circuits eul\u00e9riens dans les multi-graphes, pour r\u00e9soudre ce probl\u00e8me.</p>"},{"location":"i8080/","title":"\u00c9mulateur Intel 8080","text":"<p>Le processeur Intel 8080 est un des tous premiers processeurs grand public, con\u00e7u et fabriqu\u00e9 par la soci\u00e9t\u00e9 Intel en 1974. Dot\u00e9 d'un riche jeu d'instructions (pour l'\u00e9poque) et d'un bus d'adresse sur 16 bits permettant d'adresser 64kio de m\u00e9moire, il a rencontr\u00e9 un franc succ\u00e8s.</p>  Le processeur Intel 8080 (Wikipedia)  <p>L' Intel 8080 a \u00e9t\u00e9 utilis\u00e9 pour la conception des premiers PC dont le plus connu est l'Altair 8080. Des versions proches du i8080, telles que le processeur Zilog Z80, ont \u00e9t\u00e9 utilis\u00e9es comme processeurs des console de jeu GameBoy de Nintendo (1989) et Master System de Sega (1985). Le successeur du Intel 8080 sera le Intel 8086 (1978) qui est le premier processeur de la famille x86. Aujourd'hui la plupart des processeurs grand public sont con\u00e7us sur l'architecture x86-64 et on retrouve dans leurs jeux d'instructions des similitudes avec l'i8080. </p> <ul> <li> <p>L'Altair 8080 (1975)</p> <p></p> </li> <li> <p>Le PC ZX Spectrum (1982)</p> <p></p> </li> <li> <p>La console Master System (Sega)</p> <p></p> </li> <li> <p>Le jeu Space Invaders sur borne d'arcade</p> <p></p> </li> </ul> <p>(cr\u00e9dits : Wikipedia)</p>"},{"location":"i8080/#objectifs","title":"Objectifs","text":"<p>Dans ce projet en langage C, je vous propose :</p> <ul> <li>D'\u00e9crire enti\u00e8rement un programme en langage C qui \u00e9mule le fonctionnement du processeur i8080.</li> <li>De tester son fonctionnement en lui faisant ex\u00e9cuter des petits programmes \u00e9crits par nos soins en langage machine. </li> <li>De r\u00e9aliser des tests plus pouss\u00e9s, en faisant tourner des vrais programmes de diagnostique CPU, garantissant ainsi la fid\u00e9lit\u00e9 du travail obtenu.</li> <li>D'ex\u00e9cuter sur notre processeur le jeu Space Invaders : pour cela il nous faudra aussi impl\u00e9menter une \u00e9mulation du mat\u00e9riel de la borne d'arcade du jeu.</li> </ul>"},{"location":"i8080/#competences-travaillees","title":"Comp\u00e9tences travaill\u00e9es","text":"<p>Ce projet vous permettra de renforcer les comp\u00e9tences suivantes au programme de la MP2I/MPI :</p> <ul> <li>Programmer proprement en langage C</li> <li>Comprendre le fonctionnement d'un ordinateur dans un contexte simple (relativement aux processeurs actuels)</li> <li>Comprendre la repr\u00e9sentation des programmes et des donn\u00e9es en machine (base 2, entiers sign\u00e9s et non sign\u00e9s, compl\u00e9ment \u00e0 2, cha\u00eenes de caract\u00e8res, langage machine...)</li> <li>Comprendre la gestion de la m\u00e9moire d'un ordinateur : en particulier, on impl\u00e9mentera la fameuse Pile d'ex\u00e9cution et on comprendra son int\u00e9r\u00eat, on comprendra les notions de registre, RAM et ROM.</li> </ul> <p>Attention</p> <p>Les connaissances sp\u00e9cifiques pr\u00e9sent\u00e9es ici sur l'architecture, l'\u00e9mulation mat\u00e9rielle et l'i8080 ne sont bien \u00e9videmment pas au programme de MP2I/MPI. Voyez ceci comme un projet pour aiguiser vos comp\u00e9tences et \u00e9largir votre culture en informatique.</p>"},{"location":"i8080/#sources-et-liens-utiles","title":"Sources et liens utiles","text":"<p>Pour r\u00e9aliser ce projet, je me suis bas\u00e9 sur les sources suivantes (mais aussi sur des lectures de forums pour combler les manques).</p> <ul> <li>Intel 8080 Assembly Language Programming Manual rev. B, Intel Corp, 1975 (disponible sur Altairclone.com)</li> <li>Intel 8080 Microcomputer Systems User's Manual, Intel Corp, 1975</li> <li>8080/8085 Assembly language programming manual, Intel Corp, 1981 (disponible sur Altairclone.com)</li> <li>Un magnifique tableau du jeu d'instructions : Intel 8080 instruction set</li> <li>Computer archeology : un site internet fantastique sur lequel des passion\u00e9s ont d\u00e9sassembl\u00e9 et comment\u00e9 l'int\u00e9gralit\u00e9 du code source assembleur du jeu Space Invaders </li> <li>ASM80.com : un \u00e9diteur en ligne magnifique permettant d'\u00e9crire, ex\u00e9cuter et compiler des programmes en assembleur pour i8080 (entre autres...). Merci \u00e0 son auteur !</li> </ul>"},{"location":"links/","title":"Liens utiles","text":""},{"location":"links/#cpge-mp2impi","title":"CPGE MP2I/MPI","text":"<ul> <li> Le site de la classe MPI</li> <li>Le site du lyc\u00e9e Leconte de Lisle</li> <li>prepas.org : site d'information de l'UPS</li> </ul>"},{"location":"links/#concours","title":"Concours","text":"<p>Des informations utiles et surtout des annales et des rapports sur les sites des concours.</p> <ul> <li>SCEI : Gestion des concours</li> <li>Concours commun INP</li> <li>Concours commun Mines-Ponts</li> <li>Concours Centrale-Sup\u00e9lec</li> <li>Concours de l'\u00e9cole Polytechnique</li> <li>Concours des \u00e9coles normales sup\u00e9rieures (ENS)<ul> <li>Rennes</li> <li>Paris Saclay</li> <li>Lyon</li> <li>Paris Ulm</li> </ul> </li> </ul>"},{"location":"preparationoraux/","title":"Pr\u00e9paration oraux","text":""},{"location":"preparationoraux/#ccinp","title":"CCINP","text":"<ul> <li>Les modalit\u00e9s de passage</li> </ul>"},{"location":"preparationoraux/#lenvironnement-technique-a-installer-sur-sa-machine-perso","title":"L'environnement technique (\u00e0 installer sur sa machine perso !)","text":"<ul> <li>Le fichier Makefile</li> <li>L'environnement technique</li> <li>Le fichier lisez-moi</li> </ul>"},{"location":"preparationoraux/#les-annales","title":"Les annales","text":"<ul> <li>Sujets 0</li> <li>Fichiers sujets 0</li> <li>Sujets 2023</li> <li>Fichiers sujets 2023</li> <li>Sujets 2024</li> <li>Fichiers sujets 2024</li> </ul>"},{"location":"snake/","title":"Projet en C : jeu Snake","text":"Le jeu Snake"},{"location":"snake/#1-installer-la-bibliotheque-de-developpement","title":"1. Installer la biblioth\u00e8que de d\u00e9veloppement","text":"<p>Pour r\u00e9aliser le jeu, nous allons nous reposer sur une biblioth\u00e8que de d\u00e9veloppement appel\u00e9e SDL (Simple DirectMedia). Nous utiliserons la version 2. Un wiki est disponible en ligne pour lire la documentation.</p> <p>Cette biblioth\u00e8que fournit des fonctions permettant assez facilement de cr\u00e9er une fen\u00eatre de d'y dessiner. Elle est capable d'utiliser les capacit\u00e9s d'acc\u00e9l\u00e9ration de la carte graphique \u00e9ventuellement pr\u00e9sente dans l'ordinateur. Elle permet \u00e9galement d'afficher des images, de jouer des sons, de g\u00e9rer les entr\u00e9es clavier, etc. Tout ce qu'il faut pour programmer un petit jeu vid\u00e9o.</p> <p>Sous Linux, l'installation de la biblioth\u00e8que est tr\u00e8s simple puisqu'elle est normalement disponible dans les paquets de votre distribution. Par exemple, pour les distributions de la famille Debian (dont Ubuntu) la commande d'installation est : <pre><code>sudo apt install libsdl2-dev libsdl2-2.0-0\n</code></pre></p> <p>On peut \u00e9galement installer certains paquets optionnels comme : <pre><code>sudo apt install libsdl2-image-dev libsdl2-image-2.0-0\n</code></pre> pour permettre d'afficher des images.</p> <p>Pour v\u00e9rifier si l'installation a fonctionn\u00e9, on peut par exemple ex\u00e9cuter la commande : <pre><code>sdl2-config --version\n</code></pre></p>"},{"location":"snake/#2-creer-une-fenetre-graphique","title":"2. Cr\u00e9er une fen\u00eatre graphique","text":"<p>Pour nous familiariser avec SDL, nous allons commencer par cr\u00e9er une fen\u00eatre graphique, attendre 5 secondes, et quitter :</p> <p>Fichier <code>main.c</code> minimal</p> <pre><code>#include &lt;SDL2/SDL.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, char * argv[]) {\n    SDL_Init(SDL_INIT_VIDEO);\n    SDL_Window *fenetre = SDL_CreateWindow(\"Snake974\", 50, 50, 640, 480, 0);\n\n    SDL_Delay(5000); // Attendre 5 sec\n    SDL_DestroyWindow(fenetre);\n    SDL_Quit();\n\n    return EXIT_SUCCESS;\n}\n</code></pre> <p>On a inclu les fichiers d'en-t\u00eate standard et celui correspondant \u00e0 la biblioth\u00e8que SDL. Nous notons que toutes les fonctions et noms concernant la biblioth\u00e8que SDL sont pr\u00e9fix\u00e9s par <code>SDL_</code>.</p> <p>Le programme pr\u00e9c\u00e9dent commence par initialiser SDL avec la fonction <code>SDL_Init</code>. Cette fonction a pour param\u00e8tre un entier qui repr\u00e9sente les options d'initialisation. Pour construire cet entier, on se sert de constantes pr\u00e9d\u00e9finies dans la biblioth\u00e8que appel\u00e9es drapeaux comme <code>SDL_INIT_VIDEO</code> pour signifier qu'on veut initialiser les graphismes. Il est possible de combiner plusieurs drapeaux avec l'op\u00e9rateur <code>|</code> qui est le OU bit \u00e0 bit. Par exemple, si on veut initialiser le son et la vid\u00e9o on \u00e9crit : <pre><code>SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO);\n</code></pre></p> <p>On appelle ensuite la focntion <code>SDL_CreateWindow</code> permettant de cr\u00e9er une fen\u00eatre. Ses param\u00e8tres sont le titre de la fen\u00eatre, sa position <code>(50, 50)</code>, ses dimensions <code>640x480</code>. Le dernier param\u00e8tre est un entier pour les options que l'on fixe encore une fois \u00e0 l'aide de drapeaux. J'ai mis ici 0 pour dire que je voulais les options par d\u00e9faut (aucun drapeau). </p> <p>La suite du programme est claire : on demande une attente de 5000ms puis on fait le m\u00e9nage en d\u00e9truisant dans le bon ordre les objets construits pr\u00e9c\u00e9demment. En effet, on se doute bien que la fonction <code>SDL_CreateWindow</code> alloue de la m\u00e9moire sur le tas et qu'il est n\u00e9cessaire de la lib\u00e9rer avec une fonction de destruction, c'est le r\u00f4le de <code>SDL_DestroyWindow</code>.</p> <p>On peut compiler le jeu avec la commande : Compilation avec SDL2<pre><code>gcc main.c -o snake $(sdl2-config --cflags --libs)\n</code></pre> On utilise ici l'outil <code>sdl2-config</code> qui construit automatiquement les param\u00e8tres \u00e0 ajouter la ligne de compilation usuelle pour que le programme soit li\u00e9 \u00e0 la biblioth\u00e8que SDL.</p>  Fen\u00eare du jeu (vide pour l'instant)"},{"location":"snake/#3-la-gestion-des-erreurs-dans-sdl","title":"3. La gestion des erreurs dans SDL","text":"<p>Les appels aux fonctions de la biblioth\u00e8que SDL peuvent provoquer des erreurs. Dans ce cas, les fonctions retournent g\u00e9n\u00e9ralement un code d'erreur (valeur non nulle) ou un pointeur <code>NULL</code> selon les cas.</p> <p>Il faut donc en th\u00e9orie \u00e0 chaque appel de fonction de SDL, v\u00e9rifier sa valeur de retour. Pour nous faciliter la vie, la biblioth\u00e8que SDL fournit la fonction <code>SDL_GetError()</code> qui retourne une cha\u00eene de caract\u00e8res d\u00e9crivant l'erreur rencontr\u00e9e. Voil\u00e0 comment on peut adapter le code pr\u00e9c\u00e9dent :</p> <p>Illustration du traitement d'erreurs</p> <pre><code>#include &lt;SDL2/SDL.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, char * argv[]) {\n    if (SDL_Init(SDL_INIT_VIDEO) != 0) {\n        fprintf(stderr, \"Erreur lors de l'initialisation : %s \\n\", SDL_GetError());\n        exit(EXIT_FAILURE);\n    }\n\n    SDL_Window *fenetre = SDL_CreateWindow(\"Snake974\", 50, 50, 640, 480, 0);\n    if (fenetre == NULL) {\n        fprintf(stderr, \"Erreur lors de la cr\u00e9ation de la fen\u00eatre : %s \\n\", SDL_GetError());\n        exit(EXIT_FAILURE);\n    }\n\n    SDL_Delay(5000); // Attendre 5 sec\n    SDL_DestroyWindow(fenetre);\n    SDL_Quit();\n\n    return EXIT_SUCCESS;\n}\n</code></pre> <p>Avertissement</p> <p>Dans toute la suite, pour me concentrer uniquement sur l'essentiel, je n'inclurai aucune autre v\u00e9rification d'erreur SDL, mais cela doit faire partie du travail...</p>"},{"location":"snake/#3-construire-et-afficher-la-grille-du-jeu","title":"3. Construire et afficher la grille du jeu","text":"<p>Commen\u00e7ons maintenant \u00e0 d\u00e9finir \u00e0 quoi ressemblera le jeu. Notre jeu sera se d\u00e9roulera dans une arene qui est une grille rectangulaire de blocs carr\u00e9s. On notera <code>ARENA_W</code> la largeur de l'arene en nombre de blocs, <code>ARENA_H</code> sa hauteur et <code>BLOCK_SIZE</code> la longueur du c\u00f4t\u00e9 d'un bloc en pixels.</p> <p>L'ar\u00e8ne pourra contenir les types de bloc suivants :</p> <ul> <li><code>VIDE</code> : bloc vide</li> <li><code>WALL</code> : qui repr\u00e9sente un mur</li> <li><code>COCO</code> : qui repr\u00e9sente une noix de coco</li> <li><code>SNAKE</code> : qui repr\u00e9sente une partie du corps du serpent</li> </ul> <p>Cela fait de nombreuses constantes \u00e0 d\u00e9finir, nous utilisons pour cela un fichier d'en-t\u00eate <code>main.h</code> pour d\u00e9clarer les valeurs publiques (que tout le code peut du projet peut utiliser).</p> <p>Fichier <code>main.h</code></p> <pre><code>#ifndef MAIN_H\n#define MAIN_H\n\n// Position et dimensions de la fenetre\n#define WIN_W 640\n#define WIN_H 480\n#define WIN_X 50\n#define WIN_Y 50\n\n// Dimensions de l'arene \n#define ARENA_W 20\n#define ARENA_H 10\n#define B_SIZE 20\n\n// Types de blocs\n#define VIDE 0\n#define WALL 1\n#define COCO 2\n#define SNAKE 4\n\n/* L'arene est d\u00e9finie comme une matrice\n   de blocs */\ntypedef int Arena[ARENA_W][ARENA_H];\n\n#endif\n</code></pre> <p>Il suffira ensuite d'inclure ce fichier d'en-t\u00eate dans n'importe quel fichier .c pour pouvoir utiliser ces d\u00e9finitions : <pre><code>#include \"main.h\"\n</code></pre></p> <p>Attention</p> <p>Notez bien la pr\u00e9sence de guillements \"\" et non de chevrons &lt;&gt; quand on inclus un fichier situ\u00e9 dans le r\u00e9pertoire courant.</p> <p>Notez qu'on en a profit\u00e9 pour ajouter certains param\u00e8tres comme les dimensions de la fen\u00eatre. Il est toujours pr\u00e9f\u00e9rable que de telles constantes n'apparaissent pas directement dans un code source afin de faciliter la lecture et la modification.</p>"},{"location":"snake/#a-systeme-de-coordonnees","title":"A. Syst\u00e8me de coordonn\u00e9es","text":"<p>C'est le moment de faire le point sur le syst\u00e8me de coordonn\u00e9es utilis\u00e9 par SDL. SDL d\u00e9finit la position d'un pixel \\((x, y)\\) ainsi :</p>  Syst\u00e8me de coordonn\u00e9es en SDL (source : Wikipedia)  <p>L'origine \\((0, 0)\\) est situ\u00e9e en haut \u00e0 gauche. La coordonn\u00e9e \\(x\\) repr\u00e9sente l'abscisse du point et la coordonn\u00e9e \\(y\\) sont ordonn\u00e9e, sauf que l'axe des ordonn\u00e9es est orient\u00e9 vers le bas.</p> <p>Note</p> <p>Nous utiliserons par la suite toujours ces conventions pour parler de coordonn\u00e9es. En particulier les coordonn\u00e9es des blocs. Ainsi le bloc de coordonn\u00e9es (0, 0) sera celui situ\u00e9 en haut \u00e0 gauche et le bloc de coordonn\u00e9es (0, 1) celui situ\u00e9 juste en dessous de lui.</p>"},{"location":"snake/#b-dessin-de-larene-du-jeu","title":"B. Dessin de l'ar\u00e8ne du jeu","text":"<p>Pour dessiner en SDL, il est n\u00e9cessaire de cr\u00e9er un objet appel\u00e9 renderer qui est associ\u00e9 \u00e0 une fen\u00eatre et qui est en charge du dessin dans cette fen\u00eatre. Le renderer est construit avec la fonction <code>SDL_CreateRenderer</code> et d\u00e9truit avec la fonction <code>SDL_DestroyRenderer</code>. On met \u00e0 jour le code <code>main.c</code> ainsi :</p> <p>Cr\u00e9ation et destruction du renderer</p> <pre><code>#include &lt;SDL2/SDL.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, char * argv[]) {\n    SDL_Init(SDL_INIT_VIDEO);\n    SDL_Window *fenetre = SDL_CreateWindow(\"Snake974\", 50, 50, 640, 480, 0);\n    SDL_Renderer *renderer = SDL_CreateRenderer(fenetre, -1, SDL_RENDERER_ACCELERATED);\n\n    SDL_Delay(5000); // Attendre 5 sec\n\n    SDL_DestroyRenderer(renderer);\n    SDL_DestroyWindow(fenetre);\n    SDL_Quit();\n\n    return EXIT_SUCCESS;\n}\n</code></pre> <p>Il existe ensuite une multitude de fonctions de dessin, prenant en param\u00e8tre l'instance du renderer.</p> Fonction Effet <code>SDL_SetRenderDrawColor(renderer, r, g, b, a)</code> Change la couleur de dessin \\((r,g,b,a)\\) <code>SDL_RenderClear(renderer)</code> Efface tout et color le fond avec la couleur actuelle <code>SDL_RenderDrawPoint(renderer, x, y)</code> Dessine un point <code>SDL_RenderDrawLine(renderer, x1, y1, x2, y2)</code> Dessine une ligne <code>SDL_RenderDrawRect(renderer, &amp;rect)</code> Dessine un rectangle <code>SDL_RenderFillRect(renderer, &amp;rect)</code> Remplit un rectangle <code>SDL_RenderPresent(renderer)</code> Met \u00e0 jour l'affichage <p>Attention</p> <p>Noter l'importance de la fonction <code>SDL_RenderPresent</code>. Tout dessin ne sera visible qu'une fois la mise \u00e0 jour de l'affichage effectu\u00e9.</p> <p>Notre grille \u00e9tant rectangulaire, ces fonctions primitives de dessin devraient suffire. Voici quelques remarques pour bien comprendre ces fonctions :</p> <p>Les couleurs</p> <p>En SDL les couleurs sont cod\u00e9es sur 4 octets, c'est-\u00e0-dire 4 valeurs enti\u00e8res \\((r, g, b, a)\\) entre 0 et 255 pour les composantes rouge (r), vert (g) et bleu (b); la composante alpha (a) repr\u00e9sente le niveau de transparence (0 = transparent, 255 = opaque).</p> <p>Les rectangles</p> <p>SDL impl\u00e9mente son propre type <code>SDL_Rect</code> pour repr\u00e9senter un rectangle. Voici un exemple de fonctionnement : <pre><code>SDL_Rect rectangle = {20, 45, 100, 200}; // (x, y, width, height)\nSDL_RenderDrawRect(renderer, &amp;rectangle);\n</code></pre></p> <p>Exercice : dessiner l'ar\u00e8ne</p> <p>\u00c9tudiez le code ci-dessous, puis compl\u00e9ter la fonction <code>draw_arena</code>, qui s'occupe de dessiner l'ar\u00e8ne qu'on lui passe en param\u00e8tre. Cette fonction devra colorer chaque type de bloc avec une couleur diff\u00e9rente. On rappelle que les blocs doivent avoir une taille de <code>B_SIZE</code> pixels.</p> <pre><code>#include &lt;SDL2/SDL.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include \"main.h\"\n\n\n/* Construit une ar\u00e8ne enti\u00e8rement vide */\nvoid init_arena(Arena mat) {\n    for (int x = 0; x &lt; ARENA_W; x++) {\n        for (int y = 0; y &lt; ARENA_H; y++) {\n            mat[x][y] = VIDE;\n        }\n    }\n}\n\nvoid draw_arena(SDL_Renderer *renderer, Arena mat) {\n    /* A VOUS DE JOUER */\n}\n\nint main(int argc, char * argv[]) {\n    SDL_Init(SDL_INIT_VIDEO);\n    SDL_Window *fenetre = SDL_CreateWindow(\"Snake974\", WIN_X, WIN_Y, WIN_W, WIN_H, 0);\n    SDL_Renderer *renderer = SDL_CreateRenderer(fenetre, -1, SDL_RENDERER_ACCELERATED);\n\n    Arena mat;\n    init_arena(mat);\n    mat[3][5] = WALL; // Pour tester\n    mat[6][6] = SNAKE; // Toujours pour tester\n    mat[6][7] = SNAKE;\n    mat[6][8] = SNAKE;\n    mat[15][2] = COCO;\n    draw_arena(renderer, mat);\n\n    SDL_RenderPresent(renderer);\n\n    SDL_Delay(5000); // Attendre 5 sec\n\n    SDL_DestroyRenderer(renderer);\n    SDL_DestroyWindow(fenetre);\n    SDL_Quit();\n\n    return EXIT_SUCCESS;\n}\n</code></pre> <p>Voil\u00e0 ce que vous devriez obtenir \u00e0 l'\u00e9tat actuel du jeu :</p>  Dessin de l'ar\u00e8ne  Aide <p>Si vous n'y parvenez pas, pensez le probl\u00e8me ainsi :</p> <ul> <li>commencez par choisir la couleur de fond puis tout effacer (clear)</li> <li>on parcourt chaque case de la matrice <code>mat</code> on construit un <code>bloc</code> qui est un <code>SDL_Rect</code> de bonnes dimensions et plac\u00e9 au bon endroit</li> <li>On remplit (fill) <code>bloc</code> avec la bonne couleur</li> <li>On dessine (draw) <code>bloc</code> avec la couleur de contour des blocs</li> </ul> <p>Bon, nous avon\u00e7ons bien mais il reste encore un petit probl\u00e8me : il n'y a pas de murs au bord de notre grille de jeu : le serpent pourrait s'\u00e9chapper. \u00c9crivons une petite fonction pour ajouter des murs tout autour de l'ar\u00e8ne.</p> <p>Exercice : mur d'enceinte</p> <p>\u00c9crire une fonction <code>void mur_enceinte(Arena mat)</code> qui assigne la valeur <code>WALL</code> \u00e0 toutes les cases sur le pourtour de la grille <code>mat</code>.</p>"},{"location":"snake/#4-une-structure-de-donnees-pour-le-serpent","title":"4. Une structure de donn\u00e9es pour le serpent","text":"<p>Dans cette partie, nous allons proposer une structure de donn\u00e9es pour g\u00e9rer le serpent. Le serpent peut \u00eatre impl\u00e9ment\u00e9 sous forme d'une liste simplement cha\u00een\u00e9e de blocs. Cette structure permet ais\u00e9ment de faire \u00e9voluer le serpent lorsqu'il avance ou lorsqu'il grandit.</p>"},{"location":"snake/#a-compilation-separee","title":"A. Compilation s\u00e9par\u00e9e","text":"<p>Comme le code se complexifie, il serait bon de commencer \u00e0 le s\u00e9parer dans plusieurs fichiers. On introduit un nouveau fichier d'en-t\u00eate :</p> Fichier <code>serpent.h</code> <pre><code>#ifndef SERPENT_H\n#define SERPENT_H\n\n#include &lt;stdbool.h&gt;\n#include \"main.h\"\n\nstruct maillon_s {\n    /* Coordonn\u00e9es du bloc */\n    int x;\n    int y;\n\n    /* Maillon suivant (de la queue vers la t\u00eate) */\n    struct maillon_s *suivant;\n};\ntypedef struct maillon_s Maillon;\n\n/* Sens de d\u00e9placement */\n#define RIGHT 0\n#define UP 1\n#define DOWN 2\n#define LEFT 3\n\nstruct serpent_s {\n    Maillon *queue; /* Premier maillon : fin du serpent */\n    Maillon *tete; /* Dernier maillon : t\u00eate du serpent */\n    int direction; /* Sens de d\u00e9placement */\n};\ntypedef struct serpent_s Serpent;\n\n/* Coordonn\u00e9es du bloc vers lequel va le serpent */\nextern int prochain_x(const Serpent *s);\nextern int prochain_y(const Serpent *s);\n\n/* Teste si la case est occup\u00e9e par le serpent */\nextern bool appartient(const Serpent *s, int x, int y);\n\n/* Fait avancer le serpent */\nextern void avancer(Serpent *s);\n\n/* Fait grandir le serpent */\nextern void grandir(Serpent *s);\n\n/* Cr\u00e9er un serpent de longueur 1 positionn\u00e9 en (x, y) et\n   se d\u00e9placant dans la direction dir */\nSerpent *creer_serpent(int x, int y, int dir);\n\n/* Marque dans l'arene mat les cases occupees par le serpent */\nextern void place_serpent(const Serpent *s, Arena mat);\n\n#endif\n</code></pre> <p>Ce fichier d'en-t\u00eate d\u00e9clare les structures de donn\u00e9es impl\u00e9mentant le serpent ainsi que les fonctions utiles pour le manipuler. Ces fonctions seront impl\u00e9ment\u00e9es dans le fichier <code>serpent.c</code>, ressemblant \u00e0 :</p> serpent.c<pre><code>#include \"serpent.h\"\n\nint prochain_x(const Serpent* s) {\n    /* A VOUS DE JOUER */\n}\n/* etc */\n</code></pre> <p>Votre projet contient maintenant 4 fichiers : <code>main.c</code>, <code>main.h</code>, <code>serpent.h</code>, <code>serpent.c</code>. Et la compilation s'obtient avec les commandes : <pre><code>    gcc -c main.c $(sdl2-config --cflags)\n    gcc -c serpent.c\n    gcc main.o serpent.o -o snake $(sdl2-config --cflags --libs)\n</code></pre> Cela devient fastidieux ! De plus \u00e0 chaque modification du projet, on peut se torturer \u00e0 se demander quel(s) fichier(s) doivent \u00eatre recompil\u00e9s ou pas et dans quel ordre...</p> <p>Nous allons utiliser le logiciel <code>make</code> pour nous faciliter la t\u00e2che. Pour fonctionner, cet outil a besoin de disposer d'un fichier nomm\u00e9 <code>Makefile</code> \u00e0 la racine de notre projet. Ce fichier d\u00e9crit un ensemble de cibles, c'est-\u00e0-dire de fichiers \u00e0 compiler, suivi de ses d\u00e9pendances et de la commande de compilation. \u00c9crivons ce fichier :</p> <p>Fichier <code>Makefile</code></p> <p>Attention, les tabulations utilis\u00e9es sont importantes et doivent \u00eatre de vraies tabulation (pas une succession d'espaces). Il faudra aussi adapter les valeurs de <code>CC</code>, <code>CFLAGS</code> et <code>LIBS</code> selon votre propre configuration. Makefile<pre><code>CC=gcc # nom du compilateur\n\n# Resultat de la commande sdl2-config --cflags\nCFLAGS= -I/usr/local/include -I/usr/local/include/SDL2 -D_REENTRANT -D_THREAD_SAFE\n\n# Resultat de la commande sdl2-config --libs\nLIBS= -L/usr/local/lib -lSDL2\n\n.PHONY: clean\n\nsnake: main.o serpent.o\n    $(CC) main.o serpent.o -o snake $(CFLAGS) $(LIBS)\n\nmain.o: main.h serpent.h main.c\n    $(CC) -c main.c $(CFLAGS)\n\nserpent.o: main.h serpent.h serpent.c\n    $(CC) -c serpent.c\n\nclean:\n    rm -f *.o\n</code></pre></p> <p>Une fois ce fichier renseign\u00e9, l'appel \u00e0 la commande <code>make</code> compile automatiquement la premiere cible. Ici, la premi\u00e8re cible est l'ex\u00e9cutable <code>snake</code>. En cas de modification du code, <code>make</code> est capable de savoir exactement ce qui a besoin d'\u00eatre recompil\u00e9 : cela \u00e9vite de recompiler enti\u00e8rement un projet \u00e0 chaque une petite modification.</p> <p>De plus nous avons ajout\u00e9 une fausse (PHONY) cible <code>clean</code> qui fait le m\u00e9nage en supprimant les fichiers interm\u00e9diaires devenus inutiles.</p> <p>R\u00e9sumons, d\u00e9sormais la commande <code>make</code> permet compiler ou recompuler tout le projet. La commande <code>make clean</code> permet de faire le m\u00e9nage.</p>"},{"location":"snake/#b-implementation-des-operations","title":"B. Impl\u00e9mentation des op\u00e9rations","text":"<p>Nous allons maintenant impl\u00e9menter dans <code>serpent.c</code> les op\u00e9rations d\u00e9crites dans le fichier d'en-\u00eate <code>serpent.h</code>. Rappelons les structures de donn\u00e9es mises en jeu : Rappel de serpent.h<pre><code>    struct maillon_s {\n        /* Coordonn\u00e9es du bloc */\n        int x;\n        int y;\n\n        /* Maillon suivant (de la queue vers la t\u00eate) */\n        struct maillon_s *suivant;\n    };\n    typedef struct maillon_s Maillon;\n\n    /* Sens de d\u00e9placement */\n    #define RIGHT 0\n    #define UP 1\n    #define DOWN 2\n    #define LEFT 3\n\n    struct serpent_s {\n        Maillon *queue; /* Premier maillon : fin du serpent */\n        Maillon *tete; /* Dernier maillon : t\u00eate du serpent */\n        int direction; /* Sens de d\u00e9placement */\n    };\n    typedef struct serpent_s Serpent;\n</code></pre></p> <p>Voici une repr\u00e9sentation sch\u00e9matique d'un serpent qui occupe les blocs de coordonn\u00e9es \\((4,4)\\), \\((5, 4)\\), \\((6, 4)\\) et qui se d\u00e9place vers la droite. Notez bien que la liste commence avec l'\u00e9l\u00e9ment de fin du serpent, et remonte jusque la case de t\u00eate du serpent (en derni\u00e8re position dans la liste). La structure <code>Serpent</code> contient un pointeur permettant d'atteindre la t\u00eate du serpent en temps \\(O(1)\\).</p> <pre><code>flowchart LR\n    direction LR\n    subgraph Serpent\n        queue\n        tete\n        direction[direction = RIGHT]\n    end\n    queue --&gt; M1\n    tete --&gt; M3\n    subgraph M1[Maillon]\n        direction LR\n        x1[x = 4]\n        y1[y = 4]\n        suivant1[suivant]\n    end\n    suivant1 --&gt; M2\n    subgraph M2[Maillon]\n        direction LR\n        x2[x = 5]\n        y2[y = 4]\n        suivant2[suivant]\n    end\n    suivant2 --&gt; M3\n    subgraph M3[Maillon]\n        direction LR\n        x3[x = 6]\n        y3[y = 4]\n        suivant3[suivant]\n    end\n    N@{shape: lin-rect, label: \"NULL\", color: blue}\n    suivant3 --&gt; N</code></pre> <p>Exercice : Impl\u00e9mentation des op\u00e9rations</p> <p>Dans le fichier <code>serpent.c</code>, impl\u00e9mentez les op\u00e9rations :</p> <ol> <li><code>creer_serpent</code></li> <li><code>prochain_x</code> et <code>prochain_y</code></li> <li><code>appartient</code></li> <li><code>avancer</code></li> <li><code>grandir</code></li> <li><code>place_serpent</code></li> </ol> <p>Des indications sont fournies ci-dessous.</p> <p>Voici quelques indications pour vous aider dans votre t\u00e2che :</p> <ol> <li><code>creer_serpent</code> : il faudra allouer de la m\u00e9moire sur le tas pour la structure et pour le premier et unique maillon</li> <li><code>prochain_x</code> et <code>prochain_y</code> : les coordonn\u00e9es de la prochaine case se calculent \u00e0 partir de celles de la t\u00eate et de la direciton actuelle</li> <li><code>appartient</code> : c'est un parcours de liste</li> <li><code>avancer</code> : c'est ici que la structure propos\u00e9e est vraiment int\u00e9ressante : il suffit de calculer la prochaine case occup\u00e9e et d'ajouter un maillon pour cet emplacement qui sera la nouvelle t\u00eate, le maillon de queue quant \u00e0 lui sera supprim\u00e9 (ne pas oublier de lib\u00e9rer la m\u00e9moire...).</li> <li><code>grandir</code> : m\u00eame chose que l'op\u00e9ration pr\u00e9c\u00e9dente, mais on ne supprime pas cette fois l'\u00e9l\u00e9ment de queue : la longueur de la liste augmente donc de 1.</li> <li><code>place_serpent</code> : pas de difficult\u00e9 particuli\u00e8re, on parcourt la liste et on modifie les cases correspondantes de l'ar\u00e8ne.</li> </ol> <p>Remarque</p> <p>Pour le moment on ne se pr\u00e9occupe pas de savoir si les d\u00e9placements sont effectivement possibles (murs, collisions, sortie de l'ar\u00e8ne, ...).</p> <p>Attention</p> <p>Pensez bien aux cas limites de votre structure de liste !</p> <p>Exercice : Nettoyage</p> <p>Ajouter une op\u00e9ration <code>destroy_serpent</code> dont le but est de lib\u00e9rer la m\u00e9moire allou\u00e9e par un serpent. Vous ajouterez cette op\u00e9ration dans le fichier <code>serpent.h</code> en vous inspirant des autres prototypes, puis vous coderez l'impl\u00e9mentation dans <code>serpent.c</code>.</p>"},{"location":"snake/#c-un-serpent-anime","title":"C. Un serpent anim\u00e9 !","text":"<p>Nous sommes maintenant pr\u00eat pour cr\u00e9er une petite animation de serpent qui se d\u00e9place.</p> <p>Nous allons commencer par cr\u00e9er un serpent de taille 1 en position (3, 3) avec un d\u00e9placement vers la droite, puis le faire grandir 5 fois pour obtenir un serpent de taille 5.</p> <p>Ensuite, nous dessinons la sc\u00e8ne du jeu : on part d'une ar\u00e8ne vide, on ajoute le mur d'enceinte, puis on place le serpent. On met \u00e0 jour l'affichage pour voir le r\u00e9sultat.</p> <p>Pour faire d\u00e9placer le serpent, on utilise la fonction <code>avance</code> mais il faut alors recommencer le dessin complet de la sc\u00e8ne : remettre tout \u00e0 vide, mettre les murs, placer le serpent, actualiser l'affichage.</p> <p>Bref, en r\u00e9alisant plusieurs fois ces op\u00e9rations et en ajoutant des petites pauses de 0,5s entre chaque image, on obtient une animation. Testez maintenant votre code avec l'animation propos\u00e9e ci-dessous !</p> <p>Example</p> fonction main<pre><code>int main(int argc, char * argv[]) {\n    SDL_Init(SDL_INIT_VIDEO);\n    SDL_Window *fenetre = SDL_CreateWindow(\"Snake974\", WIN_X, WIN_Y, WIN_W, WIN_H, 0);\n    SDL_Renderer *renderer = SDL_CreateRenderer(fenetre, -1, SDL_RENDERER_ACCELERATED);\n\n    Serpent *s = creer_serpent(3, 3, RIGHT);\n    for (int k = 0; k &lt; 5; k++) {\n        grandir(s);\n    }\n\n    Arena mat;\n\n    for (int k = 0; k &lt; 8; k++) {\n        init_arena(mat);\n        mur_enceinte(mat);\n        place_serpent(s, mat);\n        draw_arena(renderer, mat);\n        SDL_RenderPresent(renderer);\n\n        SDL_Delay(500);\n        avancer(s);\n    }\n    s-&gt;direction = DOWN;\n    for (int k = 0; k &lt; 3; k++) {\n        init_arena(mat);\n        mur_enceinte(mat);\n        place_serpent(s, mat);\n        draw_arena(renderer, mat);\n        SDL_RenderPresent(renderer);\n\n        SDL_Delay(500);\n        avancer(s);\n    }\n    s-&gt;direction = LEFT;\n    for (int k = 0; k &lt; 8; k++) {\n        init_arena(mat);\n        mur_enceinte(mat);\n        place_serpent(s, mat);\n        draw_arena(renderer, mat);\n        SDL_RenderPresent(renderer);\n\n        SDL_Delay(500);\n        avancer(s);\n    }\n\n\n    SDL_DestroyRenderer(renderer);\n    SDL_DestroyWindow(fenetre);\n    SDL_Quit();\n\n    return EXIT_SUCCESS;\n}\n</code></pre>"},{"location":"snake/#5-la-boucle-principale","title":"5. La boucle principale","text":"<p>Nous nous approchons du but. Il nous reste \u00e0 programmer la boucle principale du jeu. En effet, le jeu est en fait une boucle infinie dans laquelle on effectue les actions suivantes :</p> <ol> <li>Dessiner la sc\u00e8ne</li> <li>Attendre</li> <li>Lire et prendre en compte les actions du joueur</li> <li>Mettre \u00e0 jour le serpent</li> </ol>"},{"location":"snake/#a-lire-les-evenements-clavier","title":"A. Lire les \u00e9v\u00e9nements clavier","text":"<p>Les \u00e9v\u00e9nements sont toutes les actions ext\u00e9rieures qui peuvent \u00eatre prises en compte par notre programme : appui sur des touches clavier, actions de la souris ou de la manette de jeu, utilisation de boutons de la fen\u00eatre, etc.</p> <p>SDL a un fonctionnement tr\u00e8s simple pour g\u00e9rer les \u00e9v\u00e9nements. \u00c0 chaque fois qu'un \u00e9v\u00e9nement se produit il est enregistr\u00e9 dans une file FIFO interne. Il existe ensuite une fonction de signature <code>int SDL_PollEvent(SDL_Event *event)</code> qui a pour but d'extraire un \u00e9l\u00e9ment de cette file. Elle retourne 1 si un \u00e9v\u00e9nement est effectivement d\u00e9fil\u00e9 et 0 si la file est vide.</p> <p>De plus, cette fonction attend un argument un pointeur vers une structure de type <code>SDL_Event</code> qui permet d'enregistrer les informations sur l'\u00e9v\u00e9nement qui vient d'\u00eatre extrait de la file. Notons <code>event</code> cette variable, nous aurons besoin des champs suivants :</p> <ul> <li><code>event.type</code> : d\u00e9crit le type d'\u00e9v\u00e9nement produit. On \u00e9coutera les \u00e9v\u00e9nements de type <code>SDL_KEYDOWN</code> (une touche est press\u00e9e) </li> <li><code>event.key.keysim.sym</code> : dans le cas o\u00f9 l'\u00e9v\u00e9nement concerne une touche, ce champ contient le caract\u00e8re concern\u00e9</li> </ul> <p>Pour r\u00e9sumer, voil\u00e0 \u00e0 quoi ressemble notre boucle principale :</p> <p>Boucle principale</p> <pre><code>int main(int argc, char * argv[]) {\n    SDL_Init(SDL_INIT_VIDEO);\n    SDL_Window *fenetre = SDL_CreateWindow(\"Snake974\", WIN_X, WIN_Y, WIN_W, WIN_H, 0);\n    SDL_Renderer *renderer = SDL_CreateRenderer(fenetre, -1, SDL_RENDERER_ACCELERATED);\n\n    Serpent *s = creer_serpent(3, 3, RIGHT);\n    for (int k = 0; k &lt; 5; k++) {\n        grandir(s);\n    }\n\n    Arena mat;\n\n    bool run = true;\n\n    while (run) {\n        init_arena(mat);\n        mur_enceinte(mat);\n        place_serpent(s, mat);\n        draw_arena(renderer, mat);\n        SDL_RenderPresent(renderer);\n\n        SDL_Delay(200);\n        SDL_Event event;\n        while (SDL_PollEvent(&amp;event) != 0) {\n            if (event.type == SDL_KEYDOWN) {\n                fprintf(stderr, \"Touche press\u00e9e : %c \\n\", event.key.keysym.sym); \n            }\n            if (event.key.keysym.sym == 'x') {\n                run = false; // touche pour quitter le jeu\n            }\n        }\n        avancer(s);\n    }\n\n    destroy_serpent(s);\n    SDL_DestroyRenderer(renderer);\n    SDL_DestroyWindow(fenetre);\n    SDL_Quit();\n\n    return EXIT_SUCCESS;\n}\n</code></pre> <p>Dans le code propos\u00e9, le jeu est une boucle principale qui fait avancer le serpent \u00e0 chaque it\u00e9ration et qui s'arr\u00eate lorsque le joueur appuie sur la touche <code>x</code>.</p> <p>Exercice : Diriger le serpent</p> <p>Modifiez la boucle principale propos\u00e9e pour qu'elle puisse prendre en compte des commandes de d\u00e9placement <code>q</code> (gauche), <code>s</code> (bas), <code>d</code> (droite), <code>z</code> (haut). L'action a effectu\u00e9 consiste \u00e0 modifier la direction de d\u00e9placement du serpent.</p> <p>Et voil\u00e0, notre jeu commence \u00e0 \u00eatre jouable ! Essayez et \u00e9tudiez le comportement du jeu lorsque le serpent percute un mur, marche sur lui-m\u00eame ou sors de la zone de jeu...</p>"},{"location":"snake/#b-gestion-des-collisions","title":"B. Gestion des collisions","text":"<p>Nous allons maintenant g\u00e9rer la mise \u00e0 jour du serpent. Pour l'instant le serpent ne fait qu'avancer... nous allons affiner son comportement.</p> <p>Exercice : Gestion des collisions</p> <p>Modifiez votre code pour que le jeu s'arr\u00eate lorsque le bloc vers lequel on va avancer est un mur ou appartient d\u00e9j\u00e0 au serpent. Dans ce cas, la partie est perdue.</p>"},{"location":"snake/#c-gestion-de-la-noix-de-coco","title":"C. Gestion de la noix de coco","text":"<p>Exercice : Noix de coco</p> <ol> <li>Ajouter dans votre fonction <code>main</code> deux variables locales : <pre><code>int coco_x;\nint coco_y;\n</code></pre> qui repr\u00e9sentent la position d'une noix de coco. Cette position doit \u00eatre choisie al\u00e9atoirement pour correspondre \u00e0 une case vide de l'ar\u00e8ne.</li> <li>Programmer le comportement suivant : si la case suivante est une noix de coco, alors plut\u00f4t qu'avancer on fait grandir le serpent. On choisit ensuite une nouvelle position valide de noix de coco.</li> </ol>"},{"location":"snake/#6-aller-plus-loin","title":"6. Aller plus loin","text":"<p>Voil\u00e0 ! vous avez un jeu fonctionnel minimal et il vous appartient maintenant de le faire \u00e9voluer ! Voici des pistes non limitatives :</p> <ul> <li>Programmer une touche pause</li> <li>Proposer des notions de score et de niveau. Plus le niveau augmente, plus le serpent est rapide.</li> <li>Ajouter des sons.</li> <li>Si la noix de coco reste trop longtemps en jeu alors elle devient un cocotier (= 1 mur)</li> <li>Possibilit\u00e9 d'avoir plusieurs noix de coco</li> <li>Possibilit\u00e9 d'avoir des pommes empoisonn\u00e9es en plus des noix de coco</li> <li>Possibilit\u00e9 d'avoir un bonus \u00e0 ramasser qui fait diminuer la longueur du serpent</li> <li>...</li> </ul>"},{"location":"aboutme/","title":"\u00c0 propos de moi","text":"<p>Je suis professeur de Sciences Informatiques en classes pr\u00e9paratoires aux grandes \u00e9coles (CPGE) MPI, au lyc\u00e9e Leconte de Lisle de la R\u00e9union. Dans cette section du site, vous trouverez des informations sur mon parcours, mes activit\u00e9s d'enseignement, mes anciennes activit\u00e9s de recherche. </p>"},{"location":"aboutme/enseignement/","title":"Enseignement","text":"<p>J'enseigne l'informatique (Num\u00e9rique et Sciences Informatiques) depuis 2012.</p>"},{"location":"aboutme/enseignement/#enseignement-en-cpge","title":"Enseignement en CPGE","text":"<ul> <li>depuis 2023 : Informatique MPI au Lyc\u00e9e Leconte de Lisle</li> <li>2022 : Informatique MPI/MPI* au Lyc\u00e9e Claude Fauriel</li> <li>2021 : MP2I au lyc\u00e9e Claude Fauriel</li> <li>2016-2023 : Option informatique MPSI/MP/MP* au lyc\u00e9e Claude Fauriel</li> <li>depuis 2023 : Informatique tronc commun en MP et PSI*</li> <li>2020-2021 : Informatique tronc commun en PC*</li> <li>2016-2021 : Informatique tronc commun en PCSI</li> <li>2016-2021 : Colles d'informatique Scilab en ECE et ECS</li> <li>depuis 2016 : Colles de math\u00e9matiques (MPSI, PCSI, ECE, ECS, MP* , MPI) </li> </ul>"},{"location":"aboutme/enseignement/#enseignement-a-luniversite","title":"Enseignement \u00e0 l'universit\u00e9","text":"<ul> <li>2015 : ATER \u00e0 l'universit\u00e9 de Nantes<ul> <li>Initiation \u00e0 la cryptographie (L1)</li> <li>TD/TP de programmation en C++ (L3)</li> <li>TD/TP de bases de donn\u00e9es relationnelles (L3)</li> </ul> </li> </ul>"},{"location":"aboutme/enseignement/#enseignement-pendant-mon-doctorat","title":"Enseignement pendant mon doctorat","text":"<ul> <li>2012 - 2015 : Mission d'enseignement ENS Rennes / Universit\u00e9 de Rennes 1<ul> <li>Le\u00e7ons d'agr\u00e9gation \u00e0 l'ENS de Rennes</li> <li>TD de probabilit\u00e9s et statistiques pour informaticiens \u00e0 l'ENS de Rennes </li> <li>INSA Rennes : TP de programmation fonctionnelle en Scheme</li> <li>Universit\u00e9 de Rennes M1 : logique, sp\u00e9cification, v\u00e9rification (TPs)</li> </ul> </li> </ul>"},{"location":"aboutme/parcours/","title":"Parcours acad\u00e9mique","text":"<ul> <li>2015 : Doctorat en informatique \u00e0 l'Universit\u00e9 de Rennes 1</li> <li>2012 : Agr\u00e9gation de math\u00e9matiques -- option D (informatique)</li> <li>2011 : Master Recherche en Informatique \u00e0 l'ENS Lyon</li> <li>2009 : Licence d'informatique \u00e0 l'Universit\u00e9 de Rennes 1</li> <li>2009 : Licence de math\u00e9matiques \u00e0 l'Universit\u00e9 de Rennes 1</li> <li>2008-2012 : Normalien au d\u00e9partement d'informatique de l'ENS Rennes</li> <li>2005-2008 : Classes pr\u00e9paratoires MPSI/MP* au Lyc\u00e9e Louis-le-Grand</li> <li>2005 : Baccalaur\u00e9at scientifique au Lyc\u00e9e de Vincendo</li> </ul>"},{"location":"algo/cfc/","title":"Composantes fortement connexes","text":""},{"location":"algo/cfc/#1-rappels-sur-la-connexite","title":"1. Rappels sur la connexit\u00e9","text":""},{"location":"algo/cfc/#a-composantes-connexes","title":"A. Composantes connexes","text":"<p>On notera \\(x \\Rightarrow^* y\\) la relation binaire : il existe un chemin du sommet \\(x\\) vers le sommet \\(y\\) dans un graphe donn\u00e9.</p> <p>Proposition</p> <p>Dans un graphe \\(G = (S, A)\\) non orient\u00e9, la relation binaire \\(\\Rightarrow^{*}\\)   est une relation d'\u00e9quivalence.</p> <p>D\u00e9finition (composantes connexes)</p> <p>Dans un graphe non orient\u00e9, les classes d'\u00e9quivalence de \\(R\\) sont appel\u00e9es composantes connexes du graphe.</p> <p>Remarque</p> <p>On peut \u00e9tendre la d\u00e9finition de composante connexe dans un graphe orient\u00e9 en oubliant l'orientation des arcs.</p>"},{"location":"algo/cfc/#algorithmes-les-parcours-de-graphes","title":"Algorithmes : les parcours de graphes","text":"<p>Les parcours de graphes, peu importe lequel, permettent de d\u00e9terminer les composantes connexes d'un graphe. Revoir le cours de 1\u00e8re ann\u00e9e et le chapitre 3 si besoin.</p>"},{"location":"algo/cfc/#b-composantes-fortement-connexes","title":"B. Composantes fortement connexes","text":"<p>Proposition</p> <p>Dans un graphe \\(G = (S, A)\\) orient\u00e9, la relation binaire  \\(xRy &lt;=&gt; (x \\Rightarrow^* y \\land y \\Rightarrow^* x)\\) est une relation d'\u00e9quivalence.</p> <p>D\u00e9finition (composantes fortement connexes)</p> <p>Dans un graphe orient\u00e9, Les classes d'\u00e9quivalences de \\(R\\) sont appel\u00e9es composantes fortement connexes (CFC) du graphe.</p> <p>Remarque</p> <p>Dans le cas des graphes non orient\u00e9s, les notions de composantes connexes et de composantes fortement connexes co\u00efncident, l'\u00e9tude des composantes fortement connexes n'est donc int\u00e9ressante que dans le contexte des graphes orient\u00e9s.</p> <p>Proposition</p> <p>Soit \\(G = (S, A)\\) un graphe, une partie \\(X\\) de \\(S\\) est une CFC si et seulement si :</p> <ol> <li>\\(\\forall x, y \\in X, xRy\\) c'est-\u00e0-dire qu'il existe un chemin de \\(x\\) vers \\(y\\) et r\u00e9ciproquement. </li> <li>\\(X\\) est satur\u00e9e, c'est-\u00e0-dire qu'il n'existe pas de partie \\(Y\\) telle que \\(X \\subset Y\\) strictement et \\(Y\\) v\u00e9rifie 1. Autrement dit, \\(X\\) est une partie maximale pour l'inclusion qui v\u00e9rifie 1.</li> </ol> <p>Le programme de 1\u00e8re ann\u00e9e ne nous dit pas comment calculer les composantes fortement connexes d'un graphe.</p>"},{"location":"algo/cfc/#2-tri-topologique","title":"2. Tri topologique","text":"<p>On se place maintenant dans le cadre d'un graphe \\(G = (S, A)\\) orient\u00e9.</p> <p>Le parcours en profondeur (DFS) r\u00e9cursif d'un graphe \\(G = (S, A)\\) permet d'obtenir un ordonnancement des sommets d'un graphe poss\u00e9ndant des propri\u00e9t\u00e9s int\u00e9ressantes.</p> <p>Commen\u00e7ons par rappeler l'algorithme r\u00e9cursif de parcours en profondeur. On utilisera le syst\u00e8me de couleurs suivant pour marquer les sommets :</p> <ul> <li>vert : sommet non explor\u00e9</li> <li>orange : sommet en cours d'exploration</li> <li>rouge : sommet dont l'exploration est termin\u00e9e</li> </ul> <pre><code>Variables globales : \n    un tableau de couleur c[x] pour chaque sommet x\n    une variable entiere t representant le temps logique\n\nInitialisation :\n    c[x] &lt;- vert pour tout sommet x\n    t &lt;- 0\n\nfonction EXPLORE(x: sommet) :\n    Si c[x] == vert Alors\n        c[x] &lt;- orange\n        d[x] &lt;- t\n        t &lt;- t + 1\n        Pour tout y dans Voisins(x) Faire\n            EXPLORE(y)\n        FinPour\n        f[x] &lt;- t\n        t &lt;- t + 1\n    Fin Si\n</code></pre> <p>Ainsi, nous avons ajouter quelques instructions pour enregistrer \u00e0 quels instants le parcours d'un sommet d\u00e9bute et finit.</p> <p>Proposition</p> <p>Les paires d'\u00e9venements \\(d(x) / f(x)\\) ordonn\u00e9es par le temps logique d'ex\u00e9cution forment une expression bien parenth\u00e9s\u00e9e.</p> <p>D\u00e9monstration</p> <p>On proc\u00e8de par r\u00e9currence forte le nombre de sommets verts dans \\(G\\) restants dans le graphe.</p> <ul> <li>\\(P(0)\\) : ne produit aucun \u00e9v\u00e9nement : on produit alors \\(u = \\varepsilon\\)</li> <li>\\((\\forall k \\in [| 1, n |], P(k)) \\Rightarrow P(n+1)\\) : On suppose qu'il reste \\(n+1\\) sommets \u00e0 explorer. On explore le sommet \\(x\\). Si \\(x\\) est vert (sinon la s\u00e9quence produite est \\(\\varepsilon\\)) il passe orange et on d\u00e9clenche une suite de \\(p\\) EXPLORE(y). Par hypoth\u00e8se de r\u00e9currence forte, les s\u00e9quences produites \\(v_1, \\dots, v_p\\) sont bien parenth\u00e9s\u00e9es. Ainsi la s\u00e9quence produite au final sera : \\(d(x) v_1 \\dots v_p f(x)\\) qui est bien parenth\u00e9s\u00e9e.</li> </ul> <p>D\u00e9finition</p> <p>Apr\u00e8s l'exploration compl\u00e8te d'un graphe \\(G\\) par parcours en profondeur, on pose \\(x \\leq_T y\\) lorsque \\(f(x) \\geq f(y)\\). Autrement dit, on ordonne les sommets par date de fin d'exploration : de celui qui termine en dernier \u00e0 celui qui termine en premier.</p> <p>La relation \\(\\leq_T\\) est une relation d'ordre total sur l'ensemble des sommets.</p> <p>Exemple</p> <p>Soit le graphe : <pre><code>A -&gt; B\n   / |\n  L  v\nD &lt;- C -&gt; E\n</code></pre> Un exemple d'ex\u00e9cution du parcours en profondeur depuis \\(A\\) est : <pre><code>d(A) d(B) d(C) d(D) f(D) d(E) f(E) f(C) f(B) f(A)\n</code></pre> L'ordre \\(\\leq_T\\) obtenu est donc : \\(A \\leq_T B \\leq_T C \\leq_T E \\leq_T D\\)</p>"},{"location":"algo/cfc/#a-consequence-dans-le-cas-dun-dag","title":"A. Cons\u00e9quence dans le cas d'un DAG","text":"<p>On rappelle qu'un DAG est un graphe orient\u00e9 sans cycle (directed acyclic graph).</p> <p>D\u00e9finition (ordre topologique)</p> <p>Soit \\(G = (S, A)\\) un graphe et \\(\\leq\\) un ordre total sur ses sommets. On dit qu'un tel ordre est un ordre topologue lorsque :</p> \\[ (x,y) \\in A \\quad \\Rightarrow (x \\leq y) \\] <p>Autrement dit, si on dessine le graphe lin\u00e9airement avec les sommets de gauche \u00e0 droite dans l'ordre \\(\\leq\\), alors tous les arcs vont de la gauche vers la droite.</p> <p>Cela est tr\u00e8s important pour r\u00e9soudre les probl\u00e8mes de d\u00e9pendances : si l'arc \\(x \\to y\\) mat\u00e9rialise le fait que \\(y\\) d\u00e9pend de \\(x\\), alors un ordre topologique est un ordre pour lequel on peut traiter les sommets en respectant les d\u00e9pendances.</p> <p>Proposition</p> <p>Si \\(G = (S, A)\\) est un DAG alors l'ordre \\(\\leq_T\\) est un ordre topologique. C'est-\u00e0-dire :</p> \\[ (x,y) \\in A \\quad \\Rightarrow (x \\leq_T y) \\] <p>D\u00e9monstration</p> <p>Soit \\(xy \\in A\\) une ar\u00eate. On proc\u00e8de par disjonction de cas sur tous les parenth\u00e9sages corrects possibles des \u00e9v\u00e9nements li\u00e9s \u00e0 \\(x\\) et \\(y\\) :</p> <ul> <li>Cas 1 : d(y) f(y) d(x) f(x) : Dans ce cas \\(x \\leq_T y\\)</li> <li>Cas 2 : d(x) d(y) f(y) f(x) : Dans ce cas \\(x \\leq_T y\\)</li> <li>Cas 3 : d(y) d(x) f(x) f(y) : Ce cas est impossible : cela signifie qu'il existe un chemin de \\(y\\) vers \\(x\\), mais comme \\(xy \\in A\\) on aurait un cycle.</li> <li>Cas 4 : d(x) f(x) d(y) f(y) Ce cas est impossible : cela voudrait dire que le DFS depuis \\(x\\) s'est termin\u00e9 sans que \\(y\\) ne soit explor\u00e9 mais \\(xy \\in A\\).</li> </ul>"},{"location":"algo/cfc/#b-consequence-dans-le-cas-general","title":"B. Cons\u00e9quence dans le cas g\u00e9n\u00e9ral","text":"<p>Dans le cas o\u00f9 le graphe contient des cycles un ordre topologique ne peut pas exister (pourquoi ?).</p> <p>On poss\u00e8de toutefois la propri\u00e9t\u00e9 suivante :</p> <p>Proposition</p> <p>Soit \\(G = (S, A)\\) un graphe. Soit \\(x\\) et \\(y\\) appartenant \u00e0 des composantes fortement connexes distinctes tels que \\(x \\leq_T y\\) alors il ne peut exister de chemin de \\(y\\) vers \\(x\\).</p> <p>D\u00e9monstration</p> <p>Supposons par l'absurde l'existence d'un tel chemin de \\(y\\) vers \\(x\\) et raisonnons ensuite par disjonction de cas sur tous les parenth\u00e9sages corrects possibles des \u00e9v\u00e9nements li\u00e9s \u00e0 \\(x\\) et \\(y\\) :</p> <ul> <li>Cas 1 : d(y) f(y) d(x) f(x) : On a un chemin de \\(y\\) vers \\(x\\) mais quand on explore \\(y\\) on ne trouve pas \\(x\\) : c'est absurde.</li> <li>Cas 2 : d(x) d(y) f(y) f(x) : Dans ce cas cela signifie qu'il y a un chemin de \\(x\\) vers \\(y\\) donc \\(x\\) et \\(y\\) seraient dans la m\u00eame CFC : c'est absurde.</li> <li>Cas 3 : d(y) d(x) f(x) f(y) : Exclu car \\(f[y] &lt; f[x]\\).</li> <li>Cas 4 : d(x) f(x) d(y) f(y) Exclu car \\(f[y] &lt; f[x]\\).</li> </ul>"},{"location":"algo/cfc/#3-algorithme-de-kosaraju","title":"3. Algorithme de Kosaraju","text":"<p>L'algorithme de Kosaraju est un algorithme efficace pour calculer les composantes fortement connexes d'un graphe orient\u00e9. <pre><code>KOSARAJU(G = (S,A))\n    Gbar &lt;- transpose(G)\n    ordre &lt;- tri_topo(G)\n    composante &lt;- 0\n    Pour tout x dans S selon ordre :\n        EXPLORER(x) par DFS dans Gbar en \u00e9tiquettant tout somme explor\u00e9 par composante \n        composante &lt;- composante + 1\n    Fin Pour\n</code></pre></p> <p>D\u00e9monstration</p> <p>Remarquons d\u00e9j\u00e0 que les CFC de \\(G\\) et de \\(G^t\\) sont les m\u00eames. On proc\u00e8de par r\u00e9currence sur le nombre de composantes connexes produites : P(k) : les k premiers arbres d'exploration obtenus lors du parcours de \\(G^t\\) sont des CFC</p> <ul> <li>\\(P(0)\\) est \u00e9videmment vraie il n'y a aucun arbre</li> <li> <p>\\(P(k) \\Rightarrow P(k+1)\\) : On note \\(u_{k+1}\\) la racine de l'arbre d'exploration \\(T_{k+1}\\) et \\(C_{k+1}\\) la CFC de \\(u_{k+1}\\). Montrons que \\(T_{k+1} = C_{k+1}\\).</p> <ul> <li>Tous les sommets de la composante \\(C_{k+1}\\) sont atteints par \\(T_{k+1}\\) : en effet par hypoth\u00e8se de r\u00e9currence, aucun sommet de \\(C_{k+1}\\) n'est actuellement explor\u00e9, donc l'exploration par parcours en profondeur depuis \\(u_{k+1}\\) va tous les d\u00e9couvrir c'est-\u00e0-dire que \\(C_{k+1} \\subset T_{k+1}\\).</li> <li>Si un sommet \\(y\\) est atteint par \\(T_{k+1}\\) alors il est dans \\(C_{k+1}\\). Supposons qu'il ne le soit pas c'est-\u00e0-dire que \\(y\\) appartient \u00e0 une CFC diff\u00e9rente de \\(x\\). On a de plus \\(x \\leq_T y\\) car on explore les sommets dans l'ordre \\(\\leq_T\\). Donc d'apr\u00e8s la proposition pr\u00e9c\u00e9dente, il n'existe pas de chemin de \\(y\\) vers \\(x\\) dans \\(G\\), ce qui signifie qu'il n'existe pas de chemin de \\(x\\) vers \\(y\\) dans \\(G^t\\) c'est absurde. Donc \\(T_{k+1} \\subset C_{k+1}\\).</li> </ul> </li> </ul> <p>Remarque : Cela ne change rien si on avait effecut\u00e9 le tri topologique sur \\(G^t\\), puis le parcours dans \\(G\\). </p> <p>Complexit\u00e9 : Notons \\(n\\) le nombre de sommets et \\(m\\) le nombre d'arcs; on suppose le graphe repr\u00e9sent\u00e9 par liste d'adjacences. Le tri topologique est un parcours de graphe donc de complexit\u00e9 \\(O(n + m)\\) de complexit\u00e9 lin\u00e9aire, le calcul de transpos\u00e9e est aussi lin\u00e9aire \\(O(n + m)\\), enfin le second parcours en profondeur est de complexit\u00e9 lin\u00e9aire \\(O(n+m)\\). Conclusion : l'algorithme de Kosaraju est de complexit\u00e9 lin\u00e9aire par rapport \u00e0 la taille du graphe \\(O(n + m)\\)</p>"},{"location":"algo/cfc/#4-2-sat-est-dans-p","title":"4. 2-SAT est dans P","text":"<p>On sait que 3-SAT est NP-complet d'apr\u00e8s le th\u00e9or\u00e8me de Cook, mais qu'en est-il de 2-SAT ?</p> <p>Si a est un litteral on notera bar(a) le litteral contraire : bar(x) = non(x) bar(non(x)) = x</p> <p>Pour toute formule F de 2-SAT, on peut construire le graphe d'implications G_F =(S, A) o\u00f9 S est l'ensemble des litt\u00e9raux qu'on peut former avec toutes les variables de S</p> <p>(a ou b) &lt;=&gt; (non(non(a)) ou b) &lt;=&gt; (non(a) -&gt; b) donc pour toute clause de la formule F on ajoute deux arcs : non(a) -&gt; b et non(b) -&gt; a, c'est graphe repr\u00e9sentent les implications existant entre litt\u00e9raux.</p> <p>Exemple : (x ou non(y)) et (x ou z) et (non(y) ou non(z)) et (z ou non(x))</p>"},{"location":"algo/cfc/#remarque-1","title":"Remarque 1","text":"<p>S'il existe une valuation de phi satisfaisant F alors phi est constante sur chaque CFC de G_F.</p>"},{"location":"algo/cfc/#remarque-2","title":"Remarque 2","text":"<p>S'il existe une valuation de phi et C une CFC, alors phi(bar(C)) et phi(C) ont des valeurs bool\u00e9ennes contraires. En effet, le tiers exclu est une tautologie.</p>"},{"location":"algo/cfc/#remarque-3","title":"Remarque 3","text":"<p>Le graphe poss\u00e8de une certaine forme de sym\u00e9trie : si a-&gt;b est un arc de G alors non(b) -&gt; non(a) est un arc de G.</p>"},{"location":"algo/cfc/#proposition","title":"Proposition","text":"<p>F est satisfiable ssi il n'existe pas de CFC dans G_F contenant un litteral et son contraire</p> <p>Dem : =&gt; on raisonne par contrapos\u00e9e supposons qu'il existe une CFC contenant un litteral et son contraire, soit phi une valuation satisfaisant F, alors d'apr\u00e8s la remarque 1, phi est constante sur C donc vaut faux pour tous les litt\u00e9raux de C ou vrai... c'est absurde. Donc F n'est pas satisfiable &lt;= donnons un algorithme pour construire une valuation qui satisfait F on construit H le graphe des CFC de GF, c'est un DAG On prend une CFC C qui n'a pas de predecesseur et on la pose vrai (tous ses litteraux sont vrais). C'est possible car il n'y a pas un llitteral et son contraire dans la clause. Donc toutes les implications dans C sont vraies. On pose donc necessairement bar(C) \u00e0 vrai. Toutes les implications dans C sont vraies aussi( faux -&gt; faux)  En raison de la remarque 3 on a que bar(C) n'a pas de successeur. enfin toutes les implications sortantes de C sont vraies (car faux -&gt; ?? est toujours vrai) et toutes les implications entrantes dans bar(C) sont vraies (car ?? -&gt; vrai est toujours vrai). En it\u00e9rant ainsi on construit G tel que toutes les implications sont vraies donc F est vrai.</p> <p>Remarque : c'est \u00e9quivalent de dire on va faire le tri topo de H et ensuite consid\u00e9rer les cfc de H dans cet ordre. Les CFC non marqu\u00e9es sont marqu\u00e9es faux (et en meme temps on marque l'autre vrai).</p> <p>D'apr\u00e8s cette proposition : pour v\u00e9rfier si F est satisfisable il suffit de construire son graphe d'implication, calculer ses CFC, et regarder si elles ne contiennent pas un litt\u00e9ral et son contraire (temps lin\u00e9aire). Donc 2-SAT est dans P.</p> <p>De plus, la d\u00e9monstration donne un algorithme pour calculer une valuation qui satisfait F. </p>"},{"location":"algo/concur/","title":"Programmation concurrente","text":""},{"location":"algo/concur/#1-introduction","title":"1. Introduction","text":"<p>La programmation concurrente consiste \u00e0 ex\u00e9cuter plusieurs programmes simultan\u00e9ment. Par exemple un programme A commence \u00e0 s'ex\u00e9cuter mais avant qu'il ne termine un autre programme B commence aussi son ex\u00e9cution. Autrement dit, les intervalles de temps durant lesquels les programmes \\(A\\) et \\(B\\) s'ex\u00e9cutent ont une intersection non vide ! La programmation concurrente s'oppose donc \u00e0 une programmation s\u00e9quentielle dans laquelle les programmes s'ex\u00e9cutent les uns apr\u00e8s les autres.</p> <p>En pratique, ces programmes peuvent \u00eatre soit des processus distincts, soit des fils d'ex\u00e9cution (thread en anglais) distincts d'un m\u00eame programme. En MPI, on se concentrera uniquement sur le m\u00e9canisme des threads.</p> <p>La programmation concurrente ne doit pas \u00eatre confondue avec la programmation parall\u00e8le. Dans un programme parall\u00e8le, plusieurs instructions s'ex\u00e9cutent simultan\u00e9ment, cela est possible gr\u00e2ce aux progr\u00e8s technologiques en mati\u00e8re de conception de processeurs : ceux-ci contiennent maintenant g\u00e9n\u00e9ralement plusieurs coeurs permettant des ex\u00e9cutions simultan\u00e9es d'instructions (par exemple des affectations simultan\u00e9es). Ainsi le parall\u00e9lisme est l'une des formes de programmation concurrente mais n'est pas obligatoire.</p> <p>La forme la plus complexe de programmation concurrente est la programmation distribu\u00e9e dans laquelle diff\u00e9rents ordinateurs ex\u00e9cutent des programmes simultan\u00e9ment en s'\u00e9changeant des messages \u00e0 travers un r\u00e9seau. Nous n'aborderons pas ce sujet difficile ici.</p>"},{"location":"algo/concur/#hypotheses-de-travail","title":"Hypoth\u00e8ses de travail","text":"<p>Dans ce cours on fera les hypoth\u00e8ses suivantes :</p> <ul> <li>La programmation concurrente s'effectuera \u00e0 l'aide de threads d'ex\u00e9cution</li> <li>Coh\u00e9rence s\u00e9quentielle (sequential consistency): tout se passe comme si l'ex\u00e9cution des threads \\(A\\) et \\(B\\) se d\u00e9roulait par un m\u00eame processeur qui alterne entre l'ex\u00e9cution d'instructions de \\(A\\) et d'instructions de \\(B\\). On dit qu'il y a entrelacement des ex\u00e9cutions. Il n'y aura donc pas de parall\u00e9lisme. On ne contr\u00f4le pas l'entrelacement.</li> <li>Les instructions de lecture d'une variable ou d'\u00e9criture dans une variable sont atomiques : on ne change pas de thread au milieu d'une de ces op\u00e9rations. </li> </ul> <p>Mise en garde</p> <p>Attention, ces hypoth\u00e8ses de travail ne sont g\u00e9n\u00e9ralement pas valides sur un ordinateur moderne multi-coeurs. C'est pourquoi certains des algorithmes pr\u00e9sent\u00e9s dans ce chapitre (algorithmes de peterson et de Lamport) peuvent ne pas fonctionner en pratique.</p> <p>N\u00e9anmoins, ces hypoth\u00e8ses permettent d'appr\u00e9hender les principes de la programmtion concurrente et les probl\u00e9matiques en jeu.</p>"},{"location":"algo/concur/#applications","title":"Applications","text":"<p>On trouve de nombreux exemples pratiques d'utilisation de la programmation concurrente :</p> <ul> <li>Ramasse-miette : quand un programme Java s'ex\u00e9cute, un thread sp\u00e9cial appel\u00e9 ramasse-miette est charg\u00e9 de d\u00e9tecter et lib\u00e9rer la m\u00e9moire qui n'est plus utilis\u00e9e,</li> <li>Interfaces graphiques : un thread g\u00e8re le fonctionnement des fen\u00eatres, des boutons, des \u00e9venements, etc, un autre thread g\u00e8re le programme en lui-m\u00eame</li> <li>Consoles de jeux : chaque manette est g\u00e9r\u00e9e par un thread, l'ex\u00e9cution du jeu est g\u00e9r\u00e9 par plusieurs threads, ... </li> <li>Serveurs Web : chaque requ\u00eate du serveur par un ordinateur distant est g\u00e9r\u00e9e par un thread distinct</li> <li>Calcul \"parall\u00e8le\" : sur un grand jeu de donn\u00e9es, on divise les donn\u00e9es en \\(N\\) et chaque partie est trait\u00e9e par un thread diff\u00e9rent (ex: images)</li> </ul> <p>C'est donc un concept important \u00e0 appr\u00e9hender car tr\u00e8s utilis\u00e9 en pratique mais qui peuvent conduire aussi \u00e0 de nombreux bugs difficiles \u00e0 comprendre et \u00e0 corriger.</p>"},{"location":"algo/concur/#2-fils-dexecution-threads","title":"2. Fils d'ex\u00e9cution (threads)","text":"<p>Un fil d'ex\u00e9cution (thread) est une instance qui ex\u00e9cute du code. Chaque programme est intialement ex\u00e9cut\u00e9 au sein du thread principal. On peut d\u00e9clencher l'ex\u00e9cution de nouveaux threads \u00e0 l'aide de la commande create.</p> <p>Un thread est cr\u00e9\u00e9 \u00e0 l'aide d'une op\u00e9ration create. A partir du moment o\u00f9 il est cr\u00e9\u00e9, son ex\u00e9cution concurrente aux autres threads se produit.</p> <p>En ce qui concerne la m\u00e9moire, on peut supposer que chaque thread poss\u00e8de sa pile d'ex\u00e9cution qui lui est propre, par contre le tas est partag\u00e9 entre tous les threads.</p> <p>Tout thread cr\u00e9\u00e9 par le programme doit \u00eatre d\u00e9truit par une op\u00e9ration appel\u00e9e join. L'op\u00e9ration join attend que le fil d'ex\u00e9cution termine sa t\u00e2che, puis le d\u00e9truit.</p> <p>Toute op\u00e9ration create doit \u00eatre associ\u00e9e \u00e0 un join de destruction, \u00e0 l'image d'un malloc qui est toujours associ\u00e9 \u00e0 un free.</p> <p>Illustration d'un programme s'ex\u00e9cutant avec 3 threads</p> <pre><code>sequenceDiagram\n    create participant Thread A\n    Main-&gt;&gt;Thread A: create(f) \n    create participant Thread B\n    Main-&gt;&gt;Thread B: create(g)\n    destroy Thread A\n    Thread A--&gt;&gt;Main: join()\n    destroy Thread B\n    Thread B--&gt;&gt;Main: join()</code></pre>"},{"location":"algo/concur/#en-langage-c","title":"En langage C","text":"<p>L'acc\u00e8s aux fonctions de multi-threading se fait par l'inclusion du fichier d'en-t\u00eate <code>pthread.h</code>. Le type des fils est <code>pthread_t</code>, la fonction create est <code>pthread_create</code>, la fonction join est <code>pthread_join</code>.</p> <p>La fonction <code>pthread_create</code> poss\u00e8de 4 param\u00e8tres :</p> <ol> <li>l'adresse de la variable du type <code>pthread_t</code> qui contiendra le thread</li> <li>un param\u00e8tre qu'on n'utilisera pas : argument <code>NULL</code></li> <li>l'adresse de la fonction \u00e0 ex\u00e9cuter : celle-ci doit imp\u00e9rativement \u00eatre de type <code>void*</code> vers <code>void*</code></li> <li>l'adresse du param\u00e8tre de la fonction associ\u00e9</li> </ol> <p>La fonction <code>pthread_join</code> poss\u00e8de 2 param\u00e8tres :</p> <ol> <li>le thread de type <code>phtread_t</code> \u00e0 d\u00e9truire (pas son adresse)</li> <li>un param\u00e8tre qu'on n'utilisera pas : argument <code>NULL</code></li> </ol> <p>Un premier exemple</p> <p>Compl\u00e9ter le programme suivant pour qu'il ex\u00e9cute un thread <code>thread2</code> suppl\u00e9mentaire qui affiche des caract\u00e8res <code>b</code>. Observer l'entrelacement des threads. <pre><code>#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;time.h&gt;\n\n// Une fonction pour attendre une dur\u00e9e en secondes\nvoid attendre(int sec) {\n    const time_t t_debut = time(NULL);\n    time_t t_actuel = time(NULL);\n    while (t_actuel - t_debut &lt; sec) { // attente active\n        t_actuel = time(NULL);\n    }    \n    return;\n}\n\n// Une fonction qui affiche 10 fois un caract\u00e8re\nvoid* afficher_caracteres(void* args) {\n    char* c = (char*) args;\n    for (int i = 0; i &lt; 10; i++) {\n        fputc(*c, stderr);\n        attendre(1);\n    }\n\n    return NULL;\n}\n\nint main() {\n    pthread_t thread1;\n    char c1 = 'a';\n    pthread_create(&amp;thread1, NULL, &amp;afficher_caracteres, &amp;c1);\n    pthread_join(thread1, NULL);\n    printf(\"\\n Programme termin\u00e9 \\n\");\n    return 0;\n}\n</code></pre></p> <p>Voil\u00e0 ce qu'on peut par exemple obtenir pour 3 ex\u00e9cutions de l'exemple pr\u00e9c\u00e9dent : <pre><code>abbaabbaabbaabbaabba\nabababbababababaabab\nababbabaababbaababab\n</code></pre></p> <p>On remarque donc que l'ex\u00e9cution d'un programme \u00e0 threads concurrents est non d\u00e9terministe. Cela complexifie nettement la programmation, par exemple un cas de bug pourrait survenir 1 ex\u00e9cution sur 100...</p> <p>Remarque</p> <p>Pour mettre en \u00e9vidence l'entrelacement, on a utilis\u00e9 la fonction <code>attendre</code> afin d'\u00e9viter que l'ex\u00e9cution d'un fil ne se termine avant m\u00eame que l'autre ne commence. On a \u00e9galement utilis\u00e9 exceptionnellement l'affichage sur le canal <code>stderr</code> pour obtenir les r\u00e9sultats du programme en direct (la sortie d'erreur n'\u00e9tant pas buff\u00e9ris\u00e9e).</p> <p>Exercice : affichage de la progression d'un calcul</p> <p>Ci-dessous se trouve un programme qui construit un grand tableau d'entiers al\u00e9atoires, puis le trie par ordre croissant selon l'algorithme du tri par insertion.</p> <ol> <li>Compl\u00e9tez la fonction <code>progress</code> qui a pour but d'afficher en boucle toutes les 1 seconde le pourcentage d'avancement \\(i/N\\) sur le canal <code>stderr</code>. La fonction quitte la boucle lorsque <code>i == N</code>.</li> <li>Dans la fonction <code>main</code>, ajouter du code pour la cr\u00e9ation d'un thread pour ex\u00e9cuter la fonction <code>progress</code> de mani\u00e8re concurrente au thread principal.</li> </ol> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;pthread.h&gt;\n\n#define N (1 &lt;&lt; 17)\n\nvoid attendre(int sec) {\n    const time_t t_debut = time(NULL);\n    time_t t_actuel = time(NULL);\n    while (t_actuel - t_debut &lt; sec) {\n        t_actuel = time(NULL);\n    }    \n    return;\n}\n\nvoid* progress(void* i) {\n    // A COMPLETER\n    return NULL;\n}\n\nint main() {\n    // Initialisation d'un tableau al\u00e9atoire\n    int t[N];\n    for (int i = 0; i &lt; N; i++) {\n        t[i] = (int) random();\n    }\n\n    // Tri par insertion\n    int i = 0;\n\n    for (i = 1; i &lt; N; i++) {\n        int k = i;\n        while (k &gt; 0 &amp;&amp; t[k-1] &lt; t[k]) {\n            int tmp = t[k-1];\n            t[k-1] = t[k];\n            t[k] = tmp;\n            k -= 1;\n        }\n    }\n}\n</code></pre> <p>Remarque : cas des fonctions \u00e0 plusieurs param\u00e8tres</p> <p>Si l'on souhaite ex\u00e9cuter une fonction ayant plusieurs param\u00e8tres dans un thread, c'est plus compliqu\u00e9. La fonction \u00e0 fournir \u00e0 create ne doit comporter qu'un seul param\u00e8tre, il faut donc cr\u00e9er un type struct d\u00e9di\u00e9 pour regrouper les param\u00e8tres au sein d'une seule structure.</p>"},{"location":"algo/concur/#les-difficultes-de-la-programmation-concurrente","title":"Les difficult\u00e9s de la programmation concurrente","text":"<p>La programmation concurrente est bien plus difficile que la programmation classique : de nombreux bugs peuvent \u00eatre \u00e9crits si on consid\u00e8re mal les sc\u00e9narios d'ex\u00e9cution possibles. \u00c9tudions un exemple.</p> <p>Un compteur partag\u00e9</p> <p>On souhaite \u00e9crire un programme qui compte les nombres premiers entre \\(2\\) et \\(1000\\). Dans un esprit de parall\u00e9lisation du calcul, on d\u00e9cide d'effectuer ce calcul avec deux threads : l'un qui compte les nombres premiers entre \\(2\\) et \\(500\\) et l'autre entre \\(501\\) et \\(1000\\). Ces deux threads ont pour effet d'incr\u00e9menter un compteur partag\u00e9 lorsqu'ils d\u00e9tectent un nombre premier.</p> <ol> <li>Impl\u00e9menter la fonction <code>compte_premiers</code>, cette fonction prend en argument un pointeur vers un <code>struct args_s</code>.</li> <li>Compl\u00e9ter la fonction <code>main</code> pour qu'elle cr\u00e9\u00e9 les deux threads destin\u00e9s \u00e0 compter les nombres premiers.</li> <li>Observer le r\u00e9sultat sur plusieurs ex\u00e9cutions.</li> </ol> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;assert.h&gt;\n\n// Teste si un entier est premier\nbool est_premier(int n) {\n    assert(n &gt;= 2);\n    for (int k = 2; k &lt; n; k++) {\n        if (n % k == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Une structure pour les parametres du thread\nstruct args_s {\n    int debut; // [debut, fin] est l'intervalle de recherche\n    int fin;\n    int* compteur; // adresse du compteur partag\u00e9\n};\n\nvoid* compte_premiers(void* args) {\n    // A COMPLETER\n    return NULL;\n}\n\nint main() {\n    int* c = malloc(sizeof(int)); // Le compteur partag\u00e9 est allou\u00e9 sur le tas\n    *c = 0;\n    // A COMPLETER\n    printf(\"Il y a %d nombres premiers\\n\", *c);\n    free(c);\n    return EXIT_SUCCESS;\n}\n</code></pre> <p>Fausse solution</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;assert.h&gt;\n\nstruct args_t {\n    int debut;\n    int fin;\n    int* compteur;\n};\n\nbool est_premier(int n) {\n    assert(n &gt;= 2);\n    for (int k = 2; k &lt; n; k++) {\n        if (n % k == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid* compte_premiers(void* args) {\n    struct args_t* param = (struct args_t*) args;\n    for (int n = param-&gt;debut; n &lt;= param-&gt;fin; n++) {\n        if (est_premier(n)) {\n            *(param-&gt;compteur) = *(param-&gt;compteur) + 1;\n        }\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n    int c = 0;\n    struct args_t arg1 = {.debut = 2, .fin = 500, .compteur = &amp;c};\n    struct args_t arg2 = {.debut = 501, .fin = 1000, .compteur = &amp;c};\n    pthread_create(&amp;t1, NULL, &amp;compte_premiers, &amp;arg1);\n    pthread_create(&amp;t2, NULL, &amp;compte_premiers, &amp;arg2);\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    printf(\"Il y a %d nombre premiers\\n\", c);\n    return 0;\n}\n</code></pre> <p>Le probl\u00e8me est la race condition (spoiler)</p> <p>Sur certaines ex\u00e9cutions le r\u00e9sultat est faux. Cela vient du fait que l'instruction <code>*c = *c + 1</code> n'est pas atomique : entre la lecture de <code>c</code> et l'\u00e9criture de <code>c</code> il est possible qu'un autre thread effectue des op\u00e9rations... Cela pose probl\u00e8me quand les deux threads d\u00e9cident de manipuler le compteur \u00e0 des instants proches (race condition). Voici un exemple de sc\u00e9nario qui produit le bug : <pre><code>sequenceDiagram\n    participant Thread A\n    participant Compteur\n    participant Thread B\n    Note over Compteur: c vaut 4\n    Compteur-&gt;&gt;Thread A: lire c \n    Note over Thread A: c vaut 4\n    Note over Thread A: calculer c+1\n    Compteur-&gt;&gt;Thread B: lire c \n    Note over Thread B: c vaut 4\n    Note over Thread B: calculer c+1\n    Thread A-&gt;&gt;Compteur: ecrire c\n    Note over Compteur: c vaut 5\n    Thread B-&gt;&gt;Compteur: ecrire c\n    Note over Compteur: c vaut 5</code></pre> Au final chacun des threads a provoqu\u00e9 une incr\u00e9mentation mais le compteur partag\u00e9 n'a \u00e9t\u00e9 augment\u00e9 que d'une seule unit\u00e9.</p> <p>Ainsi, la programmation concurrente n\u00e9cessite l'utilisation de m\u00e9thodes permettant de contraindre l'entrelacement des processus afin d'\u00e9viter ce type de bugs.</p>"},{"location":"algo/concur/#3-la-synchronisation","title":"3. La synchronisation","text":"<p>Lorsqu'on utilise la programmation concurrente, on cherche \u00e0 garantir les bonnes propri\u00e9t\u00e9s suivantes :</p> <ul> <li>L'exclusion mutuelle : l'exclusion mutuelle consiste \u00e0 emp\u00eacher deux processus d'acc\u00e9der simultan\u00e9ment \u00e0 une ressource partag\u00e9e, en particulier d'ex\u00e9cuter simultan\u00e9ment une section critique de code </li> <li>L'absence d'interblocage (deadlock): un interblocage survient lorsque l'ensemble des processus s'attendent mutuellement </li> <li>L'absence de famine (starvation): une famine survient lorsqu'un processus souhaite acc\u00e9der \u00e0 une ressource mais n'obtient jamais la main \u00e0 un moment o\u00f9 il peut y acc\u00e9der. </li> </ul> <p>Remarque</p> <p>Par d\u00e9finition, l'absence de famine implique l'absence d'interblocage</p> <p>La synchronisation est l'ensemble des m\u00e9thodes utilis\u00e9es pour contr\u00f4ler l'entrelacement des processus afin de garantir ces bonnes propri\u00e9t\u00e9s.</p>"},{"location":"algo/concur/#a-les-verrous-mutex","title":"A.  Les verrous (mutex)","text":"<p>Les verrous, souvent appel\u00e9s mutex, sont le m\u00e9canisme le plus simple de synchronisation. Un mutex sert \u00e0 cr\u00e9er une zone d'exclusion mutuelle. Il sert donc \u00e0 prot\u00e9ger les sections critiques du code (celles o\u00f9 on veut \u00e9viter un acc\u00e8s simultan\u00e9 \u00e0 une ressource partag\u00e9e).</p> <p>Un verrou est un objet sur lequel on peut effectuer deux op\u00e9rations :</p> <ul> <li>V\u00e9rouiller (lock) : cette op\u00e9ration place le thread courant en attente jusqu'\u00e0 ce que que le verrou soit libre. Lorsque le verrou est libre, il le verouille et poursuit \u00e0 l'instruction suivante.</li> <li>D\u00e9v\u00e9rouiller (unlock) : cette op\u00e9ration lib\u00e8re le verrou</li> </ul> <p>Ainsi la section de code situ\u00e9e entre l'instruction lock et l'instruction unlock est prot\u00e9g\u00e9e : un seul thread \u00e0 la fois peut ex\u00e9cuter cette section de cote.</p> <p>Une image mentale que vous pouvez vous faire est celui d'un vestiaire. Verouiller correspond \u00e0 attendre que le vestiaire soit libre puis entrer et le verouiller. D\u00e9verouiller consiste \u00e0 d\u00e9verouiller le vestiaire en sortant. Si tout le monde utilise cet algorithme alors personne ne peut \u00eatre dans le vestiaire en m\u00eame temps que vous.</p> <p>Remarque</p> <p>Si plusieurs processus sont en attente de lib\u00e9ration d'un verrou, alors au moment o\u00f9 il est lib\u00e9r\u00e9 le prochain procesus qui va acqu\u00e9rir le verrou est ind\u00e9termin\u00e9. Il n'y a pas possibilit\u00e9 de contr\u00f4ler quel processus va passer avant l'autre.</p> <p>Remarque importante</p> <p>Pour faire fonctionner ce m\u00e9canisme, il faut que les threads concern\u00e9s puissent acc\u00e9der au m\u00eame verrou. Le verrou doit donc \u00eatre une ressource partag\u00e9e entre les deux processus.</p>"},{"location":"algo/concur/#en-langage-c_1","title":"En langage C","text":"<p>En langage C, les mutex sont d\u00e9finis dans <code>pthread.h</code>. Le type des mutex est <code>pthread_mutex_t</code>. L'utilisation des mutex se fait \u00e0 l'aide de 4 op\u00e9rations :</p> <ul> <li><code>pthread_mutex_init(&amp;mutex, NULL)</code> permet de cr\u00e9er un verrou qui sera enregistr\u00e9 dans la variable <code>mutex</code></li> <li><code>pthread_mutex_lock(&amp;mutex)</code> v\u00e9rouille le verrou enregistr\u00e9 dans la variable <code>mutex</code></li> <li><code>pthread_mutex_unlock(&amp;mutex)</code> m\u00eame chose mais d\u00e9v\u00e9rouille <code>mutex</code></li> <li><code>pthread_mutex_destroy(&amp;mutex)</code> d\u00e9truit le mutex (doit \u00eatre utilis\u00e9 pour lib\u00e9rer les ressources)</li> </ul> <p>Exercice</p> <p>Reprendre le programme du compteur partag\u00e9 mais en le corrigeant \u00e0 l'aide d'une zone d'exclusion mutuelle mise en oeuvre \u00e0 l'aide d'un mutex.</p>"},{"location":"algo/concur/#b-les-semaphores","title":"B.  Les s\u00e9maphores","text":"<p>Les s\u00e9maphores sont une m\u00e9thode de synchronisation invent\u00e9e par Dijkstra. Un s\u00e9maphore peut \u00eatre vu comme une variable enti\u00e8re \\(S\\), sur laquelle il existe deux op\u00e9rations :</p> <ul> <li>\\(P(S)\\) (Proberen) (mn\u00e9motechnique : Puis-je ?) :<ul> <li>Attendre que \\(S\\) devienne strictement positif</li> <li>D\u00e9cr\u00e9menter \\(S\\) d'une unit\u00e9 et continuer</li> </ul> </li> <li>\\(V(S)\\) (Verhogen) (mn\u00e9motechnique : Vas-y) :<ul> <li>Incr\u00e9menter \\(S\\) d'une unit\u00e9</li> </ul> </li> </ul> <p>Nota Bene</p> <p>Les op\u00e9rations \\(P(S)\\) et \\(V(S)\\) sont atomiques, elles ne posent donc pas de probl\u00e8me d'acc\u00e8s simultan\u00e9.</p>"},{"location":"algo/concur/#utilisation-comme-verrou","title":"Utilisation comme verrou","text":"<p>Un s\u00e9maphore peut-\u00eatre utilis\u00e9 comme un verrou. Dans ce cas il doit \u00eatre initialis\u00e9 \u00e0 1 et alors l'op\u00e9ration \\(P(S)\\) peut-\u00eatre vue comme un lock, trandis que \\(V(S)\\) est un unlock. La seule diff\u00e9rence avec un mutex est que le thread qui v\u00e9rouille et le thread qui d\u00e9verouille peuvent \u00e9ventuellement \u00eatre diff\u00e9rents.</p> <p>Ainsi, sauf dans ce dernier cas bien pr\u00e9cis, il est inutile de s'emb\u00eater avec un s\u00e9maphore pour cr\u00e9er une zone d'exclusion mutuelle et on pr\u00e9ferera utiliser un mutex qui a \u00e9t\u00e9 con\u00e7u dans ce but.</p>"},{"location":"algo/concur/#utilisation-comme-jauge-limite","title":"Utilisation comme jauge limite","text":"<p>Une g\u00e9n\u00e9ralisation du verrou est d'utiliser un s\u00e9maphore initialis\u00e9 \u00e0 \\(N\\) afin qu'au plus \\(N\\) processus ne puissent ex\u00e9cuter une certaine zone de code. Voici un exemple en exercice :</p> <p>Exercice : Le d\u00eener des philosophes</p> <p>Quatre philosophes sont assis autour d'une table carr\u00e9e pour manger. Par souci d'\u00e9conomie (et par clair manque d'hygi\u00e8ne), ils d\u00e9cident de n'utiliser que quatre baguettes en tout pour manger : chaque philosophe a \u00e0 sa gauche (resp. \u00e0 sa droite) une baguette qu'il partage avec son voisin de gauche (resp. de droite). Un philosophe fonctionne avec l'algorithme suivant : <pre><code>PHILOSOPHE(x):\n    Tant que (vrai) Faire\n        PENSER()\n        PRENDRE(baguette_gauche(x))\n        PRENDRE(baguette_droite(x))\n        MANGER()\n        POSER(baguette_gauche(x))\n        POSER(baguette_droite(x))\n    Fin Tant que\n</code></pre></p> <ol> <li>On suppose que les 4 philosophes sont ex\u00e9cut\u00e9s chacun dans un thread. Impl\u00e9menter un m\u00e9canisme de synchronisation pour emp\u00eacher qu'une baguette ne soit prise en m\u00eame temps par deux philosophes.</li> <li>Avec cette solution, d\u00e9crire un scenario qui conduit \u00e0 un interblocage des 4 philosophes.</li> <li>On remarque que la situation pr\u00e9c\u00e9dente ne peut se produire lorsque 3 philosophes au plus d\u00e9cident de manger en m\u00eame temps. En utilisant un s\u00e9maphore, r\u00e9soudre le probl\u00e8me de l'interblocage.</li> </ol>"},{"location":"algo/concur/#utilisation-comme-moyen-de-signalisation","title":"Utilisation comme moyen de signalisation","text":"<p>Les s\u00e9maphores permettent surtout \u00e0 des processus de se syncrhoniser en s'envoyant des signaux de type \"tu peux poursuivre\". Pour r\u00e9aliser cela, on initialise le s\u00e9maphore \u00e0 \\(S = 0\\). L'op\u00e9ration \\(P(S)\\) consiste alors \u00e0 se placer en attente de r\u00e9ception du signal. A l'inverse l'op\u00e9ration \\(V(S)\\). En langage C, cela est rendu encore plus explicite par le nom des choix de fonction : l'op\u00e9ration \\(P\\) est appel\u00e9e <code>sem_wait</code> tandis que l'op\u00e9ration \\(V\\) est appel\u00e9e <code>sem_post</code>.</p> <p>Exemple : Synchronisation Ping-Pong</p> <p>On \u00e9crit le programme C suivant qui ex\u00e9cute deux threads :</p> <ul> <li><code>ping</code> : qui affiche des <code>PING</code> \u00e0 l'\u00e9cran</li> <li><code>pong</code> : qui affiche des <code>PONG</code> \u00e0 l'\u00e9cran</li> </ul> <p>Voici un extrait de code : <pre><code>void* ping(void* args) {\n    for (int i = 0; i &lt; N; i++) {\n        fprintf(stderr, \"PING\\n\");\n        attendre(1);\n    }\n    return NULL;\n}\n\nvoid* pong(void* args) {\n    for (int i = 0; i &lt; N; i++) {\n        fprintf(stderr, \"pong\\n\");\n        attendre(1);\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t tping, tpong;\n    pthread_create(&amp;tping, NULL, &amp;ping, NULL);\n    pthread_create(&amp;tpong, NULL, &amp;pong, NULL);\n    pthread_join(tping, NULL);\n    pthread_join(tpong, NULL);\n\n    return EXIT_SUCCESS;\n}\n</code></pre></p> <p>D'apr\u00e8s ce qu'on a vu, ces deux threads vont s'entrelacer de mani\u00e8re non d\u00e9termiste : ce qu'on ne souhaite pas. On voudrait qu'un PONG ne soit produit qu'apr\u00e8s un PING et r\u00e9ciproquement.</p> <p>Une solution est d'utiliser des signaux impl\u00e9ment\u00e9s \u00e0 l'aide de s\u00e9maphores :</p> <ul> <li>Un signal <code>envoi</code> qui est est d\u00e9clench\u00e9 par <code>ping</code> lorsqu'il envoie la balle</li> <li>Un signal <code>retour</code> qui rest d\u00e9clench\u00e9 par <code>pong</code> lorsqu'il renvoie la balle</li> </ul> Solution <p>Voici corriger le programme pr\u00e9c\u00e9dent : <pre><code>#include &lt;semaphore.h&gt;\n(...)\n\nstruct param_s {\n    sem_t *envoi;\n    sem_t *retour;\n};\ntypedef struct param_s param;\n\nvoid* ping(void* args) {\n    param* p = (param*) args;\n    for (int i = 0; i &lt; N; i++) {\n        fprintf(stderr, \"PING\\n\");\n        sem_post(p-&gt;envoi);\n        attendre(1);\n        sem_wait(p-&gt;retour);\n    }\n    return NULL;\n}\n\nvoid* pong(void* args) {\n    param* p = (param*) args;\n    for (int i = 0; i &lt; N; i++) {\n        sem_wait(p-&gt;envoi);\n        fprintf(stderr, \"pong\\n\");\n        sem_post(p-&gt;retour);\n        attendre(1);\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t tping, tpong;\n\n    sem_t envoi, retour;\n    sem_init(&amp;envoi, 0, 0);\n    sem_init(&amp;retour, 0, 0);\n\n    param a = {.envoi = &amp;envoi, .retour = &amp;retour};\n\n    pthread_create(&amp;tping, NULL, &amp;ping, &amp;a);\n    pthread_create(&amp;tpong, NULL, &amp;pong, &amp;a);\n    pthread_join(tping, NULL);\n    pthread_join(tpong, NULL);\n\n    sem_destroy(&amp;envoi);\n    sem_destroy(&amp;retour);\n\n    return EXIT_SUCCESS;\n}\n</code></pre></p>"},{"location":"algo/concur/#c-algorithme-de-peterson","title":"C. Algorithme de Peterson","text":"<p>Les verrous et les s\u00e9maphores utilisent des instructions sp\u00e9ciales du processeur telles que test-and-set pour fonctionner. Ces instructions sont disponibles sur les architectures r\u00e9centes.</p> <p>Historiquement, les ordinateurs travaillaient s\u00e9quentiellement et ne disposaient pas de telles instructions. Il a alors fallu trouver des solutions algorithmiques pour synchroniser des processus en se basant sur l'attente active.</p> <p>L'algorithme de Peterson permet de cr\u00e9er une zone d'exclusion mutuelle de mani\u00e8re algorithmique pour deux processus uniquement.</p> <pre><code>// ALGORITHME DE PETERSON\n\n// Init\nbool veut_entrer[2] = {false, false};\nint tour;\n\n// Dans le thread 0 :\nT0: veut_entrer[0] = true;\n    tour = 1;\n    while (veut_entrer[1] &amp;&amp; tour == 1) {} // attente active\n    // D\u00e9but de la section critique\n    ...\n    // fin de la section critique\n    veut_entrer[0] = false;\n\n// Dans le thread 1 :\nT1: veut_entrer[1] = true;\n    tour = 0;\n    while (veut_entrer[0] &amp;&amp; tour == 0) {} // attente active\n    // D\u00e9but de la section critique\n    ...\n    // fin de la section critique\n    veut_entrer[1] = false;\n</code></pre> <p>Proposition</p> <p>L'algorithme de Peterson garantit l'exclusion mutuelle pour deux processus dans la zone critique associ\u00e9e.</p> <p>Supposons par l'absurde qu'il y a violation de l'exclusion mutuelle et que \\(0\\) est le dernier thread \u00e0 avoir \u00e9crit dans tour (donc tour vaut 1). Cela signifie que <code>veut_entrer</code> vaut vrai pour les deux processus (car fix\u00e9 avant le tour). Donc le thread 0 n'a pas pu franchir le test du <code>while</code>, c'est absurde.</p> <p>Proposition</p> <p>L'algorithme de Peterson garantit l'absence de famine pour chacun des processus. En particulier, il n'y a pas d'interblocage.</p> <p>Supposons par l'absurde que le thread 0 est en famine, cela signifie qu'\u00e0 chaque fois qu'il obtient la main, et qu'il effectue le test du while, le test vaux <code>true</code>. Remarquons d\u00e9j\u00e0, que comme le thread 1 ne modifie <code>tour</code> que pour le mettre \u00e0 <code>0</code>, cette situation ne peut se produire que si <code>veut_entrer[1]</code> est toujours \u00e0 vrai quand le thread 0 obtient la main. Alors regardons la situation du thread 1 juste au moment o\u00f9 il va rendre la main:</p> <ul> <li>S'il se situe apr\u00e8s sa zone critique, il a plac\u00e9 <code>veut_entrer[1]</code> \u00e0 false, donc un retour \u00e0 thread 0 le d\u00e9bloque : absurde</li> <li>S'il se situe dans sa zone critique : il finira par en sortir et on est ramen\u00e9 au cas pr\u00e9c\u00e9dent</li> <li>S'il sort de sa zone critique mais revient (boucle, ...) et tente de r\u00e9acceder \u00e0 la zone critique : il va placer <code>tour</code> \u00e0 0 et comme <code>veut_entrer[1]</code> est \u00e0 true, il entre dans une boucle potentiellement infinie, le retour au thread 0 d\u00e9bloque alors ce dernier : absurde</li> </ul> <p>Donc il n'y pas de famine.</p> <p>Attention</p> <p>L'algorithme est bien pr\u00e9cis et doit \u00eatre respect\u00e9 \u00e0 la lettre. Par exemple, l'absence de drapeaux <code>veut_entrer</code> rend l'algorithme faux.</p>"},{"location":"algo/concur/#d-algorithme-de-la-boulangerie-de-lamport","title":"D. Algorithme de la boulangerie de Lamport","text":"<p>L'algorithme de la boulangerie de Lamport permet de cr\u00e9er une zone d'exclusion mutuelle de mani\u00e8re algorithmique pour un nombre fini de processus.</p> <p>Son principe de fonctionnement est le suivant :</p> <ul> <li>chaque thread voulant acc\u00e9der \u00e0 la ressource tire un ticket (plus grand que les tickets d\u00e9j\u00e0 tir\u00e9s)</li> <li>lorsqu'un processus veut acc\u00e9der \u00e0 la section critique :<ul> <li>il v\u00e9rifie que les autres threads qui aient fini de tirer leur ticket</li> <li>il v\u00e9rifie s'il a bien le plus petit num\u00e9ro par rapport aux autres</li> <li>en cas d'\u00e9galit\u00e9, s'il a le plus petit num\u00e9ro de thread alors il passe en premier</li> </ul> </li> <li>lorsqu'il a termin\u00e9, il jette son ticket</li> </ul> <pre><code>    // ALGORITHME DE LA BOULANGERIE DE LAMPORT \n\n    // Variables globales :\n\n    // Num\u00e9ro de ticket tir\u00e9 (0 = pas de ticket)\n    int num[N] = {0, ..., 0};\n\n    // Drapeau pour dire qu'on est en train de prendre un ticket\n    bool prends_ticket[N] = {false, ..., false};\n\n    // Le thread i demande la ressource :\n    void lock(int i) {\n        prends_ticket[i] = true;\n        num[i] = MAX(num[0], ..., num[n-1]) + 1;\n        prends_ticket[i] = false;\n        for (int p = 0; p &lt; N; p++) {\n            while (prends_ticket[p]) // On attends que p ait termin\u00e9 de prendre son ticket\n            while (num[p] != 0 &amp;&amp; (num[p] &lt; num[i] || (num[p] == num[i] &amp;&amp; p &lt; i)) {}\n    // En cas d'egalite de ticket, le thread de plus petit numero passe en premier\n        }\n    }\n\n    // Le thread i lib\u00e8re la ressource :\n    void unlock(int i) {\n        num[i] = 0;\n    }\n</code></pre> <p>Proposition</p> <p>L'algorithme de Lamport garantit l'exclusion mutuelle (entre <code>lock</code> et <code>unlock</code>) ainsi que l'absence de famine.</p> <p>Attention</p> <p>L'algorithme est bien pr\u00e9cis et doit \u00eatre respect\u00e9 \u00e0 la lettre. Par exemple, l'absence de drapeaux <code>prends_ticket</code> ou de traitement du cas d'\u00e9galit\u00e9 rend l'algorithme faux.</p> <p>Attention</p> <p>Comme mentionn\u00e9 au d\u00e9but de ce chapitre, les algorithmes de Peterson et de la boulangerie de Lamport sont faux \u00e9crits comme tels dans le cadre de la programmation sur une machine moderne multi-coeurs (absence de coh\u00e9rence s\u00e9quentielle). Vous pouvez essayer de les programmer en langage C et vous verrez que l'ex\u00e9cution l'exclusion mutuelle n'est pas v\u00e9rifi\u00e9e...</p> <p>Remarque importante</p> <p>Les algorithmes de Peterson et de la boulangerie de Lamport ont surtout un int\u00e9r\u00eat historique et p\u00e9dagagogique. Sauf si l'\u00e9nonc\u00e9 le demande explicitement, pr\u00e9f\u00e9rez l'utilisation des mutex pour cr\u00e9er une zone d'exclusion mutuelle en pratique.</p>"},{"location":"algo/decicomp/","title":"D\u00e9cidabilit\u00e9 et complexit\u00e9","text":"<p>La th\u00e9orie de la complexit\u00e9 a pour but d'\u00e9tablir une hi\u00e9rarchie de difficult\u00e9 des probl\u00e8mes que l'on souhaite r\u00e9soudre en informatique. Elle ne doit pas \u00eatre confondue avec l'analyse de complexit\u00e9 des algorithmes (vue en premi\u00e8re ann\u00e9e), bien que les deux notions sont effectivement li\u00e9es.</p> <p>Cette \u00e9tude permet de mieux comprendre les limites th\u00e9oriques de l'informatique et d\u00e9finit en particulier deux classes de probl\u00e8mes importantes et rencontr\u00e9s fr\u00e9quemment en informatique :</p> <ul> <li>Les probl\u00e8mes ind\u00e9cidables : pour lesquels on sait qu'il ne peut pas exister d'algorithme pour les r\u00e9soudre</li> <li>Les probl\u00e8mes NP-complets : pour lesquels on ignore aujourd'hui s'il existe des algorithmes efficaces pour les r\u00e9soudre</li> </ul>"},{"location":"algo/decicomp/#1-introduction","title":"1. Introduction","text":""},{"location":"algo/decicomp/#a-problemes-de-decision","title":"A. Probl\u00e8mes de d\u00e9cision","text":"<p>La premier point que nous abordons est la d\u00e9finition de ce qu'on consid\u00e8re \u00eatre un probl\u00e8me \u00e0 r\u00e9soudre :</p> <p>D\u00e9finition (probl\u00e8me de d\u00e9cision)</p> <p>Un probl\u00e8me de d\u00e9cision est une question portant sur un ensemble de donn\u00e9es appel\u00e9es instance du probl\u00e8me et dont la r\u00e9ponse est soit oui soit non.</p> <p>Attention, tous les probl\u00e8mes ne sont pas des probl\u00e8mes de d\u00e9cision, mais la hi\u00e9rarchie de difficult\u00e9 qu'on va \u00e9tablir concerne ce type de probl\u00e8mes.</p> <p>Exemples</p> <p>Voici des probl\u00e8mes de d\u00e9cision :</p> <ul> <li>Instance : un graphe non orient\u00e9 \\(G\\). Question : \\(G\\) est-il connexe ?</li> <li>Instance : un graphe orient\u00e9 \\(G\\) et deux sommets \\(u\\) et \\(v\\). Question : existe-t-il un chemin dans \\(G\\) de \\(u\\) \u00e0 \\(v\\) ?</li> <li>Instance : un tableau \\(T\\). Question : \\(T\\) est-il tri\u00e9 par ordre croissant ?</li> <li>Instance : un tableau \\(T\\) et une valeur \\(v\\). Question : la valeur \\(v\\) est-elle pr\u00e9sente dans \\(T\\) ?</li> <li>Instance : un entier naturel \\(n\\). Question : \\(n\\) est-il premier ?</li> <li>Instance : une formule propositionnelle \\(F\\). Question : \\(F\\) est-elle une tautologie ?</li> <li>...</li> </ul> <p>Pour pouvoir parler de complexit\u00e9 nous devons \u00e9galement \u00eatre en mesure de donner une taille aux entr\u00e9es du probl\u00e8me :</p> <p>D\u00e9finition (taille de l'instance)</p> <p>La taille d'une instance d'un probl\u00e8me de d\u00e9cision est l'espace qu'elle occupe en m\u00e9moire (en octets par exemple). Pour simplifier, on utilisera les conventions suivantes selon le type d'instance :</p> <ul> <li>un entier \\(n\\) non born\u00e9 : \\(log_2(n)\\) (le nombre est \u00e9crit en binaire)</li> <li>un tableau ou une liste de longueur \\(n\\) : \\(n\\) (les cases du tableau occupent un m\u00eame espace constant)</li> <li>un graphe de \\(n\\) sommets et \\(m\\) ar\u00eates/arcs : \\(n + m\\) (listes d'adjacence) ou \\(n^2\\) (matrice d'adjacence)</li> <li>un arbre (arbre binaire, formule logique, expression r\u00e9guli\u00e8re, etc) : la taille de l'arbre (nombre de noeuds et de feuilles)</li> </ul> <p>La mani\u00e8re exacte de compter la taille de l'instance importe peu dans la th\u00e9orie qui va suivre, \u00e0 condition de rester raisonnable sur la mani\u00e8re dont l'instance est cod\u00e9e et mesur\u00e9e. Par exemple on ne va pas coder un entier non born\u00e9 en base 1...</p>"},{"location":"algo/decicomp/#b-modele-de-calcul","title":"B. Mod\u00e8le de calcul","text":"<p>Maintenant, nous avons besoin de d\u00e9finir ce qu'est un ordinateur et comment on mesure le temps et l'espace consomm\u00e9 pour r\u00e9soudre un probl\u00e8me. Malheureusement, il y a beaucoup d'ordinateurs diff\u00e9rents c'est pourquoi il est n\u00e9cessaire de se baser sur un mod\u00e8le de machine th\u00e9orique qui d\u00e9crit ce qu'un ordinateur est capable de calculer ou non. Le mod\u00e8le th\u00e9orique de r\u00e9f\u00e9rence est la machine de Turing mais elle n'est pas au programme en MP2I/MPI.</p> <p>Pour simplifier, nous utiliserons dans ce cours le terme g\u00e9n\u00e9ral de machine pour parler d'un ordinateur qui prend des donn\u00e9es en entr\u00e9e, r\u00e9alise un calcul algorithmique et produit un r\u00e9sultat en sortie. Le calcul effectu\u00e9 sera d\u00e9crit au choix :</p> <ul> <li>par un algorithme \u00e9crit en pseudo-code</li> <li>par un programme ou une fonction \u00e9crite en C</li> <li>par un programme ou une fonction \u00e9crire en OCaml</li> </ul> <p>Le temps d'ex\u00e9cution sera compt\u00e9 en nombre d'op\u00e9rations \u00e9l\u00e9mentaires effectu\u00e9es et l'espace utilis\u00e9 par le nombre de cases m\u00e9moires utilis\u00e9es. Autrement dit on compte le temps et l'espace comme vous avez pris l'habitude de le faire en premi\u00e8re ann\u00e9e (MP2I).</p>"},{"location":"algo/decicomp/#c-problemes-decidables","title":"C. Probl\u00e8mes d\u00e9cidables","text":"<p>D\u00e9finition (probl\u00e8me d\u00e9cidable)</p> <p>Un probl\u00e8me de d\u00e9cision est d\u00e9cidable s'il existe une machine qui prend en entr\u00e9e une instance du probl\u00e8me, qui termine sur toute entr\u00e9e, et qui donne en sortie la bonne r\u00e9ponse oui ou non pour l'instance donn\u00e9e. <pre><code>flowchart LR\n    classDef instance fill:lightblue,stroke:transparent,fill:transparent;\n    classDef machine fill:pink;\n    classDef answer fill:lightblue,stroke:transparent,fill:transparent;\n    I[instance] --&gt; M;\n    M --&gt; R[oui/non];\n    class I instance;\n    class M machine;\n    class R answer;</code></pre></p> <p>Exemple</p> <p>Soit le probl\u00e8me de d\u00e9cision suivant qu'on appellera MEMTAB :</p> <ul> <li>Instance : un tableau \\(T\\) et une valeur \\(v\\)</li> <li>Question : la valeur \\(v\\) est-elle pr\u00e9sente dans \\(T\\) ?</li> </ul> <p>Montrer que le probl\u00e8me MEMTAB est d\u00e9cidable.</p> Solution <p>MEMTAB est d\u00e9cidable, voici un exemple d'alogorithme qui d\u00e9cide MEMTAB : <pre><code>Entr\u00e9es : T, v\nn &lt;- longueur(T)\nPour i allant de 0 \u00e0 n-1 Faire\n    Si T[i] == v Alors\n        R\u00e9pondre OUI\n    FinSi\nFinPour\nR\u00e9pondre NON\n</code></pre> Cet algorithme r\u00e9pond correctement \u00e0 la question, de plus il termine sur toute entr\u00e9e (une boucle Pour termine toujours). Donc MEMTAB est d\u00e9cidable.</p> <p>Il est difficile de se l'imaginer pour le moment mais nous verrons que certains probl\u00e8mes ne sont pas d\u00e9cidables. On dit qu'il alors qu'ils sont ind\u00e9cidables.</p>"},{"location":"algo/decicomp/#d-reductions-dun-probleme-a-lautre","title":"D. R\u00e9ductions d'un probl\u00e8me \u00e0 l'autre","text":"<p>Comme annonc\u00e9 dans l'introduction, un des buts de ce chapitre est de classer les probl\u00e8mes \u00e0 traiter selon leur difficult\u00e9. Pour cela on va se reposer sur le principe suivant. Supposons qu'on poss\u00e8de un probl\u00e8me \\(A\\) par exemple \"Eteindre une bougie\" et un probl\u00e8me \\(B\\) par exemple \"Eteindre un incendie\".</p> <p>Si je dispose d'une m\u00e9thode \\(M\\) pour r\u00e9soudre \\(B\\) (par exemple utiliser une lance \u00e0 incendie), je peux certainement utiliser cette m\u00e9thode \\(M\\) pour r\u00e9soudre \\(A\\). On dira dans ce cas que \\(B\\) est plus difficile que \\(A\\) puisque si je sais r\u00e9soudre \\(B\\) je sais r\u00e9soudre \\(A\\).</p> <p>L'inverse n'est pas vrai : si je dispose d'une m\u00e9thode pour \u00e9teindre une bougie (par exemple souffler dessus), il est peu vraisemblable que cette m\u00e9thode me permette d'\u00e9teindre un incendie. Formalisons cela pour les probl\u00e8mes de decision.</p> <p>D\u00e9finition (r\u00e9duction et r\u00e9duction polynomiale)</p> <p>Soit \\(A\\) et \\(B\\) deux probl\u00e8mes de d\u00e9cision. On dit que \\(A\\) se r\u00e9duit \u00e0 \\(B\\) s'il existe une machine \\(R\\) prenant en entr\u00e9e une instance \\(I_A\\) de \\(A\\) et produisant en sortie une instance \\(I_B\\) de \\(B\\) et v\u00e9rifiant :</p> <ul> <li>(i) La machine \\(R\\) termine sur toute entr\u00e9e </li> <li>(ii) \\(I_A\\) est une instance positive \\(\\Leftrightarrow\\) \\(I_B = R(I_A)\\) est une instance positive</li> </ul> <p>Dans ce cas on notera \\(A \\leq B\\).</p> <p>Si de plus, il existe un r\u00e9el \\(k &gt; 0\\) tel que </p> <ul> <li>(iii) Le temps d'ex\u00e9cution pire cas de \\(R\\) est en \\(O(|I_A|^k)\\)</li> </ul> <p>alors on dit que la r\u00e9duction est polynomiale et on notera alors \\(A \\leq_P B\\).</p> <pre><code>flowchart LR\n    classDef instance fill:lightblue,stroke:transparent,fill:transparent;\n    classDef machine fill:pink;\n    classDef reduction fill:lightgreen,stroke:green;\n    classDef answer fill:lightblue,stroke:transparent,fill:transparent;\n    I[\"$$I_A$$\"] --&gt; R@{ shape: delay };\n    R--&gt; J[\"$$I_B$$\"];\n    class I,J instance;\n    class R reduction;</code></pre> <p>Autrement dit une r\u00e9duction d'un probl\u00e8me \\(A\\) vers un probl\u00e8me \\(B\\) est une traduction des instances d'un probl\u00e8me \u00e0 l'autre qui pr\u00e9serve la r\u00e9ponse oui/non. Ainsi pour r\u00e9soudre une instance du probl\u00e8me \\(A\\) on peut consid\u00e9rer sa traduction en probl\u00e8me \\(B\\) est r\u00e9soudre ce nouveau probl\u00e8me. Donc si on sait r\u00e9soudre \\(B\\), on sait r\u00e9soudre \\(A\\) : \\(B\\) est plus difficile que \\(A\\).</p> <p>La r\u00e9duction est polynomiale lorsque le temps de calcul de la traduction est polynomial en fonction de la taille de l'instance \\(I_A\\).</p> <p>Proposition</p> <p>Soit \\(A\\) et \\(B\\) deux probl\u00e8mes de d\u00e9cision. Si \\(B\\) est d\u00e9cidable et si \\(A \\leq B\\) alors \\(A\\) est d\u00e9cidable.</p> <p>D\u00e9monstration</p> <p>Soit \\(A\\) et \\(B\\) deux probl\u00e8mes de d\u00e9cision v\u00e9rifiant les hyptoh\u00e8ses de d\u00e9part :</p> <ul> <li>\\(B\\) est d\u00e9cidable : il existe donc une machine \\(M\\) qui d\u00e9cide \\(B\\).</li> <li>\\(A \\leq B\\) : il existe donc une machine \\(R\\) qui transforme correctement les instances de \\(A\\) en instances de \\(B\\).</li> </ul> <p>On pose la machine suivante :</p> <pre><code>flowchart LR\n    classDef instance fill:lightblue,stroke:transparent,fill:transparent;\n    classDef machine fill:pink;\n    classDef reduction fill:lightgreen,stroke:green;\n    classDef answer fill:lightblue,stroke:transparent,fill:transparent;\n\n    subgraph MM[\"$$M'$$\"]\n    R--&gt; J[\"$$I_B$$\"];\n    J--&gt; M[\"$$M$$\"];\n    end\n\n    I[\"$$I_A$$\"] --&gt; R@{ shape: delay };\n    M--&gt; X[\"oui/non\"];\n    class I,J instance;\n    class R reduction;\n    class M machine;\n    class X answer;</code></pre> <p>Cette machine prend donc en entr\u00e9e une instance de \\(A\\) et r\u00e9pond oui/non. De plus :</p> <ol> <li>\\(M'\\) termine sur toute entr\u00e9e, car \\(R\\) termine et \\(M\\) termine par d\u00e9finition.</li> <li>\\(I_A\\) est une instance positive \\(\\Leftrightarrow\\) \\(I_B\\) est une instance positive \\(\\Leftrightarrow\\) \\(M(I_B) = oui\\) \\(\\Leftrightarrow\\) \\(M'(I_A) = oui\\).</li> </ol> <p>Donc \\(M'\\) d\u00e9cide \\(A\\), donc \\(A\\) est d\u00e9cidable.</p> <p>Remarque</p> <p>Dans la d\u00e9monstration pr\u00e9c\u00e9dente, la machine \\(M'\\) a \u00e9t\u00e9 introduite par un sch\u00e9ma mais on aurait tout aussi bien pu la donner sous d'algorithme en pseudo-code : <pre><code>Entr\u00e9e : I_A\nI_B &lt;- R(I_A)\nrep &lt;- M(I_B)\nR\u00e9pondre rep\n</code></pre> ou m\u00eame de fonction pseudo-code : <pre><code>MPRIME(I_A)\n    I_B &lt;- R(I_A)\n    return M(I_B)\n</code></pre> ou encore de fonction C ou OCaml : <pre><code>bool Mprime(Instance ia) {\n    Instance ib = R(ia);\n    return M(ib);\n}\n</code></pre> Je trouve la repr\u00e9sentation sch\u00e9matique plus claire mais toutes ces propositions sont valides</p> <p>La proposition suivante \u00e9tablit que la r\u00e9duction (polynomiale) se comporte presque comme un ordre (il manque l'antisym\u00e9trie) sur les probl\u00e8mes de d\u00e9cision.</p> <p>Proposition</p> <p>Soit \\(A\\), \\(B\\), \\(C\\) trois probl\u00e8mes de d\u00e9cision alors :</p> <ol> <li>\\(A \\leq A\\)</li> <li>\\(A \\leq_P A\\)</li> <li>\\(A \\leq B\\) et \\(B \\leq C \\Rightarrow A \\leq C\\)</li> <li>\\(A \\leq_p B\\) et \\(B \\leq_P C \\Rightarrow A \\leq_P C\\)</li> </ol> <p>D\u00e9monstration</p> <ul> <li>Les points (1) et (2) sont \u00e9vidents, il suffit de prendre la machine identit\u00e9 (recopie l'entr\u00e9e sur la sortie) pour \u00e9tablir la r\u00e9duction. </li> <li>Montrons (3) : soit \\(R_1\\) la machine qui r\u00e9duit de \\(A\\) \u00e0 \\(B\\) et \\(R_2\\) la machine qui r\u00e9duit de \\(A\\) \u00e0 \\(C\\). On construit la machine \\(R\\) suivante : <pre><code>flowchart LR\n    classDef instance fill:lightblue,stroke:transparent,fill:transparent;\n    classDef machine fill:pink;\n    classDef reduction fill:lightgreen,stroke:green;\n    classDef answer fill:lightblue,stroke:transparent,fill:transparent;\n\n    subgraph R[\"$$R$$\"]\n    RA[\"$$R_1$$\"]--&gt; J[\"$$I_B$$\"];\n    J--&gt; RB[\"$$R_2$$\"];\n    end\n\n    I[\"$$I_A$$\"] --&gt; RA@{ shape: delay };\n    RB@{ shape: delay } --&gt; K[\"$$I_C$$\"];\n    class I,J,K instance;\n    class RA,RB reduction;</code></pre> Cette machine termine sur toute entr\u00e9e (car \\(R_1\\) et \\(R_2\\) terminent). De plus, \\(I_A\\) est positive ssi \\(I_B\\) est positive (d'apr\u00e8s la r\u00e9duction 1) ssi \\(I_C\\) est positive (d'apr\u00e8s la r\u00e9duction 2). \\(R\\) est donc bien une r\u00e9duction de \\(A\\) vers \\(C\\).</li> <li>Montrons (4) : on reprend la m\u00eame preuve que (3) mais il faut \u00e9galement montrer que la r\u00e9duction est polynomiale, en supposant que \\(R_1\\) et \\(R_2\\) le sont. Il existe donc des r\u00e9els \\(k_1 &gt; 0\\) et \\(k_2 &gt; 0\\) tels que \\(R_1\\) est de complexit\u00e9 \\(O(|I_A|^{k_1})\\) et \\(R_2\\) de complexit\u00e9 \\(O(|I_B|^{k_2})\\). Une autre fa\u00e7on de le dire est qu'il existe des constantes \\(C_1\\) et \\(C_2\\) tels que les temps de calcul de \\(R_1\\) et \\(R_2\\) v\u00e9rifient : \\(T_1 \\leq C_1 |I_A|^{k_1}\\) et \\(T_2 \\leq C_2 |I_B|^{k_2}\\). Maintenant, voici le point d\u00e9licat de la preuve : \\(R_1\\) ne peut pas produire une sortie plus grande que sont temps de calcul, car \u00e9crire sur la sortie consomme justement du temps de calcul de \\(R_1\\), donc \\(|I_B| \\leq T_1\\). On obtient alors que le temps de calcul de \\(R\\) v\u00e9rifie : \\(T = T_1 + T_2 \\leq C_1 |I_A|^{k_1} + C_2 |I_B|^{k_2} \\leq C_1 |I_A|^{k_1} + C_2 C_1^{k_2} |I_A|^{k_1k_2} \\leq C |I_A|^{\\max(k_1,k_1k_2)}\\) avec \\(C = \\max(C_1, C_2C_2^{k_2})\\) qui est une constante. Donc \\(R\\) est bien de complexit\u00e9 polynomiale.</li> </ul> <p>Exercice</p> <p>Pour v\u00e9rifier que vous avez bien compris : \u00e9crire la machine \\(R\\) de la d\u00e9monstration sous forme d'algorithme en pseudo-code; puis de fonction en langage C</p>"},{"location":"algo/decicomp/#2-la-classe-p","title":"2. La classe P","text":"<p>Le fait qu'un probl\u00e8me soit d\u00e9cidable ne suffit pas \u00e0 dire qu'on sait le traiter en pratique. En effet, il se peut que les algorithmes qu'on connaisse pour le r\u00e9soudre soient de complexit\u00e9 trop \u00e9lev\u00e9e pour pouvoir \u00eatre utilis\u00e9s en pratique. Nous allons donc maintenant ajouter une condition sur la complexit\u00e9 de la machine qui r\u00e9sout le probl\u00e8me.</p> <p>La classe P est l'ensemble des probl\u00e8mes de d\u00e9cision pour lesquels il existe un algorithme de complexit\u00e9 polynomiale pour les r\u00e9soudre.</p> <p>D\u00e9finition (classe P)</p> <p>Un probl\u00e8me de d\u00e9cision est dans la classe P, s'il existe un nombre r\u00e9el \\(k &gt; 0\\) et une machine \\(M\\) prenant en entr\u00e9e une instance \\(I\\) telle que :</p> <ol> <li>\\(M\\) donne en sortie la bonne r\u00e9ponse oui ou non pour l'instance \\(I\\)</li> <li>Dans le pire cas, le temps d'ex\u00e9cution de la machine est \\(O(n^k)\\) avec \\(n\\) la taille de l'instance \\(I\\)</li> </ol> <pre><code>flowchart LR\n    classDef instance fill:lightblue,stroke:transparent,fill:transparent;\n    classDef machine fill:pink;\n    classDef answer fill:lightblue,stroke:transparent,fill:transparent;\n    I[\"instance I\"] --&gt; M;\n    M --&gt; R[oui/non];\n    class I instance;\n    class M machine;\n    class R answer;</code></pre> <p>On remarque que la condition (2) implique n\u00e9cessairement que la machine termine sur toute entr\u00e9e et qu'un probl\u00e8me dans la classe P est toujours un probl\u00e8me d\u00e9cidable.</p> <p>Dans la d\u00e9finition, on aurait pu remplacer le r\u00e9el \\(k\\) par l'existence d'un polyn\u00f4me \\(Q\\) tel que le temps d'ex\u00e9cution pire cas est en \\(O(Q(n))\\). Cela est totalement \u00e9quivalent \u00e0 la d\u00e9finition donn\u00e9e et c'est aussi pour cela que la classe s'appelle P comme polyn\u00f4me.</p> <p>Exemple</p> <p>Soit le probl\u00e8me de d\u00e9cision suivant qu'on appellera TABTRIE :</p> <ul> <li>Instance : un tableau \\(T\\) d'entiers</li> <li>Question : le tableau \\(T\\) est-il tri\u00e9 par ordre croissant ? </li> </ul> <p>Montrer que le probl\u00e8me TABTRIE appartient \u00e0 P.</p> Solution <p>On consid\u00e8re l'algorithme en pseudo-code suivant : <pre><code>Entr\u00e9es : T\nn &lt;- longueur(T)\nPour i allant de 0 \u00e0 n-2 Faire\n    Si T[i] &gt; T[i+1] Alors\n        R\u00e9pondre NON\n    FinSi\nFinPour\nR\u00e9pondre OUI\n</code></pre> Cet algorithme r\u00e9pond correctement \u00e0 la question. Dans le pire cas sa complexit\u00e9 est \\(O(n)\\) qui est bien polynomiale en fonction de la taille de l'instance (\\(n\\)). Donc TABTRIE \\(\\in\\) P.</p> <p>Remarquer que cela implique forc\u00e9ment que TABTRIE est d\u00e9cidable...</p> <p>Attention \u00e0 la taille de l'instance !</p> <p>Soit le probl\u00e8me de d\u00e9cision suivant appel\u00e9 PRIME :</p> <ul> <li>Instance : un entier naturel \\(n\\) </li> <li>Question : \\(n\\) est-il premier ? </li> </ul> <p>Montrer que PRIME est dans P.</p> Solution fausse <p>On consid\u00e8re l'algorithme en pseudo-code suivant : <pre><code>Entr\u00e9es : n\nPour k allant de 2 \u00e0 n-1 Faire\n    Si n mod k == 0 Alors // si k divise n\n        R\u00e9pondre NON\n    FinSi\nFinPour\nR\u00e9pondre OUI\n</code></pre> Cet algorithme r\u00e9pond correctement \u00e0 la question. Dans le pire cas sa complexit\u00e9 est \\(O(n)\\) MAIS ATTENTION dans ce cas \\(n\\) n'est pas la TALLE DE L'INSTANCE donc on ne peut pas conclure que PRIME \\(\\in P\\).</p> <p>En effet, ici dans ce probl\u00e8me \\(n\\) est un entier quelconque aussi grand qu'on veut et sa taille en octets (si on l'\u00e9crit en binaire) est de l'ordre de \\(p = \\log_2(n)\\). Il fallait donc exprimer la complexit\u00e9 en fonction de \\(p\\) (la taille de l'instance) et non de \\(n\\). Avec notre algorithme on trouve donc que la complexit\u00e9 est \\(O(2^p)\\) (exponentielle) ce qui ne permet pas de conclure que PRIME \\(\\in\\) P.</p> <p>En r\u00e9alit\u00e9 PRIME est bien un probl\u00e8me dans P mais la d\u00e9monstration de ce r\u00e9sultat est tr\u00e8s difficile et n'a \u00e9t\u00e9 r\u00e9solue qu'en 2002 par 3 chercheurs indiens qui ont mis au point l'algorithme AKS. Bien que cet algorithme soit de complexit\u00e9 polynomiale, il n'est pas adapt\u00e9 \u00e0 l'usage pratique...</p> <p>Bien \u00e9videmment il y a beaucoup d'autres exemples de probl\u00e8mes qui sont dans P. Si on y r\u00e9fl\u00e9chit bien, la grande majorit\u00e9 des algorithmes que vous avez \u00e9tudi\u00e9s jusqu'\u00e0 pr\u00e9sent ont des complexit\u00e9s polynomiales et permettent donc de r\u00e9pondre en temps polynomial \u00e0 des probl\u00e8mes de d\u00e9cision.</p> <p>En informatique th\u00e9orique, on consid\u00e8re donc que la classe P est l'ensemble des probl\u00e8mes qu'on peut r\u00e9soudre sur ordinateur en temps raisonnable (bien que cela soit une simplification tr\u00e8s grossi\u00e8re).</p> <p>Proposition</p> <p>Soit \\(A\\) et \\(B\\) deux probl\u00e8mes de d\u00e9cision. Si</p> <ol> <li>\\(A \\leq_P B\\)</li> <li>\\(B \\in \\mathbf{P}\\)</li> </ol> <p>Alors \\(A \\in \\mathbf{P}\\)</p> <p>Cette proposition pourrait se reformuler : si on est plus facile qu'un probl\u00e8me facile alors on est facile.</p> <p>D\u00e9monstration</p> <p>Soit \\(A\\) et \\(B\\) deux probl\u00e8mes de d\u00e9cision v\u00e9rifiant (1) et (2). D'apr\u00e8s (1), il existe une machine \\(R\\) qui r\u00e9duit \\(A\\) vers \\(B\\) en temps polynomial. D'apr\u00e8s (2), il existe une machine \\(M\\) qui d\u00e9cide \\(B\\) en temps polynomial. On construit donc la machine suivante \\(M'\\) suivante : <pre><code>flowchart LR\n    classDef instance fill:lightblue,stroke:transparent,fill:transparent;\n    classDef machine fill:pink;\n    classDef reduction fill:lightgreen,stroke:green;\n    classDef answer fill:lightblue,stroke:transparent,fill:transparent;\n\n    subgraph MM[\"$$M'$$\"]\n    R--&gt; J[\"$$I_B$$\"];\n    J--&gt; M[\"$$M$$\"];\n    end\n\n    I[\"$$I_A$$\"] --&gt; R@{ shape: delay };\n    M--&gt; X[\"oui/non\"];\n    class I,J instance;\n    class R reduction;\n    class M machine;\n    class X answer;</code></pre> Alors on bien :</p> <ul> <li>\\(I_A\\) est positive \\(\\Leftrightarrow\\) \\(I_B\\) est positive \\(\\Leftrightarrow\\) \\(M(I_B) = oui\\) \\(\\Leftrightarrow M'(I_A) = oui\\)</li> <li>\\(M'\\) fonctionne en temps polynomial dans le pire cas (m\u00eame preuve que pour la composition des r\u00e9ductions \\(R_1\\) et \\(R_2\\) ci-dessus).</li> </ul>"},{"location":"algo/decicomp/#3-la-classe-np","title":"3. La classe NP","text":"<p>Spoiler</p> <p>NP ne signifie pas non polynomial</p> <p>Certains probl\u00e8mes que l'on rencontre en informatique sont difficiles \u00e0 r\u00e9soudre efficacement. Cependant si on vous donne une solution au probl\u00e8me, il est facile de v\u00e9rifier que cette solution est la bonne.</p> <p>Un exemple important est celui du probl\u00e8me appel\u00e9 SAT :</p> <ul> <li>Instance : une formule \\(F\\) de la logique propositionnelle</li> <li>Question : \\(F\\) est elle satisfiable ?</li> </ul> <p>Il est difficile de concevoir un algorithme qui permette de r\u00e9pondre \u00e0 cette question en temps polynomial par rapport \u00e0 la taille de la formule. Vous connaissez bien quelques algorithmes pour le r\u00e9soudre (dresser la table de v\u00e9rit\u00e9 de la formule, algorithme de Quine) mais ils sont tous de complexit\u00e9 exponentielle.</p> <p>Par contre, si on vous donne une valuation \\(\\varphi\\) qui satisfait \\(F\\), alors il est tr\u00e8s facile de v\u00e9rifier que cette valuation convient bien, c'est-\u00e0-dire que \\(\u27e6F\u27e7_\\varphi = true\\). Autrement dit, on peut facilement \u00e9crire un algorithme \u00e0 deux entr\u00e9es une pour une formule et l'autre pour une valuation et qui v\u00e9rifie si la valuation donn\u00e9e satisfait bien la formule, tout cela en temps polynomial par rapport \u00e0 la la taille de la formule. On peut par exemple proc\u00e9der par r\u00e9currence en OCaml, comme ceci:</p> V\u00e9rificateur pour SAT<pre><code>    type formule = Var of int | Not of formule |\u00a0Et of formule | Ou of formule;;\n\n    let rec verificateur f phi = match f with\n    | Var(i) -&gt; phi.(i) (* valuation donn\u00e9e sous forme d'un bool array *)\n    | Not g -&gt; not (verificateur g phi)\n    | Et(g, h) -&gt; (verificateur g phi) &amp;&amp; (verificateur h phi)\n    | Ou(g, h) -&gt; (verificateur g phi) || (verificateur h phi)\n    ;;\n</code></pre> <p>Cette notion de probl\u00e8me facile \u00e0 v\u00e9rifier correspond \u00e0 la classe de probl\u00e8mes appel\u00e9e NP.</p> <p>D\u00e9finition (classe NP)</p> <p>Un probl\u00e8me de d\u00e9cision \\(A\\) est dans la classe NP, s'il existe un nombre r\u00e9el \\(k &gt; 0\\) et une machine \\(V\\) appel\u00e9e v\u00e9rificateur ayant deux entr\u00e9es :</p> <ul> <li>une entr\u00e9e \\(I\\) : pour une instance du probl\u00e8me de d\u00e9cision</li> <li>une entr\u00e9e \\(C\\) : appel\u00e9e certificat</li> </ul> <p>et qui r\u00e9pond oui/non avec le comportement suivant :</p> <ol> <li>\\(V(I, C)\\) s'ex\u00e9cute dans le pire cas en temps \\(O(n^k)\\) avec \\(n = |I|\\) la taille de l'instance.</li> <li>\\(I\\) est une instance positive de \\(A\\) \\(\\Leftrightarrow\\) il existe une entr\u00e9e \\(C\\) telle que \\(V(I, C) = oui\\).</li> </ol> <pre><code>%%{init: { \"flowchart\": { \"curve\": \"stepAfter\" } }}%%\nflowchart LR\n    classDef instance fill:lightblue,stroke:transparent,fill:transparent;\n    classDef machine fill:pink;\n    classDef answer fill:lightblue,stroke:transparent,fill:transparent;\n    I[\"instance I\"] --&gt; V[\"v\u00e9rificateur V\"];\n    C[\"certificat C\"] --&gt; V;\n    V --&gt; R[oui/non];\n    class I,C instance;\n    class M machine;\n    class R answer;</code></pre> <p>Informellement, la classe NP est la classe des prob\u00e8mes pour lesquels les instances positives admettent une preuve de positivit\u00e9 \\(C\\) qui peut \u00eatre v\u00e9rifi\u00e9e en temps polynomial par un algorithme. Dans le cas de SAT par exemple, un certificat est une valuation qui satisfait la formule F donn\u00e9e.</p> <p>Th\u00e9or\u00e8me</p> <p>P \\(\\subset\\) NP</p> <p>D\u00e9monstration</p> <p>Soit \\(A\\) un probl\u00e8me dans P. Il existe donc un r\u00e9el \\(k &gt; 0\\) et une machine \\(M\\) qui d\u00e9cide \\(A\\) en temps \\(O(n^k)\\) avec \\(n\\) la taille de l'instance. On pose la machine \\(V\\) d\u00e9finie par \\(V(I, C) = M(I)\\). On a alors :</p> <ul> <li>La machine \\(V\\) s'ex\u00e9cute en pire cas en temps \\(O(n^k)\\).</li> <li>Si la r\u00e9ponse \u00e0 \\(I\\) est oui, alors en prenant n'importe quel certificat, par exemple le certficat vide \\(C = \\varnothing\\), on a \\(V(I, C) = M(I) = oui\\).</li> <li>R\u00e9ciproquement, s'il existe \\(C\\) tel que \\(V(I, C) = oui\\) alors \\(M(I) = V(I, C) = oui\\) donc \\(I\\) est positive. <pre><code>%%{init: { \"flowchart\": { \"curve\": \"stepAfter\" } }}%%\nflowchart LR\n    classDef instance fill:lightblue,stroke:transparent,fill:transparent;\n    classDef machine fill:pink;\n    classDef answer fill:lightblue,stroke:transparent,fill:transparent;\n\n    subgraph V\n    X@{ shape: stop };\n    M[\"$$M$$\"];\n    end\n    I[\"instance I\"] --&gt; M;\n    M --&gt; R[oui/non]\n    C[\"certificat C\"] --&gt; X;\n    class I,C instance;\n    class M machine;\n    class R answer;</code></pre> Conclusion : on a bien construit un v\u00e9rificateur en temps polynomial pour le probl\u00e8me \\(A\\), donc \\(A \\in \\mathbf{NP}\\)</li> </ul> <p>J'esp\u00e8re que ce th\u00e9or\u00e8me chassera en vous l'id\u00e9e que NP signifierait \"non polynomial\"...</p> <p>Probl\u00e8me ouvert depuis 1971</p> <p>On ne sait pas aujourd'hui si P = NP ou si P \\(\\neq\\) NP.</p>"},{"location":"algo/decicomp/#4-la-classe-np-complet","title":"4. La classe NP-complet","text":"<p>On s'int\u00e9resse ici \u00e0 certains probl\u00e8mes de NP qui combinent deux aspects :</p> <ul> <li>on les rencontre assez fr\u00e9quemment en informatique</li> <li>ils sont particuli\u00e8rement coriaces \u00e0 r\u00e9soudre</li> </ul> <p>D\u00e9finition (probl\u00e8me NP-complet)</p> <p>Un probl\u00e8me de d\u00e9cision \\(A\\) est NP-complet s'il v\u00e9rifie :</p> <ol> <li>\\(A \\in \\mathbf{NP}\\)</li> <li>\\(A\\) est NP-difficile, ce qui signifie : \\(\\forall B \\in \\mathbf{NP}, B \\leq_P A\\)</li> </ol> <p>Attention \u00e0 ne pas oublier l'hypoth\u00e8se 1. L'hypoth\u00e8se 2 signifie que les probl\u00e8mes de NP-difficiles sont des majorants de NP, autrement dit les probl\u00e8mes NP-complets sont les probl\u00e8mes les plus difficiles de NP.</p> <p>Bien s\u00fbr, la premi\u00e8re question que l'on se pose est existe-t-il de tels probl\u00e8mes ?, la r\u00e9ponse est oui d'apr\u00e8s le th\u00e9or\u00e8me (admis) suivant :</p> <p>Th\u00e9or\u00e8me de Cook-Levin (1971)</p> <p>Le probl\u00e8me SAT est NP-complet</p> <p>Nous avons d\u00e9j\u00e0 montr\u00e9 ci-dessus que SAT \\(\\in\\) NP, la partie difficile et admise de ce th\u00e9or\u00e8me est que SAT est aussi NP-difficile.</p> <p>Pour se convaincre de la difficult\u00e9 des probl\u00e8mes NP-complets on peut aussi consid\u00e9rer la proposition suivante.</p> <p>Proposition</p> <p>Soit \\(A\\) un probl\u00e8me \\(NP\\)-complet. </p> <ol> <li>S'il existe une machine \\(M\\) qui d\u00e9cide \\(A\\) en temps polynomial alors \\(\\mathbf{P} = \\mathbf{NP}\\).</li> <li>Si \\(\\mathbf{P} \\neq \\mathbf{NP}\\) alors il n'existe pas de machine pour d\u00e9cider \\(A\\) en temps polynomial.</li> </ol> <p>Autrement dit (1) dit que trouver un algorithme polynomial pour r\u00e9soudre un probl\u00e8me NP-complet revient \u00e0 r\u00e9soudre le c\u00e9l\u00e8bre probl\u00e8me ouvert. La reformulation (2) dit que si on admet que \\(\\mathbf{P} \\neq \\mathbf{NP}\\)  alors il est impossible de trouver un algorithme de complexit\u00e9 raisonnable pour r\u00e9soudre \\(A\\)...</p> <p>Ceci explique aussi pourquoi on s'int\u00e9resse tant \u00e0 la question \\(P = NP\\) ?</p> <p>D\u00e9monstration</p> <ul> <li>(2) est la contrapos\u00e9e de (1) donc il suffit de montrer (1)</li> <li>Supposons qu'il existe une machine \\(M\\) pour r\u00e9soudre \\(A\\) en temps polynomial, donc \\(A \\in \\mathbf{P}\\). On sait d\u00e9j\u00e0 que \\(\\mathbf{P} \\subset \\mathbf{NP}\\), il reste \u00e0 montrer l'inclusion inverse. Soit \\(B \\in \\mathbf{NP}\\), comme \\(A\\) est NP-difficile, \\(B \\leq_P A\\). Mais d'apr\u00e8s la proposition de la partie 2, on en d\u00e9duit que \\(B \\in \\mathbf{P}\\). Conclusion \\(\\mathbf{NP} \\subset \\mathbf{P}\\).</li> </ul>"},{"location":"algo/decicomp/#exemples-de-problemes-np-complets","title":"Exemples de probl\u00e8mes NP-complets","text":"<p>Il existe une multitude d'autres probl\u00e8mes NP-complets. Pour d\u00e9montrer la NP-compl\u00e9tude, on utilise en g\u00e9n\u00e9ral la proposition suivante :</p> <p>Proposition</p> <p>Soit \\(A\\) un probl\u00e8me de d\u00e9cision NP-complet et \\(B\\) un probl\u00e8me de d\u00e9cision. Si</p> <ol> <li>\\(B \\in \\mathbf{NP}\\)</li> <li>\\(A \\leq_P B\\)</li> </ol> <p>Alors \\(B\\) est NP-complet.</p> <p>D\u00e9monstration</p> <p>D'apr\u00e8s (1), \\(B \\in \\mathbf{NP}\\), il reste donc \u00e0 montrer que \\(B\\) est NP-difficile. Soit \\(C\\) un probl\u00e8me de NP, comme \\(A\\) est NP-complet, on a \\(C \\leq_P A\\). De plus, \\(A \\leq_P B\\) d'apr\u00e8s (2), donc par transitivit\u00e9 de \\(\\leq_P\\), on a \\(C \\leq_P B\\). Ainsi \\(B\\) est bien NP-difficile. Conclusion : \\(B\\) est NP-complet.</p> <p>Autrement dit pour montrer qu'un probl\u00e8me est NP-complet, il suffit de montrer qu'il est dans NP puis de montrer qu'il est plus difficile qu'un probl\u00e8me dont on sait d\u00e9j\u00e0 qu'il est NP-complet. Cette m\u00e9thode par r\u00e9duction permet de montrer \u00e0 partir de SAT que de nombreux autres probl\u00e8mes sont NP-complets. \u00c9tudions quelques exemples.</p>"},{"location":"algo/decicomp/#reduction-de-sat-a-3-sat","title":"R\u00e9duction de SAT \u00e0 3-SAT","text":"<p>Le probl\u00e8me 3-SAT est similaire \u00e0 SAT mais on se restreint aux formules sour formes normales conjonctives avec 3 litt\u00e9raux par clause au plus.</p> <ul> <li>Instance : une formule \\(F\\) de la logique propositionnelle sous forme normale conjonctive (CNF) avec 3 litt\u00e9raux par clause au plus.</li> <li>Question : \\(F\\) est elle satisfiable ?</li> </ul> <p>Il est facile de montrer que 3-SAT \\(\\in\\) NP : on peut utiliser exactement le m\u00eame v\u00e9rificateur que pour SAT.</p> <p>Montrons que SAT \\(\\leq_P\\) 3-SAT. On d\u00e9crit l'algorithme de r\u00e9duction \u00e0 l'aide d'un exemple : \\(F = x_1 \\to \\neg(x_2 \\leftrightarrow (x_1 \\land x_4))\\)</p>"},{"location":"algo/decicomp/#etape-1","title":"\u00c9tape 1","text":"<p>On voit la formule comme un arbre et on descend les n\u00e9gations aux feuilles \u00e0 l'aide des \u00e9quivalences suivantes :</p> <ul> <li>\\(\\neg(A \\land B) \\equiv (\\neg A \\lor \\neg B)\\)</li> <li>\\(\\neg(A \\lor B) \\equiv (\\neg A \\land \\neg B)\\)</li> <li>\\(\\neg(A \\to B) \\equiv (A \\land \\neg B)\\)</li> <li>\\(\\neg(A \\leftrightarrow B) \\equiv (A \\leftrightarrow \\neg B)\\)</li> </ul> <p>On obtient ainsi un arbre \u00e9quivalent, o\u00f9 les feuilles sont des litt\u00e9raux, et les noeuds sont des connecteurs parmi \\(\\land, \\lor, \\to, \\leftrightarrow\\). Dans notre exemple on obtient : \\(F \\equiv (x_1 \\to (x_2 \\leftrightarrow (\\neg x_1 \\lor \\neg x_4)))\\)</p> <p>Ce qui se repr\u00e9sente sous forme d'arbre binaire :     <pre><code>graph TD\n    A(\"$$\\to$$\") --&gt; B[$$x_1$$];\n    A --&gt; C(\"$$\\leftrightarrow$$\");\n    C --&gt; D[\"$$x_2$$\"];\n    C --&gt; E(\"$$\\lor$$\");\n    E --&gt; F[\"$$\\neg x_1$$\"];\n    E --&gt; G[\"$$\\neg x_4$$\"];</code></pre></p>"},{"location":"algo/decicomp/#etape-2","title":"\u00c9tape 2","text":"<p>On introduit des nouvelles variables \\(y_1, y_2, \\dots\\) pour chaque noeud de l'arbre binaire obtenu (chaque sous formule en fait) :     <pre><code>graph TD\n    A(\"$$y_1$$\") --&gt; B[$$x_1$$];\n    A --&gt; C(\"$$y_2$$\");\n    C --&gt; D[\"$$x_2$$\"];\n    C --&gt; E(\"$$y_3$$\");\n    E --&gt; F[\"$$\\neg x_1$$\"];\n    E --&gt; G[\"$$\\neg x_4$$\"];</code></pre> On va consid\u00e9rer que \\(y_1\\) est la variable associ\u00e9e \u00e0 la racine de l'arbre.</p>"},{"location":"algo/decicomp/#etape-3","title":"\u00c9tape 3","text":"<p>On va contraindre chaque variables \\(y_i\\) \u00e0 prendre pour valeur l'\u00e9valuation de la sous-formule \u00e0 laquelle est elle est associ\u00e9e. On introduit pour cela des formules propositionnelles \\(N_1, N_2, \\dots\\) ainsi :</p> <ul> <li>\\(N_1 = (y_1 \\leftrightarrow (x_1 \\to y_2)\\)</li> <li>\\(N_2 = (y_2 \\leftrightarrow (x_2 \\leftrightarrow y_3))\\)</li> <li>\\(N_3 = (y_3 \\leftrightarrow (\\neg x_1 \\leftrightarrow \\neg x_4))\\)</li> </ul> <p>Plus g\u00e9n\u00e9ralement, la formule \\(N_i\\) a pour forme \\(N_i = (y_i \\leftrightarrow (g \\bowtie d)\\) avec \\(g\\) et \\(d\\) les variables (ou litt\u00e9raux) correspondant aux fils gauche et droit et \\(\\bowtie\\) le connecteur logique du noeud.</p>"},{"location":"algo/decicomp/#etape-4","title":"\u00c9tape 4","text":"<p>On remarque alors que chaque formule \\(N_i\\) fait intervenir au plus 3 variables. On peut donc lui trouver une formule \u00e9quivalente sous forme normale conjonctive avec des clauses contenant 3 litt\u00e9raux au plus. On utilise par exemple sa table de v\u00e9rit\u00e9 qui fait 8 lignes au plus (donc 8 clauses dans le pire cas pour la FNC).</p> <p>Notons \\(C_i\\) la formule sous forme 3-CNF associ\u00e9e \u00e0 cahque \\(N_i\\)</p>"},{"location":"algo/decicomp/#etape-5","title":"\u00c9tape 5","text":"<p>Au final on pose la formule \\(G = y_1 \\land C_1 \\land \\dots \\land C_m\\), qui est bien sous forme normale conjonctive avec au plus 3 litt\u00e9raux dans chaque clause. De plus, par construction \\(F\\) est satisfiable si et seulement si \\(G\\) est satisfiable. On remarque enfin que la r\u00e9duction est bien polynomiale :</p> <ul> <li>\u00e9tape 1 : descendre les n\u00e9gations est un parcours r\u00e9cursif de l'arbre binaire, donc de complexit\u00e9 lin\u00e9aire </li> <li>\u00e9tape 2 : on introduit \\(m\\) variables \\(y_i\\) qui sont en m\u00eame quantit\u00e9 que les noeuds internes de l'arbre binaire. Mais on sait que dans un arbre binaire: \\(f = m + 1\\) avec \\(f\\) le nombre de feuilles dans un arbre binaire. Donc \\(|F| = m + f = 2m + 1\\) donc \\(m\\) est lin\u00e9aire en la taille de \\(F\\) : \\(m = O(|F|)\\).</li> <li>\u00e9tape 3 : \\(O(m)\\) donc \\(O(|F|)\\)</li> <li>\u00e9tape 4 : la construction de chaque \\(C_i\\) prend un temps constant (en fonction de |F|), donc encore une fois cette \u00e9tape prend un temps \\(O(m)\\)</li> <li>\u00e9tape 5 : la formule \\(G\\) construite a donc pour taille \\(O(m) = O(|F|)\\).</li> </ul> <p>La r\u00e9duction est bien polynomiale (et m\u00eame lin\u00e9aire en fait !)</p> <p>Conclusion : on a montr\u00e9 que 3-SAT est NP et que SAT \\(\\leq_P\\) 3-SAT, donc 3-SAT est NP-complet.</p>"},{"location":"algo/decicomp/#reduction-de-3-sat-a-cnf-sat","title":"R\u00e9duction de 3-SAT \u00e0 CNF-SAT","text":"<p>Cette r\u00e9duction est beaucoup plus simple que la pr\u00e9c\u00e9dente !</p> <p>On consid\u00e8re cette fois le probl\u00e8me CNF-SAT :</p> <ul> <li>Instance : une formule \\(F\\) de la logique propositionnelle sous forme normale conjonctive (CNF).</li> <li>Question : \\(F\\) est elle satisfiable ?</li> </ul> <p>On montre d'abord que CNF-SAT est dans NP, en utilisant le m\u00eame v\u00e9rificateur que pour SAT.</p> <p>Ensuite on remarque que la fonction identit\u00e9 est une r\u00e9duction valide pour montrer 3-SAT \\(\\leq_P\\) CNF-SAT. En effet, chaque formule au format 3-CNF est bien une formule CNF en particulier.</p> <p>Ainsi CNF-SAT est NP-complet.</p> <p>Au final on a d\u00e9montr\u00e9 que 2 variantes du probl\u00e8me SAT sont NP-complet.</p>"},{"location":"algo/decicomp/#reduction-de-3-sat-a-clique","title":"R\u00e9duction de 3-SAT \u00e0 CLIQUE","text":"<p>Attaquons-nous maintenant \u00e0 une r\u00e9duction entre deux probl\u00e8mes qui n'ont a priori rien \u00e0 voir. On consid\u00e8re le probl\u00e8me CLIQUE :</p> <ul> <li>Instance : un graphe non orient\u00e9 \\(G\\) et un entier \\(K\\). </li> <li>Question : existe-t-il une clique de taille \\(K\\) dans le graphe \\(G\\) ?</li> </ul> <p>Montrons que CLIQUE est NP-complet.</p> <p>Tout d'abord CLIQUE est bien dans NP. En effet un certificat est par exemple, une liste \\(L\\) de \\(K\\) sommets qui forme une clique dans \\(G\\). Il est alors facile d'\u00e9crire un algorithme de complexit\u00e9 polynomiale, qui prend en entr\u00e9e \\((G, K)\\) d'une part (l'instance) et \\(L\\) d'autre part (le certificat) et qui v\u00e9rifie que les sommets de \\(L\\) forment bien une clique de taille \\(K\\). </p> <p>Montrons maintenant que 3-SAT \\(\\leq_P\\) CLIQUE.</p> <p>La r\u00e9duction doit partir d'une formule propositionnelle sous forme normale conjonctive qui contient 3 litt\u00e9raux au plus par clause. Le but est de construire un graphe \\(G\\) et de choisir un entier \\(K\\) tel que \\(F\\) est satisfiable si et seulement si \\(G\\) contient une \\(K\\)-clique.</p> <p>On explique la r\u00e9duction \u00e0 l'aide de l'exemple suivant : \\(F = (\\neg x \\lor y \\lor z) \\land (x \\lor \\neg y) \\land (x \\lor \\neg z)\\)</p> <p>On construit alors un graphe qui contient un noeud pour chaque occurence de litt\u00e9ral de \\(F\\). Dans ce graphe il existe un arc entre le litt\u00e9ral \\(\\ell\\) et le litt\u00e9ral \\(\\ell'\\) si et seulement si les deux conditions suivante sont v\u00e9rifi\u00e9es :</p> <ol> <li>Les occurrences \\(\\ell\\) et \\(\\ell'\\) n'appartiennent pas \u00e0 la m\u00eame clause</li> <li>\\(\\ell\\) et \\(\\ell'\\) sont compatibles c'est-\u00e0-dire qu'il n'existe pas de variable telle que \\(\\ell = x\\) et \\(\\ell' = \\neg x\\) (ou l'inverse).</li> </ol> <p>Voici le graphe \\(G\\) qu'on obtient sur l'exemple :     <pre><code>graph TD\n    subgraph X[\"$$C_1$$\"]\n    A(\"$$\\neg x$$\");\n    B(\"$$y$$\");\n    C(\"$$z$$\");\n    end;\n    subgraph Z[\"$$C_3$$\"]\n    D(\"$$\\neg z$$\");\n    E(\"$$x$$\");\n    end;\n    subgraph Y[\"$$C_2$$\"]\n    F(\"$$\\neg y$$\");\n    G(\"$$x$$\");\n    end;\n    A---F;\n    A---D;\n    B---G;\n    B---E;\n    B---D;\n    C---G;\n    C---F;\n    C---E;\n    D---G;\n    D---F;\n    E---G;\n    E---F;</code></pre> On choisit \u00e9galement \\(K = 3\\) car il y a 3 clauses dans la formule \\(F\\).</p> <p>V\u00e9rifions que la r\u00e9duction est correcte :</p> <ul> <li> <p>Si une valuation satisfait \\(F\\), par exemple \\((x,y,z) = (true, true, false)\\), alors cette valuation satisfait au moins un litt\u00e9ral par clause. Si on choisit pour chaque clause, l'un de ces litt\u00e9raux alors on obtient \\(K\\) sommets au total qui forment une clique :     <pre><code>graph TD\n    classDef true fill:lightgreen;\n    subgraph X[\"$$C_1$$\"]\n    A(\"$$\\neg x$$\");\n    B(\"$$y$$\");\n    C(\"$$z$$\");\n    end;\n    subgraph Z[\"$$C_3$$\"]\n    D(\"$$\\neg z$$\");\n    E(\"$$x$$\");\n    end;\n    subgraph Y[\"$$C_2$$\"]\n    F(\"$$\\neg y$$\");\n    G(\"$$x$$\");\n    end;\n    A---F;\n    A---D;\n    B---G;\n    B---E;\n    B---D;\n    C---G;\n    C---F;\n    C---E;\n    D---G;\n    D---F;\n    E---G;\n    E---F;\n    class B,G,D true;</code></pre>     En effet, les litt\u00e9raux sont forc\u00e9ment deux \u00e0 deux compatibles car ils sont vrais simultan\u00e9ment.</p> </li> <li> <p>R\u00e9ciproquement, si le graphe \\(G\\) admet une \\(K\\) clique alors il y a exactement 1 sommet par clause car les sommets d'une m\u00eame clause ne sont pas reli\u00e9s. On pose alors une valuation \\(\\varphi\\) qui rend vrai tous les litt\u00e9raux correspondants (ceci est possible car on n'a pas une variable et sa n\u00e9gation car les litt\u00e9raux sont 2 \u00e0 2 compatibles). Cette valuation rend alors vrai au moins un litt\u00e9ral par clause donc elle satisfait \\(F\\).</p> </li> </ul> <p>Cette r\u00e9duction est donc correcte, de plus elle est bien polynomiale : le nombre de sommets de \\(G\\) est major\u00e9 par \\(|F|\\) donc le graphe s'il est par exemple repr\u00e9sent\u00e9 par matrice d'adjacence a pour taille \\(O(|F|^2)\\).</p> <p>Culture</p> <p>En 1972, Richard Karp (Prix Turing 1985) utilise ce proc\u00e9d\u00e9 pour montrer que 21 probl\u00e8mes fr\u00e9quents en informatique sont NP-complets, on y trouve par exemple :</p> <ul> <li>couverture par sommets d'un graphe</li> <li>probl\u00e8me du sac \u00e0 dos</li> <li>existence de circuits Hamiltoniens dans un graphe</li> <li>partition d'un ensemble d'entiers en deux sous-ensembles de m\u00eame somme</li> <li>...</li> </ul>"},{"location":"algo/decicomp/#5-les-problemes-indecidables","title":"5. Les probl\u00e8mes ind\u00e9cidables","text":"<p>Pour conclure ce chapitre nous consid\u00e9rons maintenant les probl\u00e8mes de d\u00e9cision qui sont impossibles \u00e0 r\u00e9soudre. Un probl\u00e8me est ind\u00e9cidable s'il n'est pas d\u00e9cidable, autrement dit s'il n'existe pas de machine (i.e. d'algorithme) qui termine toujours et qui r\u00e9pond oui/non correctement par rapport \u00e0 l'instance donn\u00e9e.</p> <p>L'existence de tels probl\u00e8mes est surprenante et est la cons\u00e9quence de deux faits :</p> <ul> <li>les machines \\(M\\) peuvent \u00eatre trait\u00e9es comme des donn\u00e9es : toute machine poss\u00e8de un codage qu'on notera \\(&lt;M&gt;\\)</li> <li>les machines sont capables d'ex\u00e9cuter une machine \u00e0 partir de son code \\(&lt;M&gt;\\).</li> </ul> <p>D\u00e9finition (Machine universelle)</p> <p>Une machine \\(U\\) est universelle si elle est capable d'effectuer le calcul de \\(M(x)\\) si elle poss\u00e8de pour donn\u00e9es le code de la machine \\(&lt;M&gt;\\) et l'entr\u00e9e \\(x\\).</p> <p>Nous admettons que le mod\u00e8le de calcul qu'on consid\u00e8re poss\u00e8de cette propri\u00e9t\u00e9. En effet : il est possible de voir un algorithme ou un programme C/OCaml comme une donn\u00e9e (par exemple le fichier source du programme). Il est \u00e9galement possible d'\u00e9crire un programme capable d'ex\u00e9cuter cet algorithme ou ce programme \u00e0 partir de sa description (par exemple un interpr\u00e8te ou un programme qui compile et ex\u00e9cute le code). Autrement dit, nos ordinateurs sont assez puissants pour \u00eatre capable d'ex\u00e9cuter un programme qu'on lui donne en entr\u00e9e.</p> <p>Le fait de pouvoir voir les algorithmes et les programmes comme des donn\u00e9es peut sembler \u00eatre une propri\u00e9t\u00e9 souhait\u00e9e, mais cela va malheureusement entrainer l'existence de probl\u00e8mes ind\u00e9cidables. Le plus c\u00e9l\u00e8bre est le probl\u00e8me HALT :</p> <ul> <li>Instance : le code d'une machine \\(&lt;M&gt;\\) et une entr\u00e9e \\(x\\) pour la machine \\(M\\)</li> <li>Question : le calcul \\(M(x)\\) termine-t-il ?</li> </ul> <p>Proposition</p> <p>HALT est ind\u00e9cidable.</p> <p>D\u00e9monstration</p> <p>Supposons par l'absurde qu'il existe une telle machine qu'on appelle \\(H\\) qui termine sur toute entr\u00e9e et qui v\u00e9rifie \\(H(&lt;M&gt;, x) = oui\\) si et seulement si \\(M(x)\\) termine. On consid\u00e8re la machine diagonale \\(D\\) prenant en entr\u00e9e un code de machine \\(&lt;M&gt;\\) et qui fait le calcul suivant, donn\u00e9 en pseudo-code : <pre><code>def D(&lt;M&gt;):\n    b &lt;- H(&lt;M&gt;, &lt;M&gt;) // &lt;M&gt; est une suite de 1/0 donc on peut prendre cette information comme x\n    if b = true then\n        while (true) do {} // boucle infinie\n    else\n        return true\n</code></pre> On obtient la contractiction suivante \\(D(&lt;D&gt;)\\) termine si et seulement si \\(H(&lt;D&gt;, &lt;D&gt;) = false\\) si et seulement si \\(D(&lt;D&gt;)\\) ne termine pas. C'est absurde.</p> <p>Le fait que HALT soit ind\u00e9cidable permet de montrer que beaucoup d'autres probl\u00e8mes le sont, voici un exemple :</p> <p>Exercice</p> <p>Soit le probl\u00e8me de d\u00e9cision HW suivant :</p> <ul> <li>Instance : le code d'une machine \\(&lt;M&gt;\\) ne prenant pas d'entr\u00e9e.</li> <li>Question : est-ce que la machine \\(M\\) produit en sortie le texte Hello World! ?</li> </ul> <p>Montrer que HW est ind\u00e9cidable.</p> Solution <p>Supposons par l'absurde qu'il existe une telle machine \\(HW\\). On va construire une machine \\(H\\) prenant en entr\u00e9e le code d'une machine \\(&lt;M&gt;\\) et une entr\u00e9e \\(x\\) pour M et dont voici la description :</p> <ul> <li>elle \u00e9crit la description d'une machine \\(&lt;P&gt;\\) ex\u00e9cutant le programme suivant : calculer \\(M(x)\\) (machine universelle) puis produire en sorie Hello World!</li> <li>elle calcule \\(HW(&lt;P&gt;)\\) et renvoie la r\u00e9ponse oui/non</li> </ul> <p>Alors si \\(H(&lt;M&gt;, x) = oui\\) c'est que \\(HW(&lt;P&gt;) = oui\\) donc P affiche Hello world! et donc le calcul de \\(M(x)\\) s'est termin\u00e9. Si \\(H(&lt;M&gt;, x) = non\\) c'est que \\(HW(&lt;P&gt;) = non\\), c'est que P n'affiche pas Hello world!, cela n'est possible que si \\(M(x)\\) ne termine pas. Conclusion HW d\u00e9cide HALT c'est absurde. Donc HW n'est pas d\u00e9cidable.</p> <p>Plus g\u00e9n\u00e9ralement, il existe un th\u00e9or\u00e8me (Rice) qui exprime que toute propri\u00e9t\u00e9 s\u00e9mantique non triviale sur un programme est ind\u00e9cidable par exemple :</p> <ul> <li>Est-ce que le programme peut renvoyer la valeur nulle ?</li> <li>Est-ce que le programme calcule la fonction \"carr\u00e9e\" ? Est-ce que le programme impl\u00e9mente une fonction donn\u00e9e ?</li> <li>Est-ce que le programme envoie un message sur internet ?</li> <li>etc...</li> </ul>"},{"location":"algo/graphes/","title":"Graphes, g\u00e9n\u00e9ralit\u00e9s et parcours","text":""},{"location":"algo/graphes/#1-rappels","title":"1. Rappels","text":""},{"location":"algo/graphes/#a-definitions","title":"A. D\u00e9finitions","text":"<p>Nous avons revu en cours :</p> <ul> <li>D\u00e9finition d'un graphe orient\u00e9 ou non</li> <li>Rappels sur l'accessibilit\u00e9 : d\u00e9finition de chemin, de composante connexe</li> </ul>"},{"location":"algo/graphes/#b-representations-en-machine","title":"B. Repr\u00e9sentations en machine","text":"<p>Nous avons revu en cours :</p> <ul> <li>Repr\u00e9sentation par matrice d'adjacence</li> <li>Repr\u00e9sentation par listes d'adjacence</li> <li>Repr\u00e9sentation implicite</li> </ul>"},{"location":"algo/graphes/#2-parcours-de-graphe-generique","title":"2. Parcours de graphe g\u00e9n\u00e9rique","text":"<p>Les parcours de graphes permettent de r\u00e9pondre \u00e0 la question de l'accessibilit\u00e9 entre deux sommets d'un graphe. Leur \u00e9tude est fondamentale car ils sont d'une part efficaces et d'autre part constituent souvent un excellent point de d\u00e9part pour r\u00e9soudre des probl\u00e8mes sur les graphes. (exemples : calcul des composantes connexes, existence de cycles, 2-colorabilit\u00e9, etc)</p> <p>Un parcours de graphe consiste \u00e0 explorer les sommets d'un graphe de proche en proche en partant d'un sommet choisi \\(x_d\\). Lors de ce parcours, un certain marquage des sommets doit \u00eatre maintenu afin d'\u00e9viter de r\u00e9-explorer les sommets qui ont d\u00e9j\u00e0 \u00e9t\u00e9 explor\u00e9s. Nous distinguerons 3 types sommets :</p> <ul> <li>Les sommets non d\u00e9couverts, qu'on marquera avec la couleur blanche</li> <li>Les sommets ouverts, qu'on marquera avec la couleur grise : ces sommets ont \u00e9t\u00e9 d\u00e9couverts comme voisin d'un sommet explor\u00e9, mais ils sont en attente d'\u00eatre explor\u00e9s</li> <li>Les sommets ferm\u00e9s, qu'on marquera avec la couleur noire : ces sommets ont \u00e9t\u00e9 explor\u00e9s</li> </ul> <p>De plus, on va m\u00e9moriser des sommets ouverts, en attente d'\u00eatre explor\u00e9s, dans une structure de donn\u00e9es g\u00e9n\u00e9rique appel\u00e9e sac qui supporte les op\u00e9rations d'insertion et d'extraction.</p> <p>Algorithme : parcours g\u00e9n\u00e9rique</p> <p> </p> <p>On remarque lors de l'ex\u00e9cution du parcours sur des exemples, qu'un m\u00eame sommet est en g\u00e9n\u00e9ral plac\u00e9 plusieurs fois dans le sac, car il a \u00e9t\u00e9 d\u00e9couvert s\u00e9par\u00e9ment par chacun de ses voisins.</p> <p>Selon la structure de donn\u00e9es utilis\u00e9e pour impl\u00e9menter concr\u00e8tement le graphe, on obtient les algorithmes classiques suivants :</p> <ul> <li>Si le sac est une pile (LIFO) on obtient un parcours en profondeur</li> <li>Si le sac est une file (FIFO) on obtient un parcours en largeur</li> <li>Si le sac est une file de priorit\u00e9 avec les poids d'ar\u00eates on obtient l'algorithme de Prim (hors programme)</li> </ul> <p>Une version simplifi\u00e9e de ce parcours ne tient compte que de deux \"couleurs\" : Visit\u00e9 (noir) ou non (blanc/gris). Dans ce cas le changement de couleur du blanc au gris est inutile. Nous verrons qu'il est toutefois utile de faire le distingo surtout lors de l'\u00e9tude des algorithmes de Dijkstra et de A*.</p>"},{"location":"algo/graphes/#arborescence-du-parcours","title":"Arborescence du parcours","text":"<p>Il est important de comprendre que tout parcours a pour r\u00e9sultat la construction d'une arborescence qui est un arbre repr\u00e9sentant les chemins utilis\u00e9s lors du parcours depuis le sommet \\(x_d\\).</p> <p>Cet arborescence s'obtient en notant pour chaque sommet explor\u00e9 son parent qui est le sommet qui a permis sa d\u00e9couverte. Plus pr\u00e9cis\u00e9ment le parent est d\u00e9fini ainsi :</p> <p>Algorithme : parcours g\u00e9n\u00e9rique avec arborescence</p> <p> </p> <p>Puisqu'un m\u00eame sommet peut appara\u00eetre plusieurs fois dans le sac depuis des sommets diff\u00e9rents. La premi\u00e8re occurrence \u00e0 \u00eatre extraite du sac, d\u00e9signera le sommet qui sera son parent dans l'arborescence du parcours.</p> <p>Proposition</p> <ol> <li>\u00c0 la fin de l'algorithme du parcours, tout sommet \\(x\\) ferm\u00e9 (noir) est accessible depuis \\(x_d\\) par un chemin provenant du sommet \\(parent[x]\\). </li> <li>Si un sommet \\(x\\) est accessible depuis \\(x_d\\) alors \u00e0 la fin du parcours, il sera ferm\u00e9 (de couleur noire).</li> </ol> <p>D\u00e9monstration</p> <ol> <li>On fait une preuve par invariant. On pose</li> </ol> \\[ I : \\quad \\ll \\forall x \\in S, \\  c[x] = Noir \\quad \\Longrightarrow \\quad x_d \\leadsto x \\text{ (provenant de parent[x])} \\gg \\] <ol> <li>Se d\u00e9montre par r\u00e9currence sur la longueur du chemin permettant d'atteindre \\(x\\) depuis \\(x_d\\).</li> </ol> \\[ P(n) : \\quad \\ll \\exists u_0 \\rightarrow u_1 \\rightarrow \\dots \\rightarrow u_n \\text{ avec }\\gg \\]"},{"location":"algo/graphes/#2-parcours-en-profondeur-dfs","title":"2. Parcours en profondeur (DFS)","text":""},{"location":"algo/graphes/#3-parcours-en-largeur-bfs","title":"3. Parcours en largeur (BFS)","text":""},{"location":"algo/graphes/#4-algorithme-de-dijkstra","title":"4. Algorithme de Dijkstra","text":""},{"location":"algo/graphes/#5-algorithme-a","title":"5. Algorithme A*","text":""},{"location":"algo/proba/","title":"Algorithmes probabilistes, algorithmes d'approximation","text":""},{"location":"algo/proba/#1-algorithmes-probabilistes","title":"1. Algorithmes probabilistes","text":"<p>Un algorithme est dit probaliste lorsque son ex\u00e9cution d\u00e9pend de valeurs g\u00e9n\u00e9r\u00e9es al\u00e9atoirement. Nous \u00e9tudierons \u00e0 l'aide d'exemples, deux classes d'algorithmes probabilistes :</p> <ul> <li>Les algorithmes de Las Vegas qui donnent toujours un r\u00e9sultat correct mais dont le temps d'ex\u00e9cution est al\u00e9atoire. L'id\u00e9e est que l'esp\u00e9rance du temps d'ex\u00e9cution soit meilleure que celle d'un algorithme d\u00e9terministe.</li> <li>Les algorithmes de Monte Carlo qui donnent un r\u00e9sultat qui n'est pas forc\u00e9ment correct (soit faux avec faible probabilit\u00e9, soit approch\u00e9) mais dont le temps d'ex\u00e9cution est d\u00e9terministe.</li> </ul>"},{"location":"algo/proba/#a-generation-du-hasard","title":"A. G\u00e9n\u00e9ration du hasard","text":"<p>En informatique,  le hasard est g\u00e9n\u00e9r\u00e9 \u00e0 l'aide de nombre pseudo-al\u00e9atoires. Ces nombres sont obtenus comme les valeurs d'une certaine suite r\u00e9currente de type \\(u_{n+1} = f(u_n)\\). La valeur \\(u_0\\) utilis\u00e9e est appel\u00e9e la graine (seed en anglais). La graine peut-\u00eatre choisie au choix :</p> <ul> <li>arbitrairement (rend le programme d\u00e9terministe, utile pour d\u00e9bugger)</li> <li>comme le num\u00e9ro <code>PID</code> d'identification du processus actuel</li> <li>avec l'heure actuelle du systeme</li> <li>en utilisant un vrai hasard construit mat\u00e9riellement en mesurant le bruit thermique (instruction <code>RDRAND</code> disponible depuis 2012 sur les processeurs Intel)</li> </ul> <p>Attention</p> <p>Attention l'initialisation de la graine ne doit avoir lieu qu'une seule fois au d\u00e9but de votre programme.</p>"},{"location":"algo/proba/#en-langage-c","title":"En langage C","text":"<p>En langage C, les fonctions de hasard sont d\u00e9finies dans <code>stdlib.h</code>, la graine peut-\u00eatre initialis\u00e9e ainsi : <pre><code>#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n\nint main() {\n    srand(time(NULL));\n}\n</code></pre></p> <p>On peut ensuite utiliser la fonction <code>rand</code> qui g\u00e9n\u00e8re une valeur enti\u00e8re quelconque uniform\u00e9ment entre 0 et la constante <code>RAND_MAX</code> incluse, suppos\u00e9e grande. Il n'y a pas de fonction pour g\u00e9n\u00e9rer un flottant al\u00e9atoire, il faut ruser un peu : <pre><code>int main() {\n    ...\n    int a = rand();\n    int b = rand() % N; // Un entier entre 0 et N-1\n    int c = P + rand() % (Q-P+1); // Un entier entre P et Q \n    float u = (float) rand() / (float) RAND_MAX; // Un flottant entre 0 et 1\n    float u = 5.0 * (float) rand() / (float) RAND_MAX; // Un flottant entre 0 et 5\n}\n</code></pre></p>"},{"location":"algo/proba/#en-langage-ocaml","title":"En langage OCaml","text":"<p>En langage OCaml, les fonctions de hasard sont d\u00e9finies dans le module <code>Random</code>, la graine peut \u00eatre initialis\u00e9e ainsi : <pre><code>Random.self_init ();;\n</code></pre> Caml choisit automatiquement la meilleure source de hasard disponible sur votre syst\u00e8me pour le choix de la graine.</p> <p>Le module propose ensuite des fonctions pour g\u00e9n\u00e9rer des valeurs al\u00e9atoires. Voir le manuel OCaml pour une pr\u00e9sentation exhaustive.</p> <pre><code>(* Un entier entre p inclus et q exclus *)\nlet a = Random.int p q;;\n\n(* Un flottant entre 0 et 5 inclus *)\nlet u = Random.float 5.0;;\n</code></pre>"},{"location":"algo/proba/#une-astuce-a-connaitre","title":"Une astuce \u00e0 conna\u00eetre","text":"<p>Lorsqu'on \u00e9crit un programme probabiliste il est souvent utile d'obtenir un branchement probabiliste de type :</p> <ul> <li>avec une probablit\u00e9 \\(p\\) faire A</li> <li>sinon (avec une probabilit\u00e9 \\(1 - p\\)) faire B</li> </ul> <p>Pour cela on peut utiliser pour test, l'expression bool\u00e9eenne \\(X &lt; p\\) o\u00f9 \\(X\\) est une valeur al\u00e9atoire flottante g\u00e9n\u00e9r\u00e9e dans \\([0, 1]\\). Cela fonctionne car dans ce cas \\(P(X &lt; p) = p\\).</p> <p>Consid\u00e9rons l'exemple suivant qui consiste \u00e0 tirer \u00e0 pile ou face \\(n\\) fois avec une pi\u00e8ce truqu\u00e9e (\\(p\\) est la probabilit\u00e9 de faire face) et dans lequel on compte le nombre de face obtenus :</p> <pre><code>let nb_succes n p =\n    let compteur = ref 0 in\n    for k = 1 to n do\n        if (Random.float 1.0 &lt; p) then\n            incr compteur\n    done;\n    !compteur;;\n</code></pre>"},{"location":"algo/proba/#b-algorithmes-de-las-vegas","title":"B. Algorithmes de Las Vegas","text":"<p>Un algorithme de Las Vegas est un algorithme probabiliste qui donne toujours un r\u00e9sultat exact. L'utilisation du hasard permet en g\u00e9n\u00e9ral d'obtenir de meilleurs performances d'ex\u00e9cution.</p>"},{"location":"algo/proba/#tri-rapide-probabiliste","title":"Tri rapide probabiliste","text":"<p>On sait que dans le pire cas, c'est-\u00e0-dire par exemple quand l'entr\u00e9e est d\u00e9j\u00e0 tri\u00e9e, le tri rapide utilise \\(O(n^2)\\) compraisons.</p> <p>On peut am\u00e9liorer ce r\u00e9sultat en choisissant le pivot de mani\u00e8re al\u00e9atoire entre les indices \\(0\\) et \\(n-1\\). Cela permet d'obtenir un nombre de comparaisons de \\(O(n \\log n)\\) en moyenne.</p> <p>Le r\u00e9sultat sera toujours un tableau tri\u00e9 mais les performances d'ex\u00e9cution ont \u00e9t\u00e9 am\u00e9lior\u00e9es.</p>"},{"location":"algo/proba/#selection-rapide-quick-select","title":"S\u00e9lection rapide (quick select)","text":"<p>Consid\u00e9rons un tableau de taille \\(n\\) dans lequel on souhaite d\u00e9terminer la \\(t\\)-i\u00e8me plus grande valeur. Une mani\u00e8re de faire est de trier le tableau. Cependant, on sait qu'un tri par comparaisons effectuera au minimum \\(\\Omega(n \\log n)\\) comparaisons dans le pire cas.</p> <p>Hoare propose en 1961 l'algorithme probabiliste de type Las Vegas suivant :</p> <ol> <li>Choisir une valeur \\(y\\) au hasard dans le tableau</li> <li>Comparer \\(y\\) avec les \\(n-1\\) autres valeurs en r\u00e9organisant le tableau pour avoir les valeurs plus petites de \\(y\\) \u00e0 gauche et les plus grandes \u00e0 droite : \u00e0 l'instar du tri rapide. \\(y\\) finit en position d'indice \\(k\\).</li> <li>Si \\(k = t - 1\\) retourner \\(y\\)</li> <li>Si \\(k &gt; t - 1\\) chercher le \\(t\\)-i\u00e8me \u00e9l\u00e9ment du sous-tableau \\(T[0] \\dots T[k-1]\\) avec la m\u00eame m\u00e9thode</li> <li>Si \\(k &lt; t - 1\\) chercher le \\((t-k-1)\\)-i\u00e8me \u00e9l\u00e9ment du sous-tableau \\(T[k+1] \\dots T[n-1]\\) avec la m\u00eame m\u00e9thode.</li> </ol> <p>L'analyse math\u00e9matique du nombre moyen de comparaisons est un peu technique : elle a \u00e9t\u00e9 publi\u00e9e 10 ans plus tard (toujours par Hoare). On peut par exemple montrer que le nombre moyen de comparaisons \u00e0 effectuer  avec cet algorithme pour trouver la valeur m\u00e9diane d'un ensemble de \\(n\\) valeurs est de l'ordre de :</p> \\[ (2 + 2 \\ln 2) n \\] <p>C'est donc un temps lin\u00e9aire ce qui est beaucoup plus efficace que de trier le tableau.</p> <p>Voici une impl\u00e9mentation en langage C de cette fonction : <pre><code>#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid echanger(int t[], int a, int b) {\n    int tmp = t[a];\n    t[a] = t[b];\n    t[b] = tmp;\n}\n\n//Pivote le sous-tableau t[a:b] avec p le choix d'indice de pivot\n//Retourne la position finale du pivot\n//\nint pivoter(int t[], int a, int b, int p) {\n    echanger(t, a, p); // On place le pivot au d\u00e9but\n    int q = a; // position actuelle du pivot\n    for (int k = a; k &lt;= b; k += 1) {\n        if (t[k] &lt; t[q]) {\n            echanger(t, k, q+1);\n            echanger(t, q, q+1);\n            q += 1;\n        }\n    }\n    return q;\n}\n\n// Retourne la k-i\u00e8me plus grande valeur du sous-tableau t[a:b]\n// Attention : modifie le tableau\nint quickselect(int t[], int a, int b, int k) {\n   int p = a + rand() % (b - a + 1);\n   fprintf(stderr, \"Pivot choisi en pos %d\\n\", p);\n   p = pivoter(t, a, b, p);\n   if (p == a + k-1) {\n       return t[p];\n   } else if (p &gt; a + k-1) {\n       return quickselect(t, a, p-1, k);\n   } else {\n       return quickselect(t, p+1, b, k - (p - a + 1));\n   }\n}\n\nint main() {\n    srand(time(NULL));\n    int t[] = {5, 8, 3, 11, 4, 9, 1, 2, 10, 6, 7};\n    printf(\"Valeur mediane %d\\n\", quickselect(t, 0, 10, 6));\n}\n</code></pre></p>"},{"location":"algo/proba/#c-algorithmes-de-monte-carlo","title":"C. Algorithmes de Monte Carlo","text":"<p>Un algorithme de Monte Carlo est un algorithme probabiliste qui s'ex\u00e9cute en un temps d\u00e9terministe (qui ne d\u00e9pend pas du hasard). Le r\u00e9sultat est soumis \u00e0 une incertitude : * soit il est parfois faux (on esp\u00e8re avec une faible probabilit\u00e9) * soit il est approximatif</p>"},{"location":"algo/proba/#tester-si-un-nombre-est-premier","title":"Tester si un nombre est premier","text":"<p>L'algorithme na\u00eff pour tester si \\(p\\) est premier a une complexit\u00e9 \\(O(p)\\). Cela est suffisant pour tester si un petit entier est premier, mais cela n'est pas adapt\u00e9 aux applications cryptographiques. Typiquement la taille des entiers utilis\u00e9s en cryptographie est de l'ordre de 512 bits, ce qui repr\u00e9sente 155 chiffres en base 10. M\u00eame si une it\u00e9ration de boucle pouvait s'effectuer en 1 nanoseconde, il faudrait de l'ordre de \\(10^{137}\\) ann\u00e9es pour v\u00e9rifier si un entier de taille cryptographique est premier.</p> <p>Pour r\u00e9soudre ce probl\u00e8me on utilise des tests de primalit\u00e9 qui sont des algorithmes probabilistes. A titre d'exemple, on peut consid\u00e9rer le test de Fermat qui repose sur le petit th\u00e9or\u00e8me de Fermat :</p> <p>Petit th\u00e9or\u00e8me de Fermat</p> <p>Soit \\(p\\) un nombre premier et \\(a\\) un entier non divisible par \\(p\\) alors \\(a^{p-1} \\equiv 1 \\, (\\mathrm{mod}\\  p)\\).</p> <p>L'algorithme probabiliste qui en d\u00e9coule est le suivant :</p> <ol> <li>Choisir une entier \\(a\\) qui v\u00e9rifie \\(1 &lt; a &lt; p\\).</li> <li>Tester si \\(a^{p-1} \\equiv 1 \\, (\\mathrm{mod}\\ p)\\)</li> <li>Si le test est vrai : r\u00e9pondre vrai</li> <li>Si le test est faux : r\u00e9pondre faux</li> </ol> <p>C'est bien un algorithme de Monte Carlo : le temps d'ex\u00e9cution ne d\u00e9pend pas du hasard. De plus, si l'algorithme r\u00e9pond faux l'algorithme est correct. Si l'algorithme r\u00e9pond vrai il est possible qu'il se trompe (mais avec une faible probabilit\u00e9). Rappelons en effet que le calcul de \\(a^{p-1} \\, (\\mathrm{mod}\\ p)\\) peut renvoyer \\(p\\) valeurs possibles et que seule la valeur 1 est accept\u00e9e. Un entier \\(p\\) qui reussit ce test est dit probablement premier</p> <p>Si on veut diminuer le risque d'erreur, on peut r\u00e9p\u00e9ter ce test \\(k\\) fois :</p> <ol> <li>Choisir \\(k\\) entiers al\u00e9atoires \\(a\\) dans \\(]1, p[\\)</li> <li>Tester si chaque \\(a\\) v\u00e9rifie \\(a^{p-1} \\equiv 1 \\, (\\mathrm{mod}\\ p)\\)</li> <li>D\u00e8s qu'un test \u00e9choue : r\u00e9pondre faux</li> <li>Si tous les tests r\u00e9ussissent : r\u00e9pndre vrai</li> </ol> <p>Proposons une impl\u00e9mentation en langage <code>Python</code> de cette proc\u00e9dure. Nous utilisons exceptionnellement <code>Python</code> car il permet de pouvoir manipuler les grands entiers (&gt; 64 bits) de mani\u00e8re native. On commence par impl\u00e9menter le calcul de \\(a^n \\, (\\mathrm{mod}\\ p)\\) appel\u00e9 exponentiation modulaire en utilisant l'algorithme d'exponentiation rapide. On impl\u00e9mente ensuite la proc\u00e9dure avec \\(k\\) r\u00e9p\u00e9titions du test.</p> <pre><code># Calcul a^n modulo p\ndef mod_exp(a, n, p):\n    if n == 0:\n        return 1\n    elif n == 1:\n        return (a % p)\n    elif (n % 2 == 0):\n        return mod_exp((a * a) % p, n // 2, p)\n    else:\n        return (a * mod_exp((a * a) % p, n // 2, p)) % p\n\ndef test_de_fermat(p, k):\n    # On it\u00e8re k fois le test de fermat\n    for _ in range(k):\n        a = rd.randint(1, p-1)\n        if mod_exp(a, p-1, p) != 1:\n            return False\n    return True\n</code></pre> <p>Apart\u00e9 math\u00e9matique : si le nombre \\(p\\) n'est pas premier et n'est pas un nombre de Carmichael (nombres tr\u00e8s rares), alors il y a une probabilit\u00e9 \\(\\leq 1/2\\) que le test r\u00e9ussisse. Autrement dit si on r\u00e9p\u00e8te le test \\(k\\) fois comme on l'a fait, il y a une probabilit\u00e9 d'erreur inf\u00e9rieure \u00e0 \\(1/2^k\\).</p> <p>Il existe des tests encore plus pr\u00e9cis que celui de Fermat : Miller-Rabin, Solovay-Strassen.</p>"},{"location":"algo/proba/#las-vegas-monte-carlo-generer-un-nombre-probablement-premier-de-taille-cryptographique","title":"Las Vegas + Monte Carlo : g\u00e9n\u00e9rer un nombre probablement premier de taille cryptographique","text":"<p>Pour g\u00e9n\u00e9rer un nombre premier de taille cryptographique, disons de 512 bits, on peut utiliser l'algorithme de type Las Vegas suivant :</p> <ol> <li>G\u00e9n\u00e9rer un nombre al\u00e9atoire \\(n\\) impair de taille 512 bits</li> <li>Tester avec un algorithme de Monte Carlo si \\(n\\) est probablement premier</li> <li>Si oui, retourner \\(n\\)</li> <li>Si non, faire \\(n \\gets n + 2\\) et aller en 2</li> </ol> <p>Ce type de proc\u00e9dure est aujourd'hui utilis\u00e9 par les librairies cryptographiques telles que SSL (https).</p> <p>Voici une impl\u00e9mentation en <code>Python</code> de cet algorithme qui permet de g\u00e9n\u00e9rer en moins d'une seconde un grand nombre premier :</p> <pre><code># G\u00e9n\u00e8re un nombre entier impair de 512 bits\ndef random_big_odd_int():\n    n = 0\n    for _ in range(511):\n        n = 2 * n + rd.randint(0, 1)\n    n = 2 * n + 1\n    return n\n\n# G\u00e9n\u00e8re un nombre premier de taille cryptographique\ndef big_prime():\n    n = random_big_odd_int()\n    echecs = 0\n    while not(test_de_fermat(n, 10)):\n           echecs += 1\n           n += 2\n    print(\"Echecs : \", echecs)\n    return n\n</code></pre> <p>Dans le programme on a \u00e9galement affich\u00e9 le nombre de tentatives infructueuses avant de trouver un nombre premier. On constate que le plus souvent, moins de 500 it\u00e9rations suffisent.</p> <p>Cela est expliqu\u00e9 par le fameux Th\u00e9or\u00e8me des nombres premiers qui nous dit que le nombre de nombres premiers inf\u00e9rieur \u00e0 \\(x\\), not\u00e9  \\(\\pi(x)\\) v\u00e9rifie :</p> \\[ \\pi(x) \\sim \\frac{x}{\\ln(x)} \\] <p>Ainsi, la probabilit\u00e9 qu'un entier al\u00e9atoire soit premier est de l'ordre de \\(\\frac{1}{\\ln(x)}\\). Dans notre cas, on a environ \\(x = 2^{512}\\) ce qui donne une probabilit\u00e9 de 0,28%. Les nombres premiers sont rares mais pas si rares ! Ainsi si on teste pour 500 entiers grands entiers s'ils sont premier, on en trouvera en moyenne 1,5, ce qui explique que notre proc\u00e9dure fonctionne en pratique.</p>"},{"location":"algo/proba/#algorithme-du-recuit-simule","title":"Algorithme du recuit simul\u00e9","text":"<p>Cet algorithme sert \u00e0 d\u00e9terminer le maximum (ou le minimum) d'une fonction \\(f : E \\to \\mathbb{R}\\) en s'insipirant du processus de recuit en m\u00e9tallurgie. Ce processus consiste \u00e0 chauffer un m\u00e9tal puis \u00e0 le laisser refroidir tr\u00e8s lentement pour qu'il atteigne une organisation d'\u00e9nergie minimale.</p> <p>Intuitivement l'algorithme repose sur une valeur \\(T\\) appel\u00e9e temp\u00e9rature. Initialement on choisit un point \\(x = x_0 \\in E\\). \u00c0 chaque it\u00e9ration, on choisit al\u00e9atoirement une nouvelle valeur \\(x'\\) voisine de l'ancienne \\(x\\). Il peut alors se produire de choses, soit on obtient une plus grande valeur \\(f(x') &gt; f(x)\\) et on garde alors cette valeur \\(x \\gets x'\\). Soit la valeur est plus petite et on d\u00e9cide si on la garde al\u00e9atoirement avec une probabilit\u00e9 \\(p\\). Cette probabilit\u00e9 est d\u00e9finie par :</p> \\[ p = \\exp\\left(- \\frac{f(x) - f(x')}{T}\\right) \\] <p>On comprend alors deux choses : - Plus la temp\u00e9rature \\(T\\) est faible, moins on a de chances d'accepter \\(x'\\) - Plus diminution de \\(f(x)\\) est grande, moins on a de chances d'accepter \\(x'\\)</p> <p>\u00c0 la premi\u00e8re it\u00e9ration, on choisit une grande valeur de \\(T\\) puis \u00e0 chaque it\u00e9ration on fait diminuer tr\u00e8s l\u00e9g\u00e8rement \\(T\\). On d\u00e9cide de s'arr\u00eater soit \u00e0 un nombre fix\u00e9 d'it\u00e9rations, soit lorsque la temp\u00e9rature est jug\u00e9e assez basse.</p> <p>Voici un exemple d'impl\u00e9mentation de cet algorithme en <code>OCaml</code></p> <pre><code>(* On veut maximiser la fonction sur [-6, 6] *)\nlet f x =\n    -2.0 *. x ** 4.0 +. 5.0 *. x ** 3.0 +. 30.0 *. x ** 2.0 +. 5.0\n;;\n\nRandom.self_init ();;\n\n(* voisin de x dans [a, b] *)\nlet voisin x a b =\n    let delta = 1.0 -. (Random.float 2.0) in\n    let y = x +. delta in\n    if y &lt; a then\n        a\n    else if y &gt; b then\n        b\n    else\n        y\n;;\n\nlet recuit f a b x0 t0 tfinal =\n    let t = ref t0 in\n    let x = ref x0 in\n\n    while (!t &gt; tfinal) do\n        let y = voisin !x a b in\n        if f y &gt; f !x then begin\n            x := y\n        end\n        else begin\n            let p = exp (-. (f !x -. f y) /. !t) in\n            if (Random.float 1.0 &lt; p) then\n                x := y\n        end;\n        t := !t *. 0.999;\n        Printf.printf \"Temperature = %f \\t x = %f \\t f(x) = %f\\n \" !t !x (f !x)\n    done;\n    !x\n;;\n\nrecuit f (-6.0) (6.0) 0.0 10.0 1.0 ;;\n</code></pre> <p>On remarque que l'algorithme converge vers un maximum local. Cependant il n'atteint pas n\u00e9cessairement un maximum global. On obtient pas donc pas n\u00e9cessairement un r\u00e9sultat exact.</p>"},{"location":"algo/proba/#2-algorithmes-dapproximation","title":"2. Algorithmes d'approximation","text":"<p>Dans cette partie on introduit la notion de probl\u00e8me d'optimisation et on montre que certains sont difficiles \u00e0 r\u00e9soudre en pratique, en faisant le lien avec la th\u00e9orie de la d\u00e9cidadibilit\u00e9.</p>"},{"location":"algo/proba/#a-problemes-de-decision-et-doptimisation","title":"A. Probl\u00e8mes de d\u00e9cision et d'optimisation","text":"<p>D\u00e9finition</p> <p>Un probl\u00e8me d'optimisation :</p> <ul> <li>prend en entr\u00e9e une instance \\(I\\)</li> <li>introduit une fonction \\(f : X \\to \\mathbb{R}\\) qui d\u00e9pend de l'instance \\(I\\)</li> <li>cherche \u00e0 d\u00e9terminer une valeur \\(x \\in X\\) telle que \\(f(x)\\) est maximal (resp. minimal)</li> </ul> <p>Exemple : chemin de poids minimal dans un graphe</p> <p>On a d\u00e9j\u00e0 abord\u00e9 des probl\u00e8mes d'optimisation, par exemple d\u00e9terminer un chemin de poids minimal entre deux sommets dans un graphe :</p> <ul> <li>L'instance est le graphe \\(G\\), le sommet de d\u00e9part \\(a\\) et le sommet d'arriv\u00e9e \\(b\\)</li> <li>\\(X\\) est l'ensemble des chemins de \\(a\\) vers \\(b\\)</li> <li>\\(f : X \\to \\mathbb R\\) est la fonction qui \u00e0 chaque chemin associe son poids. On cherche \u00e0 minimiser \\(f\\).</li> </ul> <p>Pour cet exemple, on connait des algorithmes efficaces pour r\u00e9pondre \u00e0 la question.</p>"},{"location":"algo/proba/#lien-avec-les-problemes-de-decision","title":"Lien avec les probl\u00e8mes de d\u00e9cision","text":"<p>Tout probl\u00e8me d'optimisation peut \u00eatre transform\u00e9 en probl\u00e8me de d\u00e9cision \u00e0 l'aide d'un seuil. Soit \\(A\\) un probl\u00e8me de maximisation (par exemple) on pose le probl\u00e8me de d\u00e9cision \\(B\\) suivant :</p> <p>Instance : une instance de \\(A\\) et une valeur \\(v\\) de seuil</p> <p>Question : existe-t-il \\(x \\in X\\) tel que \\(f(x) &gt; v\\) ?</p> <p>\u00c0 quoi sert ce probl\u00e8me de d\u00e9cision ? Et bien il est utile car le probl\u00e8me d'optimisation \\(A\\) est plus difficile \u00e0 r\u00e9soudre que le probl\u00e8me de d\u00e9cision \\(B\\). En effet, si on sait r\u00e9soudre le probl\u00e8me d'optimisation en temps polynomial, c'est-\u00e0-dire on est capable de calculer la valeur \\(M\\) maximale de \\(f\\) alors on peut r\u00e9pondre imm\u00e9diatement \u00e0 la question \\(\\exists x : f(x) &gt; v ?\\) pour toute valeur de seuil \\(v\\) : il suffit de regarder si \\(v \\geq M\\).</p> <p>Donc si le probl\u00e8me de d\u00e9cision associ\u00e9 \u00e0 un probl\u00e8me d'optimisation est difficile, cela sera aussi le cas du probl\u00e8me d'optimisation. Par exemple, on a la proposition suivante :</p> <p>Proposition</p> <p>Soit \\(A\\) un probl\u00e8me d'optimisation, et \\(B\\) le probl\u00e8me de d\u00e9cision associ\u00e9. Si \\(B\\) est NP-complet alors il n'existe pas d'algorithme permettant de r\u00e9soudre \\(A\\) en temps polynomial, \u00e0 moins que \\(P = NP\\).</p> <p>Consid\u00e9rons le probl\u00e8me d'optimisation suivant appel\u00e9 MAX-CLIQUE</p> <p>Instance : un graphe \\(G\\) non orient\u00e9</p> <p>But : trouver une clique \\(C\\) de \\(G\\) de taille maximale</p> <p>Le probl\u00e8me de d\u00e9cision associ\u00e9 est le suivant :</p> <p>Instance : un graphe \\(G\\) non orient\u00e9 et une valeur \\(v\\)</p> <p>Question : existe-t-il une clique de taille \\(&gt; v\\) ?</p> <p>Il est facile de montrer que ce probl\u00e8me est NP-complet, donc il n'existe pas d'algorithme polynomial pour r\u00e9soudre MAX-CLIQUE \u00e0 moins que \\(P = NP\\).</p>"},{"location":"algo/proba/#b-algorithme-dapproximation","title":"B. Algorithme d'approximation","text":"<p>Que faire lorsqu'a montr\u00e9 qu'un probl\u00e8me d'optimisation est difficile ? Une mani\u00e8re de surmonter le probl\u00e8me est de se dire que l'on a peut-\u00eatre \u00e9t\u00e9 trop ambitieux sur la t\u00e2che \u00e0 accomplir : il n'est peut-\u00eatre pas n\u00e9cessaire d'obtenir une solution optimale mais une bonne solution peut suffire. </p> <p>D\u00e9finition : approximation d'un probl\u00e8me de maximisation</p> <p>Soit \\(A\\) un probl\u00e8me de maximisation, \\(f\\) la fonction \u00e0 maximiser et notons \\(M(I) = \\max_{x \\in X} f(x)\\) le maximum que l'on peut obtenir pour \\(f\\) sur une instance \\(I\\). Soit un r\u00e9el \\(0 &lt; \\rho &lt; 1\\). On dit qu'un algorithme fournit une \\(\\rho\\)-approximation de \\(A\\) si pour toute instance \\(I\\) il propose une solution \\(x \\in X\\) telle que :</p> \\[\\rho M(I) \\leq f(x) \\leq M(I) \\]"},{"location":"algo/proba/#le-probleme-max-sat","title":"Le probl\u00e8me MAX-SAT","text":"<p>\u00c0 titre d'exemple consid\u00e9rons le probl\u00e8me MAX-SAT suivant :</p> <p>Instance : une formule propositionnelle sous forme normale conjonctive</p> <p>But : trouver une valuation qui maximise le nombre de clauses satisfaites</p> <p>Si on utilise la conversion en probl\u00e8me de d\u00e9cision, on s'apercoit qu'il s'agirait de savoir si on peut satisfaire \\(k\\) clauses d'une formule ce qui est encore plus difficile que de savoir si on peut satisfaire la formule en entier. Ce probl\u00e8me d'optimisation est donc difficile.</p> <p>Pour le r\u00e9soudre on propose l'algorithme probabiliste de Monte-Carlo suivant : pour chaque variable dire qu'elle est vraie avec probabilit\u00e9 \\(1/2\\). Si chaque clause contient au moins \\(k\\) variables on obtient une \\((1 - 2^{-k})\\)-approximation en moyenne. Par exemple si on consid\u00e8re des formules de 3-CNF-SAT, on obtient une \\(7/8\\)-approximation en moyenne.</p> <p>Pour montrer ce r\u00e9sultat on va montrer que cette m\u00e9thode satisfait une proportion \\((1-2^{-k})\\) de toutes les clauses. On consid\u00e8re une clause \\((l_1 \\lor l_2 \\lor \\dots \\lor l_p)\\) o\u00f9 les litt\u00e9raux concernent des variables distinctes et \\(p \\geq k\\). Alors la probabilit\u00e9 que cette clause ne soit pas satisfaite est \\(1/2^p \\leq 1/2^k\\). Donc la probabilit\u00e9 que la clause soit satisfaite est au moins \\((1 - 1/2^k)\\). Si \\(d\\) est le nombre de clauses, le nombre de clauses satisfaites en moyennes sera :</p> \\[ \\mathbb{E}(C) \\geq (1 - 2^{-k}) d \\geq (1 - 2^{-k}) M(I) \\] <p>on obtient donc bien :</p> \\[ (1 - 2^{-k}) M(I) \\leq \\mathbb{E}(C) \\leq M(I) \\] <p>Ainsi nous voyons comme un algorithme de Monte Carlo peut obtenir un r\u00e9sultat approch\u00e9 correct en moyenne d'un probl\u00e8me d'optimisation difficile \u00e0 r\u00e9soudre de mani\u00e8re exacte.</p> <p>Remarquons que ce r\u00e9sultat est un peu d\u00e9routant : il nous apprend qu'une valuation al\u00e9atoire aura tendance \u00e0 satisfaire un grand nombre de clauses d'une formule sous forme normale conjonctive.</p> <p>Nous donnons maintenant l'\u00e9quivalent d'approximation pour un probl\u00e8me de minimisation :</p> <p>D\u00e9finition : approximation d'un probl\u00e8me de minimisation</p> <p>Soit \\(A\\) un probl\u00e8me de minimisation, \\(f\\) la fonction \u00e0 minimiser et notons \\(m(I) = \\min_{x \\in X} f(x)\\) le minimum que l'on peut obtenir pour \\(f\\) sur une instance \\(I\\). Soit un r\u00e9el \\(\\rho &gt; 1\\). On dit qu'un algorithme fournit une \\(\\rho\\)-approximation de \\(A\\) si pour toute instance \\(I\\) il propose une solution \\(x \\in X\\) telle que :</p> \\[M(I) \\leq f(x) \\leq \\rho M(I)\\] <p>Remarque</p> <p>Que ce soit pour un probl\u00e8me de maximisation ou de minimisation, on pr\u00e9f\u00e8re obtenir une \\(\\rho\\)-approximation pour \\(\\rho\\) aussi proche de 1 que possible. Plus \\(\\rho\\) est proche de 1, meilleure est la qualit\u00e9 de l'approximation.</p> <p>\u00c0 titre d'exemple on peut consid\u00e9rer le fameux probl\u00e8me du voyageur de commerce TSP (travelling salesman problem)</p> <p>Instance : un ensemble de \\(n\\) villes et la matrice de distances entre chaque villes But : trouver une tourn\u00e9e (un cycle) qui passe une et une seule fois par chaque ville et de distance totale minimale</p> <p>Il est possible de montrer que le probl\u00e8me de d\u00e9cision associ\u00e9 est NP-complet (par r\u00e9duction depuis le probl\u00e8me de cycle hamiltonien lui-m\u00eame NP-complet). C'est donc un probl\u00e8me d'optimisation difficile. De plus il est aussi possible de montrer qu'il n'admet pas de \\((1+\\varepsilon)\\)-approximation en temps polynomial et ce pour tout \\(\\varepsilon &gt; 0\\). C'est donc vraiment un probl\u00e8me th\u00e9oriquement difficile qui fait encore l'objet de recherches aujourd'hui.</p> <p>Toutefois, il existe de nombreuses m\u00e9thodes approch\u00e9es pour r\u00e9soudre le probl\u00e8me du voyageur de commerce en pratique (sur des petits exemples). On peut par exemple utiliser l'algorithme de Monte Carlo du recuit simul\u00e9 pour obtenir une bonne solution.</p> <p>Recuit simul\u00e9 pour le voyateur de commerce</p> <p>(Remerciement aux auteurs : Guillaume Grodwohl et Fran\u00e7ois Schwarzentruber)</p> <p>Une autre m\u00e9thode non probabiliste est d'utiliser un algorithme de type s\u00e9paration-\u00e9valuation branch and bound (voir TP).</p>"},{"location":"atelier/","title":"Atelier CPGE : coloration de graphes d'intervalles","text":"<p>D\u00e9but s\u00e9ance</p> <ol> <li>Faire l'appel</li> <li>Sp\u00e9cialit\u00e9s NSI 1\u00e8re et/ou terminale ?</li> </ol>"},{"location":"atelier/#1-graphes-30-min","title":"1. Graphes (30 min)","text":""},{"location":"atelier/#a-definitions-et-exemples","title":"A. D\u00e9finitions et exemples","text":"<p>D\u00e9finition (graphe)</p> <p>Un graphe \\(G\\) est un couple \\((S, A)\\) dans lequel :</p> <ul> <li>\\(S\\) est un ensemble fini de sommets</li> <li>\\(A\\) est un ensemble de paires de sommets \\(\\{x, y\\}\\) avec \\(x \\neq y\\)</li> </ul> <p>Les graphes interviennent dans la mod\u00e9lisation de nombreux probl\u00e8mes :</p> <ul> <li>Calcul d'itin\u00e9raires GPS</li> <li>Construction d'un emploi du temps</li> <li>Optimisation du transport d'un flot de marchandises</li> <li>Construction d'un r\u00e9seau de transport optimal</li> <li>R\u00e9solution du Rubik's cube</li> <li>etc.</li> </ul> <p>Les 7 ponts de K\u00f6nigsberg (Euler 1735)</p> <p>D\u00e9finitions</p> <p>Soit \\(G = (S, A)\\) un graphe connexe (= en une seule partie)</p> <ul> <li>deux sommets sont dits adjacents lorsque \\(\\{x, y\\} \\in A\\).</li> <li>dans ce cas on dit que \\(y\\) est un voisin de \\(x\\) (et aussi \\(y\\) est un voisin de \\(x\\)).</li> <li>le degr\u00e9 d'un sommet \\(x \\in S\\), not\u00e9 \\(d(x)\\) est le nombre de voisins de \\(x\\).</li> </ul> <p>Th\u00e9or\u00e8me d'Euler</p> <p>Un graphe poss\u00e8de un chemin Eul\u00e9rien dans ces deux cas seulement :</p> <ol> <li>Tous les degr\u00e9s sont pairs</li> <li>Il y a exactement 2 sommets de d\u00e9gr\u00e9 impair</li> </ol> <p>Probl\u00e8me du loup, de la ch\u00e8vre et du chou</p> <p>Un fermier souhaite poss\u00e9dant un chou, une ch\u00e8vre et un loup souhaite traverser une rivi\u00e8re \u00e0 l'aide d'une barque. Le probl\u00e8me est que la barque est petite et que le fermier ne peut emporter qu'une seule chose avec lui. De plus, il ne peut laisser seuls sans surveillance ni le loup et la ch\u00e8vre, ni la ch\u00e8vre et le chou. Comment traverse-t-il la rivi\u00e8re ?</p> <ol> <li>Construire un graphe mod\u00e9lisant le probl\u00e8me.</li> <li>Combien poss\u00e8de-t-il de sommets ? d'ar\u00eates ?</li> <li>\u00c0 quoi correspond le degr\u00e9 d'un sommet ?</li> <li>Combien y a-t-il de solutions \u00e0 ce probl\u00e8me ?</li> </ol>"},{"location":"atelier/#b-representation-informatique-dun-graphe","title":"B. Repr\u00e9sentation informatique d'un graphe","text":"<p>D\u00e9finition (listes d'adjacence)</p> <p>Soit \\(G\\) un graphe, on appelle listes d'adjacence du graphe l'ensemble des listes de voisins de chaque sommet.</p> <p>Repr\u00e9sentation d'un graphe par listes d'adjacence</p> <p>Pour repr\u00e9senter un informatiquement un graphe de taille \\(n\\), on peut :</p> <ol> <li>Num\u00e9roter chaque sommet de 0 \u00e0 \\(n-1\\)</li> <li>D\u00e9terminer la liste des voisins de chaque sommet.</li> <li>Enregistrer dans un tableau \\(G\\) de taille \\(n\\) chaque liste de voisins, de telle sorte que {\\tt G[i]} est lla liste des voisins du sommet d'indice \\(i\\).</li> </ol> <pre><code>G = [[1, 2], [], [0, 3]]\n</code></pre> <p>Calcul du degr\u00e9 d'un sommet</p> <pre><code>def degre(G, i):\n    voisins = G[i]\n    return len(voisins)\n</code></pre> <p>V\u00e9rification de chemin</p> <p>Ecrire une fonction qui v\u00e9rifie qu'une liste de sommets est un chemin du graphe.</p>"},{"location":"atelier/#c-cliques","title":"C. Cliques","text":"<p>D\u00e9finition (nombre clique)</p> <p>Soit \\(G\\) un graphe, on appelle nombre clique de \\(G\\), not\u00e9 \\(\\alpha(G)\\) le plus grand entier \\(k \\in \\mathbb{N}\\) tel qu'il existe une clique de taille \\(k\\) dans \\(G\\).</p> <p>Remarque</p> <p>Un sommet constitue \u00e0 lui seul une clique de taille 1, donc \\(\\alpha(G) \\geq 1\\).</p>"},{"location":"atelier/#2-coloration-de-graphes-30-min","title":"2. Coloration de graphes (30 min)","text":"<p>D\u00e9finition (coloration)</p> <p>Soit \\(G = (S, A)\\) un graphe. Soit \\(k \\in \\mathbb{N}^*\\) un entier naturel non nul. On appelle \\(k\\)-coloration d'un graphe une fonction de coloration \\(c : S \\to \\{0, 1, 2, ..., k-1\\}\\) qui a tout sommet \\(x\\) associe une couleur \\(c(x)\\) et qui v\u00e9rifie pour tous sommets \\(x\\), \\(y\\), \\(\\{x, y\\} \\in A \\Rightarrow c(x) \\neq c(y)\\).</p> <p>Les couleurs sont d\u00e9finies math\u00e9matiquement comme des entiers, mais peuvent \u00eatre vues comme des vraies couleurs. La d\u00e9finition dit que deux sommets adjacents doivent avoir une couleur diff\u00e9rente.</p> <p>D\u00e9finition (nombre chromatique)</p> <p>Soit \\(G\\) un graphe, on appelle nombre chromatique de \\(G\\), not\u00e9 \\(\\chi(G)\\) le plus petit entier \\(k \\in \\mathbb{N}\\) tel qu'il existe une \\(k\\)-coloration de \\(G\\).</p> <p>D\u00e9finition (coloration optimale)</p> <p>Une coloration est optimale si elle est utilise un nombre minimal de couleur, c'est-\u00e0-dire si elle est une k-coloration avec \\(k = \\chi(G)\\).</p> <pre><code>    def verifie_coloration(G, c):\n        ...\n</code></pre> <p>Proposition</p> <p>Soit \\(G\\) un graphe quelconque alors \\(\\alpha(G) \\leq \\chi(G)\\)</p> <p>On remarque sur des exemples que l'\u00e9galit\u00e9 n'est pas toujours vraie.</p>"},{"location":"atelier/#3-graphes-dintervalle-30-min","title":"3. Graphes d'intervalle (30 min)","text":"<p>D\u00e9finition (graphe d'intervalle)</p> <p>Soit \\(I_0, I_1, ..., I_{n-1}\\) \\(n\\) intervalles de la forme \\([a, b]\\). On appelle graphe d'intervalle de cet ensemble d'intervalle le graphe \\(G = (S, A)\\) d\u00e9fini par :</p> <ul> <li>\\(S\\) est l'ensemble des intervalles</li> <li>\\(I\\) est adjacent \u00e0 \\(J\\) lorsque \\(I \\cap J \\neq \\varnothing\\)</li> </ul> <p>R\u00e9servation de camping</p> <p>Prendre l'exemple du TD</p>"},{"location":"atelier/#construction-informatique-du-graphe-dintervalle","title":"Construction informatique du graphe d'intervalle","text":"<pre><code>    def collision(a, b, c, d):\n        test1 = b &lt;= c # [a, b] avant [c, d]\n        test2 = d &lt;= a # [c, d] avant [a, b]\n        col = not(test1 or test2)\n        return col\n</code></pre> <pre><code>    def construire_graphe(intervalles):\n        n = len(intervalles)\n        G = [ [] for i in range(n) ]\n        for i in range(0, n):\n            for j in range(i+1, n):\n                if collision(intervalles[i][0], intervalles[i][1], intervalles[j][0], intervalles[j][1]):\n                    G[i].append(j)\n                    G[j].append(i)\n        return G\n</code></pre>"},{"location":"atelier/#4-coloration-des-graphes-dintervalle-30-min","title":"4. Coloration des graphes d'intervalle (30 min)","text":""},{"location":"atelier/#a-un-algorithme-glouton","title":"A. Un algorithme glouton","text":"<pre><code>    def couleur_disponible(G, c, i):\n        k = 0\n        while (not(compatible(G, c, i, k))):\n            k = k + 1\u00e8re\n        return k\n</code></pre> <pre><code>    def coloration_glouton(G):\n        n = len(G)\n        c = [ -1 for i in range(0, n) ] # init : couleur -1 pour tous\n        for i in range(0, n):\n            c[i] = couleur_disponible(G, c, i)\n        return c\n</code></pre>"},{"location":"atelier/#b-coloration-optimale","title":"B. Coloration optimale","text":"<p>Remarquer sur des exemples que l'algorithme Glouton ne fournit pas n\u00e9cessairement une coloration optimale.</p> <p>Montrer qu'on peut en obtenir une en triant les intervalles.</p> <p>Activit\u00e9s compl\u00e9mentaires :</p> <ul> <li>Programmer le tri des intervalles</li> <li>D\u00e9montrer math\u00e9matiquement que le tri est optimal (difficile pour des lyc\u00e9ens ?)</li> </ul>"},{"location":"config/gdb/","title":"D\u00e9bugguer son programme C avec gdb","text":"<p>Rien de plus \u00e9nervant que de compiler un programme C, l'ex\u00e9cuter et se prendre la fameuse erreur : <pre><code>    segmentation fault (core dumped)\n</code></pre></p> <p>Dans ce mini-tuto, je vous explique comment utiliser le programme GNU Debugger (gdb) pour savoir exactement quelle ligne de votre code a provoqu\u00e9 le probl\u00e8me, et aussi avoir des informations suppl\u00e9mentaires pour enqu\u00eater sur votre bug.</p>"},{"location":"config/gdb/#1-installation-de-gdb","title":"1. Installation de gdb","text":"<p>Si jamais le programme gdb n'est pas install\u00e9 sur votre Linux, la simple commande d'installation classique vous sauvera :</p> Debian / UbuntuArch Linux <pre><code>   &gt;&gt;&gt; sudo apt install gdb \n</code></pre> <pre><code>   &gt;&gt;&gt; sudo pacman -S gdb \n</code></pre> <p>Warning</p> <p>Cette commande doit s'ex\u00e9cuter en mode administrateur d'o\u00f9 la pr\u00e9sence de sudo. Ca sera la seule commande ici \u00e0 utiliser avec sudo.</p>"},{"location":"config/gdb/#2-notre-programme-test","title":"2. Notre programme test","text":"<p>Dans le but de comprendre comment gdb fonctionne, on consid\u00e8re ce petit programme tr\u00e8s simple contenant un bug grossier et \u00e9vident :</p> somme.c<pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;stdlib.h&gt;\n\n    int somme(int tab[], int longueur) {\n        int s = 0;\n        for (int i = 0; i &lt; longueur; i++) {\n            s += tab[i];\n        }\n        return s;\n    }\n\n    void ajoute_un(int tab[], int longueur) {\n        for (int i = 0; i &lt;= longueur * 1000; i++) {\n            tab[i] += 1;\n        }\n    }\n\n    int main() {\n        int t[] = {1, 4, 5, 8, 10};\n        ajoute_un(t, 5);\n        printf(\"Somme = %d \\n\", somme(t, 5));\n        return 0;\n    }\n</code></pre> <p>Ce programme comporte deux fonctions :</p> <ul> <li><code>somme</code> : qui calcule la somme des valeurs dans un tableau</li> <li><code>ajoute_un</code> : qui ajoute un \u00e0 chacune des valeurs d'un tableau</li> </ul> <p>Evidemment la pr\u00e9sence du <code>longueur * 1000</code> dans <code>ajoute_un</code> provoque un d\u00e9passement de tableau et une erreur de segmentation...</p>"},{"location":"config/gdb/#3-compiler-avec-les-bonnes-options","title":"3. Compiler avec les bonnes options","text":"<p>Pour que gdb puisse vous donner les informations utiles, il faut d'abord demander au compilateur gcc de conserver un maximum d'informations utiles dans le programme compil\u00e9. On va donc lui passer deux options :</p> <ul> <li><code>-g</code> : pour qu'il ajoute des informations suppl\u00e9mentaires au programme compil\u00e9 comme par exemple les noms de fonctions ou de variables (dans un programme compil\u00e9 les fonctions sont rep\u00e9r\u00e9es par des adresses m\u00e9moires donc de simples num\u00e9ros, on aimerait avoir plus d'infos...).</li> <li><code>-O0</code> (lettre O et chiffre 0) : pour qu'il n'optimise rien du tout. Optimiser peut conduire \u00e0 r\u00e9organiser et modifier notre code pour qu'il soit plus efficace, c'est bien mais \u00e7a complique la tache quand on veut d\u00e9bugguer.</li> </ul> <p>Au final on tape : <pre><code>    gcc -g -O0 somme.c -o somme\n</code></pre></p> <p>Bien sur une fois qu'on a un programme qui marche : on enl\u00e8ve ces options pour avoir un programme compil\u00e9 plus performant.</p>"},{"location":"config/gdb/#4-executer-son-programme-avec-gdb","title":"4. Ex\u00e9cuter son programme avec gdb","text":"<p>Ensuite on ex\u00e9cute notre programme mais au travers de l'outil gdb, comme ceci : <pre><code>    gdb ./somme\n</code></pre></p> <p>gdb est un programme interactif qui attend que vous lui disiez quoi faire:  <pre><code>    Copyright (C) 2024 Free Software Foundation, Inc.\n    License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;\n    This is free software: you are free to change and redistribute it.\n    There is NO WARRANTY, to the extent permitted by law.\n    Type \"show copying\" and \"show warranty\" for details.\n    This GDB was configured as \"x86_64-pc-linux-gnu\".\n    Type \"show configuration\" for configuration details.\n    For bug reporting instructions, please see:\n    &lt;https://www.gnu.org/software/gdb/bugs/&gt;.\n    Find the GDB manual and other documentation resources online at:\n        &lt;http://www.gnu.org/software/gdb/documentation/&gt;.\n\n    For help, type \"help\".\n    Type \"apropos word\" to search for commands related to \"word\"...\n    Reading symbols from ./somme...\n    (gdb) \n</code></pre></p> <p>La premi\u00e8re chose qu'on va lui demander c'est d'ex\u00e9cuter le programme avec la commande <code>run</code> (puis touche entr\u00e9e) : <pre><code>    (gdb) run\n    Starting program: /home/vincent/cours/mpi/c/gdb/somme \n\n    [Thread debugging using libthread_db enabled]\n    Using host libthread_db library \"/usr/lib/libthread_db.so.1\".\n\n    Program received signal SIGSEGV, Segmentation fault.\n    0x00005555555551b6 in ajoute_un (tab=0x7fffffffe3e0, longueur=5) at somme.c:14\n    14          tab[i] += 1;\n    (gdb) \n</code></pre></p> <p>Et voil\u00e0 on a beaucoup plus d'information. On peut ainsi lire :</p> <ul> <li><code>Program received signal SIGSEGV, Segmentation fault.</code> qui signifie qu'une erreur de segmentation s'est produite</li> <li><code>0x00005555555551b6 in ajoute_un (tab=0x7fffffffe3e0, longueur=5) at somme.c:14</code> : nous indique que le probl\u00e8me est survenu dans la fonction <code>ajoute_un</code> avec comme param\u00e8tres un tableau donn\u00e9 par son adresse (illisible pour nous) et la valeur <code>longueur=5</code>. Plus pr\u00e9cis\u00e9ment, c'est arriv\u00e9 \u00e0 la ligne 14 du fichier <code>somme.c</code> : g\u00e9nial je sais maintenant o\u00f9 chercher.</li> <li><code>14           tab[i] += 1;</code> : gdb a m\u00eame eu la gentillesse de nous r\u00e9\u00e9crire la ligne de code concern\u00e9e.</li> </ul>"},{"location":"config/gdb/#mode-detective","title":"Mode d\u00e9tective !","text":"<p>Encore mieux, imagions que je ne comprenne toujours pas bien pourquoi cela a provoqu\u00e9 une erreur de segmentation, je peux demander \u00e0 gdb de m'afficher l'\u00e9tat actuel des variables au moment du bug avec la commande <code>print</code>, par exemple : <pre><code>    (gdb) print i\n    $1 = 776\n</code></pre></p> <p>Et voil\u00e0 il m'indique donc qu'au moment du bug la variable <code>i</code> vaut <code>776</code>, et puisque le tableau est de longueur 5 on comprend qu'on a \u00e9crit un bug de d\u00e9passement de tableau !</p> <p>Il n'y a plus qu'\u00e0 quitter gdb avec la commande <code>quit</code> et aller corriger son code : <pre><code>    (gdb) quit\n    A debugging session is active.\n\n        Inferior 1 [process 49338] will be killed.\n\n    Quit anyway? (y or n) y\n</code></pre></p>"},{"location":"config/manpages/","title":"Installer et utiliser les man pages","text":"<p>Les <code>man pages</code> (Manual pages) sont des pages de documentation accessibles depuis le terminal d'un syst\u00e8me Linux (ou Mac, BSD, ... priv\u00e9 de Windows). On y trouve en particulier de la docimentation pour :</p> <ul> <li>Toutes les fonctions de la biblioth\u00e8que standard C (<code>stdlib</code>, <code>stdio</code>, <code>string</code>, etc).</li> <li>De la documentation sur les outils disponibles dans le terminal (<code>ls</code>, <code>pwd</code>, <code>cp</code>, etc).</li> </ul>"},{"location":"config/manpages/#1-installation-des-man-pages","title":"1. Installation des man pages","text":"<p>Il est probable que les pages de manuels soient install\u00e9es par d\u00e9faut sur votre machine. Si ce n'est pas le cas il faut trouver et installer les bons paquets selon votre distribution Linux. Il existe aussi des paquets permettant une traduction en fran\u00e7ais  de certaines pages manuel. Par exemple sous Debian ou Ubuntu vous pouvez installer les paquets :</p> Debian / UbuntuArch Linux <pre><code>   &gt;&gt;&gt; sudo apt install man-db manpages manpages-dev manpages-fr manpages-fr-dev\n</code></pre> <pre><code>   &gt;&gt;&gt; sudo pacman -S man-db man-pages man-pages-fr\n</code></pre> <p>Warning</p> <p>Cette commande doit s'ex\u00e9cuter en mode administrateur d'o\u00f9 la pr\u00e9sence de sudo. Ca sera la seule commande ici \u00e0 utiliser avec sudo.</p>"},{"location":"config/manpages/#2-lecture-dune-page-de-manuel","title":"2. Lecture d'une page de manuel","text":"<p>Pour utiliser les man pages on invoque la commande <code>man</code> suivie du nom de la page \u00e0 consulter. Par exemple : <pre><code>    &gt;&gt;&gt; man strcmp\n</code></pre></p> <p>Ceci affiche dans le terminal la page de manuel concernant la fonction <code>strcmp</code> de C. Chez moi cela affiche : <pre><code>STRCMP(3)                                 Library Functions Manual                                STRCMP(3)\n\nNAME\n     strcmp, strncmp \u2013 compare strings\n\nLIBRARY\n     Standard C\u00a0Library (libc, -lc)\n\nSYNOPSIS\n     #include &lt;string.h&gt;\n\n     int\n     strcmp(const char *s1, const char *s2);\n\n     int\n     strncmp(const char *s1, const char *s2, size_t n);\n\nDESCRIPTION\n     The strcmp() and strncmp() functions lexicographically compare the null-terminated strings s1 and s2.\n\n     The strncmp() function compares not more than n characters.  Because strncmp() is designed for\n     comparing strings rather than binary data, characters that appear after a \u2018\\0\u2019 character are not\n     compared.\n\nRETURN VALUES\n     The strcmp() and strncmp() functions return an integer greater than, equal to, or less than 0,\n     according as the string s1 is greater than, equal to, or less than the string s2.  The comparison is\n     done using unsigned characters, so that \u2018\\200\u2019 is greater than \u2018\\0\u2019.\n\nSEE ALSO\n     bcmp(3), memcmp(3), strcasecmp(3), strcoll(3), strxfrm(3), wcscmp(3)\n\nSTANDARDS\n     The strcmp() and strncmp() functions conform to ISO/IEC 9899:1990 (\u201cISO\u00a0C90\u201d).\n</code></pre></p> <p>On y trouve de nombreuses informations utiles comme :</p> <ul> <li>La biblioth\u00e8que concern\u00e9e (ici <code>libc</code>)</li> <li>Le fichier d'en-t\u00eate \u00e0 include (<code>string.h</code>)</li> <li>Les prototypes des fonctions</li> <li>La description pr\u00e9cise des fonctions et des valeur de retour</li> <li>Des exemples classiques d'utilisation</li> <li>D'autres fonctions proches (dans <code>SEE ALSO</code>)</li> </ul>"},{"location":"config/manpages/#navigation","title":"Navigation","text":"<p>Pour afficher la page de manuel dans le terminal, l'outil <code>man</code> fait appel au pager <code>less</code> qui n'est pas tr\u00e8s intuitif la premi\u00e8re fois. Voici quelques commandes de base pour s'y retrouver :</p> <ul> <li><code>q</code> permet de quitter la page</li> <li>les touches fl\u00e9ch\u00e9es permettent de se d\u00e9pacer sur la page</li> <li>alternativement <code>j</code>/<code>k</code> permet de d\u00e9filer bas/haut (comme dans <code>vi</code>)</li> <li><code>g</code> va au d\u00e9but de la page</li> <li><code>G</code> va \u00e0 la fin de la page</li> <li><code>/mot</code> suivi de la touche entr\u00e9e permet de trouver localiser un mot dans la page (tr\u00e8s utile), on appuie enseuite sur <code>n</code> pour passer d'une occurrence \u00e0 la suivante</li> </ul>"},{"location":"config/manpages/#3-organisation-du-manuel","title":"3. Organisation du manuel","text":"<p>Le manuel est organis\u00e9 en diff\u00e9rentes sections portant toutes un num\u00e9ro. Les deux sections principalement utiles pour vous sont :</p> <ul> <li>Section 1 : commandes terminal</li> <li>Section 3 : fonctions des biblioth\u00e8ques C</li> </ul> <p>Sur toutes les pages manuel, le num\u00e9ro de section est pr\u00e9cis\u00e9 entre parenth\u00e8ses \u00e0 c\u00f4t\u00e9 du nom de la page, par exemple : <code>STRCMP(3)</code> dans l'exemple ci-dessus.</p> <p>Parfois, un m\u00eame nom de fonction peut \u00eatre utilis\u00e9 dans des contextes diff\u00e9rents, par exemple <code>man printf</code> emm\u00e8ne sur la page <code>PRINTF(1)</code> qui correspond \u00e0 la documentation de la commande <code>printf</code> du terminal (et pas du tout celle de la fonction <code>C</code>. Dans ce cas il faut pr\u00e9ciser \u00e0 <code>man</code> la section de manuel voulue :</p> <pre><code>    &gt;&gt;&gt; man 3 printf\n</code></pre>"},{"location":"config/manpages/#recherche-dune-page","title":"Recherche d'une page","text":"<p>Si vous ne savez pas exactement le nom de la page qui vous int\u00e9resse, vous pouvez utiliser la commande <code>apropos</code> pour trouver les pages int\u00e9ressantes. Par exemple, si je cherche des informations sur les <code>mutex</code> en C je tape : <pre><code>    &gt;&gt;&gt; apropos mutex\n</code></pre> qui r\u00e9pond : <pre><code>Mutex(3o)                - Locks for mutual exclusion\nStdlib.Mutex(3o)         - no description\ngnutls_global_set_mutex(3) - API function\nplockstat(1)             - front-end to DTrace to print statistics about POSIX mutexes and read/write locks\nAPR::ThreadMutex(3pm)    - Perl API for APR thread mutexes\nTcl_ConditionNotify(3tcl), Tcl_ConditionWait(3tcl), Tcl_ConditionFinalize(3tcl), Tcl_GetThreadData(3tcl), Tcl_MutexLock(3tcl), Tcl_MutexUnlock(3tcl), Tcl_MutexFinalize(3tcl), Tcl_CreateThread(3tcl), Tcl_JoinThread(3tcl) - Tcl thread support\nplockstat(1)             - front-end to DTrace to print statistics about POSIX mutexes and read/write locks\npthread_mutex_destroy(3) - free resources allocated for a mutex\npthread_mutex_init(3)    - create a mutex\npthread_mutex_lock(3)    - lock a mutex\npthread_mutex_trylock(3) - attempt to lock a mutex without blocking\npthread_mutex_unlock(3)  - unlock a mutex\npthread_mutexattr_init(3), pthread_mutexattr_destroy(3), pthread_mutexattr_setprioceiling(3), pthread_mutexattr_getprioceiling(3), pthread_mutexattr_setprotocol(3), pthread_mutexattr_getprotocol(3), pthread_mutexattr_settype(3), pthread_mutexattr_gettype(3) - mutex attribute operations\n</code></pre></p> <p>On retrouve alors dans la liste, en section 3, toutes les pages concernant les fonctions de mutex utilis\u00e9es dans le programme de MPI.</p>"},{"location":"config/opam/","title":"Installer et configurer <code>opam</code>","text":"<p><code>Opam</code> (OCaml package manager) est un gestionnaire de paquets pour OCaml. Il permet automatiquement de t\u00e9l\u00e9charger, compiler et installer un environnement de d\u00e9veloppement (interpr\u00e8tes, compilateurs, outils, biblioth\u00e8ques...) pour OCaml.</p> <p>M\u00eame si la plupart des distributions Linux int\u00e8grent des paquets pour installer OCaml, je recommande fortement d'utiliser Opam pour installer OCaml (et compagnie) sur vos ordinateurs pour b\u00e9n\u00e9ficier des avantages suivants :</p> <ul> <li>Installation ais\u00e9e des outils ('dune', 'menhir', etc)</li> <li>Installation ais\u00e9e des biblioth\u00e8ques OCaml</li> <li>Installation du serveur LSP pour OCaml (Aides pour la programmation dans VSCode)</li> <li>Tous les outils sont compil\u00e9s sur votre machine \u00e0 partir du code source OCaml (ce qui est cool)</li> </ul>"},{"location":"config/opam/#1-installation-de-opam","title":"1. Installation de Opam","text":"<p>Premi\u00e8rement Opam doit \u00eatre install\u00e9 sur votre ordinateur. En g\u00e9n\u00e9ral, les distributions Linux proposent Opam dans leurs paquets, par exemple sous Debian ou Ubuntu vous pouvez l'installer avec :</p> Debian / UbuntuArch Linux <pre><code>   &gt;&gt;&gt; sudo apt install opam\n</code></pre> <pre><code>   &gt;&gt;&gt; sudo pacman -S opam\n</code></pre> <p>Warning</p> <p>Cette commande doit s'ex\u00e9cuter en mode administrateur d'o\u00f9 la pr\u00e9sence de sudo. Ca sera la seule commande \u00e0 utiliser avec sudo.</p>"},{"location":"config/opam/#2-initialisation-de-opam","title":"2. Initialisation de Opam","text":"<p>Opam installe ses \u00e9l\u00e9ments dans un r\u00e9pertoire cach\u00e9 <code>.opam</code> de votre r\u00e9pertoire utilisateur : cela permet \u00e0 chaque utilisateur d'avoir sa configuration propre, cela permet aussi d'installer tous les outils et biblioth\u00e8ques utiles sans polluer son syst\u00e8me et sans avoir besoin de disposer des droits administrateurs. Ex\u00e9cutez simplement :</p> <pre><code>    &gt;&gt;&gt; opam init\n</code></pre> <p>Cette commande t\u00e9l\u00e9charge et copile automatiquement une suite basique d'outils pour commencer \u00e0 faire du OCaml. Au cours de cette proc\u00e9dure <code>opam</code> vous posera la question suivante : <pre><code>  In normal operation, opam only alters files within ~/.opam.\n\n  However, to best integrate with your system, some environment variables\n  should be set. If you allow it to, this initialisation step will update\n  your zsh configuration by adding the following line to ~/.zshrc:\n\n    [[ ! -r '/Users/vincent/.opam/opam-init/init.zsh' ]] || source '/Users/vincent/.opam/opam-init/init.zsh' &gt; /dev/null 2&gt; /dev/null\n\n  Otherwise, every time you want to access your opam installation, you will\n  need to run:\n\n    eval $(opam env)\n\n  You can always re-run this setup with 'opam init' later.\n\nDo you want opam to configure zsh?\n&gt; 1. Yes, update ~/.zshrc\n  2. Yes, but don't setup any hooks. You'll have to run eval $(opam env)\n     whenever you change your current 'opam switch'\n  3. Select a different shell\n  4. Specify another config file to update instead\n  5. No, I'll remember to run eval $(opam env) when I need opam\n</code></pre></p> <p>Ce message peut varier selon le programme shell que vous utilisez. Opam explique simplement qu'il faut configurer le shell pour qu'il puisse trouver les outils OCaml install\u00e9s dans votre r\u00e9pertoire <code>.opam</code>. Cette configuration d\u00e9pend du shell utilis\u00e9. Personnellement j'utilise le shell <code>zsh</code> donc opam me propose de modifier le fichier de configuration de ce shell <code>.zshrc</code>. R\u00e9pondez simplement <code>1</code> \u00e0 la question pour laiser opam configurer votre shell.</p> <p>Ensuite laissez opam travailler, cela peut prendre du temps : <pre><code>    &lt;&gt;&lt;&gt; Processing actions &lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;  \ud83d\udc2b\n\u2217 installed base-bigarray.base\n\u2217 installed base-threads.base\n\u2217 installed base-unix.base\n\u2217 installed ocaml-options-vanilla.1\n\u2b07 retrieved ocaml-config.3  (2 extra sources)\n\u2b07 retrieved ocaml-config.3  (2 extra sources)\n\u2b07 retrieved ocaml-compiler.5.3.0  (https://opam.ocaml.org/cache)\nProcessing 20/33: [ocaml-compiler: make]\n</code></pre> (opam est en train de t\u00e9l\u00e9charger les composants, et actuellement il est train de compiler mon compilateur ocaml)</p> <p>Une fois l'installation termin\u00e9e, red\u00e9marrez l'ordinateur (ou au moins relogguez vous) et v\u00e9rifiez que tout s'est bien install\u00e9 :</p> <pre><code>   &gt;&gt;&gt; opam switch\n#  switch   compiler                                           description\n\u2192  default  ocaml-base-compiler.5.3.0,ocaml-options-vanilla.1  ocaml &gt;= 4.05.0\n</code></pre> <p>Opam m'indique qu'il a install\u00e9 une version par d\u00e9faut, qui correspond \u00e0 OCaml version 5.3.</p> <p>On peut aussi v\u00e9rifier que l'ex\u00e9cutable est bien disponible au bon endroit : <pre><code>    &gt;&gt;&gt; whereis ocaml\nocaml: /Users/vincent/.opam/default/bin/ocaml /Users/vincent/.opam/default/man/man1/ocaml.1\n</code></pre></p>"},{"location":"config/opam/#3-mise-a-jour-dune-configuration-opam","title":"3. Mise \u00e0 jour d'une configuration Opam","text":"<p>De temps en temps, vous pouvez taper les deux commandes suivantes pour mettre \u00e0 jour votre opam et l'installation actuelle.</p> <ul> <li>Mettre \u00e0 jour la liste des composants disponibles : <pre><code>    &gt;&gt;&gt; opam update\n</code></pre></li> <li>Effectuer les mises \u00e0 jour disponibles : <pre><code>    &gt;&gt;&gt; opam upgrade\n</code></pre></li> </ul>"},{"location":"config/opam/#4-installation-de-nouveaux-composants","title":"4. Installation de nouveaux composants","text":"<p>Par d\u00e9faut opam installe uniquement un ensemble minimal de paquets de base pour faire du ocaml. Vous pouvez lister les paquets install\u00e9s ainsi :</p> <pre><code>    &gt;&gt;&gt; opam list\n# Packages matching: installed\n# Name                # Installed # Synopsis\nbase-bigarray         base\nbase-domains          base\nbase-effects          base\nbase-nnp              base        Naked pointers prohibited in the OCaml heap\nbase-threads          base\nbase-unix             base\nocaml                 5.3.0       The OCaml compiler (virtual package)\nocaml-base-compiler   5.3.0       Official release of OCaml 5.3.0\nocaml-compiler        5.3.0       Official release of OCaml 5.3.0\nocaml-config          3           OCaml Switch Configuration\nocaml-options-vanilla 1           Ensure that OCaml is compiled with no special\n</code></pre> <p>Pour installer de nouveaux composants on utilise la commande : <pre><code>    &gt;&gt;&gt; opam install (liste de composants)\n</code></pre></p>"},{"location":"config/opam/#paquets-recommandes","title":"Paquets recommand\u00e9s","text":"<p>Je vous recommande d'installer les composants suivants : <pre><code>    &gt;&gt;&gt; opam install utop ocaml-lsp-server dune menhir\n</code></pre></p> <ul> <li>utop : est un interpr\u00e8te OCaml un peu plus confortable d'utilisation que l'interpr\u00e8te de base <code>ocaml</code></li> <li>ocaml-lsp-server : permet \u00e0 des \u00e9diteurs tels que VSCode de comprendre le langage OCaml et de vous proposer des fonctionnalit\u00e9s avanc\u00e9es (par exemple afficher les types)</li> <li>dune : un syst\u00e8me pour compiler facilement les projets OCaml (compilation s\u00e9par\u00e9e)</li> <li>menhir : un analyseur syntaxique permettant d'\u00e9crire facilement des parseurs</li> </ul> <p>A l'ex\u00e9cution de la commande <code>opam install</code> opam d\u00e9terminera toutes les d\u00e9pendances de paquets n\u00e9cessaires et vous proposera de tout installer. Il faut r\u00e9pondre oui (<code>y</code>).</p>"},{"location":"config/opam/#recherche-de-bibliotheques","title":"Recherche de biblioth\u00e8ques","text":"<p>Si vous \u00eates \u00e0 la recherche d'une biblioth\u00e8que OCaml sp\u00e9cifique, vous pouvez utiliser la commande <code>opam search</code> pour d\u00e9terminer quel paquet installer. Par exemple, si je souhaite disposer d'une biblioth\u00e8que permettant de travailler avec des expressions reguli\u00e8res, je peux taper : <pre><code>    &gt;&gt;&gt; opam search regular expression\n# Packages matching: match(*regular*) &amp; match(*expression*)\n# Name         # Installed # Synopsis\nexpect         --          Simple implementation of 'expect' to help building unitary testing of interactive\ngrenier        --          A collection of various algorithms in OCaml\nhumane-re      --          A human friendly interface to regular expressions in OCaml\niri            --          IRI (RFC3987) native OCaml implementation\nmparser-pcre   --          MParser plugin: PCRE-based regular expressions\nmparser-re     --          MParser plugin: RE-based regular expressions\nocamlregextkit --          A regular expression toolkit for OCaml\noniguruma      --          Bindings to the Oniguruma regular expression library\npcre           --          Bindings to the Perl Compatibility Regular Expressions library\npcre2          --          Bindings to the Perl Compatibility Regular Expressions library (version 2)\nppx_regexp     --          Matching Regular Expressions with OCaml Patterns\nppx_tyre       --          PPX syntax for tyre regular expressions and routes\nre             1.13.2      RE is a regular expression library for OCaml\nre2            --          OCaml bindings for RE2, Google's regular expression library\nre_parser      --          Typed parsing using regular expressions.\nregenerate     --          Regenerate is a tool to generate test-cases for regular expression engines\ntext           --          Library for dealing with \"text\", i.e. sequence of unicode characters, in a conveni\ntyre           --          Typed Regular Expressions\nzed            3.2.3       Abstract engine for text edition in OCaml\n</code></pre> Opam r\u00e9pond par une proposition de paquets correspodant \u00e0 la recherche. On voit ici que <code>re</code> semble \u00eatre la biblioth\u00e8que adapt\u00e9e et qu'elle est d\u00e9j\u00e0 install\u00e9e (en version 1.13.2) : il n'y a donc rien \u00e0 faire. Sinon il faut installer le paquet voulu avec <code>opam install</code>.</p>"},{"location":"config/opam/#5-desinstallation","title":"5. D\u00e9sinstallation","text":"<p>Si vous voulez d\u00e9sinstaller OCaml et repartir de z\u00e9ro, supprimez simplement votre r\u00e9pertoire '.opam' :</p> <pre><code>    &gt;&gt;&gt; rm -rf ~/.opam\n</code></pre>"},{"location":"general/induction/","title":"R\u00e9currence et induction","text":""},{"location":"general/induction/#1-ensembles-definis-par-induction","title":"1. Ensembles d\u00e9finis par induction","text":"<p>Soit \\(E\\) un ensemble.</p> <p>D\u00e9finition</p> <p>On peut d\u00e9finir une partie \\(X\\) de \\(E\\) par induction en se donnant</p> <ul> <li>un ensemble \\(X_0 \\subset E\\) d'\u00e9lements de base appel\u00e9s axiomes;</li> <li>un ensemble de r\u00e8gles d'inf\u00e9rence : une r\u00e8gle \\(R\\) est une fonction de construction qui prend en entr\u00e9e un nombre \\(n_R\\) d'\u00e9lements de \\(E\\) d\u00e9j\u00e0 construits et en construit un nouveau. La valeur \\(n_R\\) s'appelle arit\u00e9 de la r\u00e8gle d'inf\u00e9rence.</li> </ul> <p>La partie \\(X\\) est alors la plus petite partie de \\(E\\) qui contient \\(X_0\\) et qui est stable par l'application des r\u00e8gles d'inf\u00e9rence (tout \u00e9l\u00e9ment construit \u00e0 partir d'\u00e9l\u00e9ments de \\(X\\) est dans \\(X\\)).</p> <p>Exemples</p> <ul> <li>Les entiers naturels impairs \\(\\mathcal{I}\\) peuvent \u00eatre d\u00e9finis par induction par : \\(E = \\mathbb{R}\\), \\(X_0 = \\{1\\}\\) et la r\u00e8gle \\(n \\mapsto n + 2\\).</li> <li>Les arbres binaires stricts sont d\u00e9finis par \\(X_0 = \\{ \\text{Feuille} \\}\\) et la r\u00e8gle d'inf\u00e9rence d'arit\u00e9 2 : \\((g, d) \\mapsto \\text{Noeud}(g, d)\\) qui cr\u00e9\u00e9 un noeud \u00e0 partir de deux sous-arbres qui seront ses fils. </li> <li>Les formules propositionnelles : les cas de bases sont les variables propositionnelles et les formules \\(\\bot\\) et \\(\\top\\). Il y a une r\u00e8gle d'arit\u00e9 \\(1\\) : \\(F \\mapsto \\neg F\\) et 4 r\u00e8gles d'arit\u00e9 2 : \\((F, G) \\mapsto (F \\land G)\\) ,\\((F, G) \\mapsto (F \\lor G)\\), \\((F, G) \\mapsto (F \\rightarrow G)\\), \\((F, G) \\mapsto (F \\leftrightarrow G)\\).</li> </ul> <p>En informatique, tr\u00e8s souvent on ne pr\u00e9cise pas l'ensemble \\(E\\) qui est implicite. Dans l'exemple des arbres binaires \\(E\\) pourrait \u00eatre par exemple l'ensemble des cha\u00eenes de caract\u00e8res, mais on ne le pr\u00e9cise pas.</p>"},{"location":"general/induction/#definition-constructive","title":"D\u00e9finition constructive","text":"<p>Lorsqu'un ensemble \\(X\\) est d\u00e9fini par induction, on peut aussi voir sa construction \u00e0 l'aide de la suite d'ensembles \\((X_i)_{i \\in \\mathbb N}\\) d\u00e9finie par par :</p> \\[ X_{i+1} = X_i \\cup \\{ \\text{nouveaux \u00e9l\u00e9ments que l'on peut construire en appliquant 1 r\u00e8gle d'inf\u00e9rence sur des \u00e9l\u00e9ments de $X_i$}\u00a0\\} \\] <p>Proposition</p> <p>La partie \\(X\\) d\u00e9finie par induction v\u00e9rifie alors :</p> \\[ X = \\bigcup_{i \\in \\mathbb N} X_i \\] <p>La preuve de cette proposition peut s'obtenir par double inclusion. D'une part, on peut montrer par r\u00e9currence simple que chaque \\(X_i \\subset X\\), ce qui montre une inclusion. D'autre part on v\u00e9rifie que \\(\\bigcup_{i \\in \\mathbb N} X_i\\) contient \\(X_0\\) et est stable par l'application des r\u00e8gles d'inf\u00e9rence, donc par d\u00e9finition de \\(X\\) qui est la plus petite partie v\u00e9rifiant cela, on obtient l'autre inclusion.</p>"},{"location":"general/induction/#2-preuves-par-recurrence","title":"2. Preuves par r\u00e9currence","text":"<p>Nous faisons ici quelques rappels sur le principe de d\u00e9monstration par r\u00e9currence, tr\u00e8s utilis\u00e9 en informatique.</p> <p>Une preuve par r\u00e9currence consiste \u00e0 d\u00e9montrer une propri\u00e9t\u00e9 pour tout entier \\(n\\) une propori\u00e9t\u00e9 \\(P(n)\\). La propri\u00e9t\u00e9 \\(P\\) d\u00e9pend donc d'un entier.</p>"},{"location":"general/induction/#a-recurrence-simple","title":"A. R\u00e9currence simple","text":"<p>Preuve par r\u00e9currence simple</p> <p>S'il existe un entier \\(n_0 \\in \\mathbb{N}\\) tel que :</p> <ul> <li>Initialisation: \\(P(n_0)\\) est vraie</li> <li>H\u00e9r\u00e9dit\u00e9:  Pour tout entier \\(n \\geq n_0\\) : \\(P(n) \\Rightarrow P(n+1)\\)</li> </ul> <p>alors par r\u00e9currence simple \\(P(n)\\) est vraie pour tout \\(n \\geq n_0\\).</p> <p>Point m\u00e9thode</p> <p>Pour r\u00e9diger une r\u00e9currence on \u00e9crira syst\u00e9matiquement la propri\u00e9t\u00e9 \u00e0 d\u00e9montrer:</p> \\[ P(n) : \\text{\"} \\dots \\text{\"} \\] <p>puis on prouve l'initialisation et l'h\u00e9r\u00e9dit\u00e9. Enfin on conclut.</p> <p>Exercice</p> <p>D\u00e9montrer que pour tout graphe non orient\u00e9 \\(G = (S, A)\\), la somme des degr\u00e9s de tous les sommets vaut \\(2m\\) o\u00f9 \\(m = |A|\\).</p> <p>Attention</p> <p>Une erreur de raisonnement fr\u00e9quente dans ce genre d'exercice est de montrer l'h\u00e9r\u00e9dit\u00e9 en partant d'un graphe \u00e0 \\(m\\) ar\u00eates et en lui ajoutant une ar\u00eate... C'est bien dans l'autre sens qu'il faut proc\u00e9der : on veut montrer \\(P(m + 1)\\) \u00e0 partir de \\(P(m)\\) donc il faut prendre un graphe quelconque \u00e0 \\(m + 1\\) ar\u00eates et lui enlever une ar\u00eate pour utiliser l'hypoth\u00e8se de r\u00e9currence.</p>"},{"location":"general/induction/#b-recurrence-double","title":"B. R\u00e9currence double","text":"<p>Preuve par r\u00e9currence double</p> <p>S'il existe un entier \\(n_0 \\in \\mathbb{N}\\) tel que :</p> <ul> <li>Initialisation: \\(P(n_0)\\) et \\(P(n_0 + 1)\\) sont vraies</li> <li>H\u00e9r\u00e9dit\u00e9:  Pour tout entier \\(n \\geq n_0\\) : \\((P(n) \\land P(n+1)) \\Rightarrow P(n+2)\\)</li> </ul> <p>alors par r\u00e9currence double \\(P(n)\\) est vraie pour tout \\(n \\geq n_0\\).</p> <p>Point m\u00e9thode</p> <p>Pour r\u00e9diger une r\u00e9currence double on \u00e9crira syst\u00e9matiquement la propri\u00e9t\u00e9 \u00e0 d\u00e9montrer</p> \\[ P(n) : \\text{\"} \\dots \\text{\"} \\] <p>puis on pr\u00e9cisera tr\u00e8s clairement que l'on proc\u00e8de par r\u00e9currence double. On montre les deux points de l'initialisation et l'h\u00e9r\u00e9dit\u00e9. Enfin on conclut.</p> <p>Exercice</p> <p>On construit la suite \\((A_n)_{n \\in \\mathbb{N}}\\) d'arbres binaires stricts suivante :</p> <ul> <li>\\(A_0 = \\text{Feuille}\\)</li> <li>\\(A_1 = \\text{Noeud}(\\text{Feuille}, \\text{Feuille})\\)</li> <li>\\(\\forall n \\geq 2, A_n = \\text{Noeud}(A_{n-1}, A_{n-2})\\)</li> </ul> <p>D\u00e9montrer que le nombre de noeuds+feuilles de \\(A_n\\) vaut \\(3 F_n + L_n - 1\\) o\u00f9 :</p> <ul> <li>\\((F_n)_{n \\in \\mathbb{N}}\\) sont les nombres de Fibonnacci : \\(F_0 = 0, \\quad F_1 = 1, \\quad F_{n+2} = F_{n+1} + F_n\\)</li> <li>\\((L_n)_{n \\in \\mathbb{N}}\\) sont les nombres de Lucas : \\(L_0 = 2, \\quad L_1 = 1, \\quad L_{n+2} = L_{n+1} + L_n\\)</li> </ul>"},{"location":"general/induction/#c-recurrence-forte","title":"C. R\u00e9currence forte","text":"<p>Preuve par r\u00e9currence forte</p> <p>S'il existe un entier \\(n_0 \\in \\mathbb{N}\\) tel que :</p> <ul> <li>Initialisation: \\(P(n_0)\\) est vraie</li> <li>H\u00e9r\u00e9dit\u00e9:  Pour tout entier \\(n \\geq n_0\\) : \\(\\left(\\forall k \\in [| n_0, n|], \\,  P(k)\\right) \\Rightarrow P(n+1)\\)</li> </ul> <p>alors par r\u00e9currence forte \\(P(n)\\) est vraie pour tout \\(n \\geq n_0\\).</p> <p>Point m\u00e9thode</p> <p>Pour r\u00e9diger une r\u00e9currence forte on \u00e9crira syst\u00e9matiquement la propri\u00e9t\u00e9 \u00e0 d\u00e9montrer</p> \\[ P(n) : \\text{\"} \\dots \\text{\"} \\] <p>puis on pr\u00e9cisera tr\u00e8s clairement que l'on proc\u00e8de par r\u00e9currence forte. On montre l'initialisation et l'h\u00e9r\u00e9dit\u00e9. Enfin on conclut.</p> <p>Exercice</p> <p>D\u00e9montrer par r\u00e9currence forte que tout arbre binaire \u00e0 \\(n\\) noeuds internes poss\u00e8de \\(n + 1\\) feuilles (noeuds externes).</p>"},{"location":"general/induction/#3-preuves-par-induction","title":"3. Preuves par induction","text":"<p>On dit aussi parfois preuve par induction structurelle.</p> <p>Le sch\u00e9ma de preuve par induction ressemble \u00e0 une r\u00e9currence, la diff\u00e9rence est que la propri\u00e9t\u00e9 \\(P(x)\\) d\u00e9pend cette fois d'un \u00e9lement \\(x \\in X\\) d'une ensemble \\(X\\) d\u00e9fini par induction. Le but d'une telle preuve est de d\u00e9montrer que la propri\u00e9t\u00e9 est vraie pour tous les \u00e9lements \\(x \\in X\\).</p> <p>Preuve par induction</p> <ul> <li>Initialisation: La propri\u00e9t\u00e9 est vraie pour tous les \u00e9l\u00e9ments de base (axiomes) : \\(\\forall x \\in X_0, \\, P(x)\\) est vraie</li> <li>H\u00e9r\u00e9dit\u00e9:  Pour chaque r\u00e8gle d'inf\u00e9rence \\(R\\) d'arit\u00e9 \\(n_R\\), et pour tous \u00e9l\u00e9ments \\(x_1, \\dots, x_{n_R} \\in X\\), on a  : </li> </ul> \\[ \\left(P(x_1) \\land P(x_2) \\land \\dots \\land P(x_{n_R}) \\right) \\Rightarrow P\\left(R(x_1, \\dots, x_{n_R})\\right) \\] <p>alors par induction structurelle \\(P(x)\\) est vraie pour tout \\(x \\in X\\).</p> <p>La formulation g\u00e9n\u00e9rale de ce princpe de preuve peut para\u00eetre intimidante, mais savoir l'appliquer en pratique est essentiel.</p> <p>Exercice</p> <p>D\u00e9montrer par induction structurelle que tout arbre binaire \u00e0 \\(n\\) noeuds internes poss\u00e8de \\(n + 1\\) feuilles (noeuds externes).</p> <p>Exercice</p> <p>Un arbre binaire de recherche est soit une \\({\\tt Feuille(n)}\\) \u00e9tiquet\u00e9e par un entier \\(n\\), soit construit \u00e0 partir de deux arbres binaires de recherche \\(g\\) et \\(d\\) par la r\u00e8gle \\({\\tt Noeud(x, g, d)}\\) qui n'est valide que lorsque \\(\\forall y \\in \\text{Etiquettes}(g), \\, y \\leq x\\) et \\(\\forall y \\in \\text{Etiquettes}(d), \\, x &lt; y\\).</p> <p>D\u00e9montrer que la liste des \u00e9tiquettes d'un arbre binaire de recherche, \u00e9num\u00e9r\u00e9es dans l'ordre du parcours en profondeur infixe est une liste tri\u00e9e par ordre croissant.</p> <p>Point m\u00e9thode</p> <p>Pour r\u00e9diger une preuve par induction on \u00e9crira syst\u00e9matiquement la propri\u00e9t\u00e9 \u00e0 d\u00e9montrer</p> \\[ P(x) : \\text{\"} \\dots \\text{\"} \\] <p>d\u00e9pendant d'\u00e9l\u00e9ments \\(x\\) d'un ensemble construit par induction (arbres, formules logiques, etc). On pr\u00e9cisera tr\u00e8s clairement que l'on proc\u00e8de par induction structurelle. On montre l'initialisation et l'h\u00e9r\u00e9dit\u00e9. Enfin on conclut.</p>"},{"location":"general/induction/#exercices","title":"Exercices","text":"<p>Un exemple tr\u00e8s facile</p> <p>En utilisant la construction inductive des entiers impairs \\(\\mathcal{I}\\) d\u00e9montrer que tout entier impair est sup\u00e9rieur ou \u00e9gal \u00e0 1.</p> <p>Hauteur minimale</p> <p>D\u00e9montrer qu'un arbre binaire poss\u00e9dant \\(2^n\\) noeuds ou plus a une hauteur au moins \u00e9gale \u00e0 \\(n\\).</p> <p>Arbres 2-3</p> <p>Un arbre 2-3 de hauteur 0 est une feuille. Un arbre 2-3 de hauteur \\(h &gt; 0\\) poss\u00e8de une racine ayant 2 ou 3 fils qui sont tous des arbres 2-3 de hauteur \\(h - 1\\). </p> <ol> <li>D\u00e9montrer que le nombre de feuilles \\(n\\) d'un arbre 2-3 v\u00e9rifie \\(2^h \\leq n \\leq 3^h\\).</li> <li>Pour quelles familles d'arbres ces bornes sont-elles atteintes ?</li> </ol> <p>Crayons de couleur</p> <p>Montrons par r\u00e9currence simple que dans toute bo\u00eete de \\(n \\in \\mathbb{N}^*\\) crayons de couleurs, tous les crayons sont de la m\u00eame couleur.</p> <ul> <li>Initialisation :Le r\u00e9sultat est vrai pour une bo\u00eete ne contenant qu'un seul crayon</li> <li>H\u00e9r\u00e9dit\u00e9 : Consid\u00e9rons une bo\u00eete \\(\\{c_1, \\dots, c_{n+1}\\}\\) contenant \\(n+1\\) crayons de couleurs et enlevons lui le premier crayon. Par hypoth\u00e8se de r\u00e9currence les \\(n\\) crayons restants \\(c_2, \\dots, c_{n+1}\\) sont de la m\u00eame couleur. Si on enl\u00e8ve maintenant le dernier crayon de la bo\u00eete initiale, on en d\u00e9duit encore par hypoth\u00e8se de r\u00e9currence que les \\(n\\) crayons restants \\(c_1, \\dots, c_n\\), sont de la m\u00eame couleur. Conclusion : tous les \\(n+1\\) crayons sont de la m\u00eame couleur.</li> </ul> <p>Par r\u00e9currence on a d\u00e9montr\u00e9 que tous les crayons d'une bo\u00eete quelconque de \\(n\\) crayons de couleurs sont de la m\u00eame couleur.</p> <p>Ce r\u00e9sultat est \u00e9videmment absurde : trouver l'erreur de raisonnement qui a \u00e9t\u00e9 faite.</p> <p>Listes infinies (Mines 2024)</p> <p>On d\u00e9finit par induction l'ensemble \\(\\mathcal{L}\\) des listes d'\u00e9l\u00e9ments de \\(E\\) ainsi :</p> <ul> <li>une liste est soit la liste vide not\u00e9e <code>[]</code></li> <li>soit construite \u00e0 partir d'un \u00e9lement \\(t \\in E\\) et d'une liste \\(q\\), on la note alors \\(t::q\\)</li> </ul> <p>Questions</p> <ol> <li>D\u00e9finir un type en langage OCaml pour repr\u00e9senter ces listes.</li> <li>D\u00e9finir un type en langage C pour repr\u00e9senter ces listes (sur les entiers).</li> <li>On d\u00e9finit intuitivement l'ensemble \\(\\mathcal{L}_{\\infty}\\) des listes finies ou infinies de valeurs. Est-ce que \\(\\mathcal{L}_\\infty\\) est stable par la r\u00e8gle d'induction. A-t-on \\(\\mathcal{L} = \\mathcal{L}_\\infty\\) ?</li> <li>D\u00e9montrer que toute liste de \\(\\mathcal{L}\\) poss\u00e8de un nombre fini d'\u00e9l\u00e9ments.</li> <li>Le type propos\u00e9 en langage C permet-il de construire une liste infinie ?</li> </ol> <p>Arbres ET/OU</p> <p>Un arbre binaire ET/OU est un arbre binaire dans lequel : </p> <ul> <li>une feuille est soit la variable \\(x\\), soit une constante \\(0\\) repr\u00e9sentant le faux, soit une constante \\(1\\) repr\u00e9sentant le vrai. </li> <li>il existe deux types de noeuds, les noeuds \\(\\land\\) repr\u00e9santant la conjonction logique et les noeuds \\(\\lor\\) repr\u00e9sentant la disjonction logique. </li> </ul> <p>\u00c0 tout arbre binaire ET/OU \\(A\\) on associe une fonction \\(f_A : \\{0, 1\\} \\to \\{0, 1\\}\\) o\u00f9 \\(f_A(t)\\) vaut le r\u00e9sultat de l'\u00e9valuation de l'arbre \\(A\\) en repla\u00e7ant les feuilles \\(x\\) par la valeur \\(t\\).</p> <p>D\u00e9montrer qu'il est impossible de produire la fonction bool\u00e9enne de n\u00e9gation : \\(f : x \\mapsto 1 - x\\) \u00e0 l'aide d'un tel arbre.</p> <p>\\(\\star\\) Compacit\u00e9 de la logique propositionnelle \\(\\star\\)</p> <p>On consid\u00e8re un ensemble d\u00e9nombrable de variables propositionnelles \\(\\mathbb{V} = \\{x_1, \\dots, x_n, \\dots \\}\\).</p> <p>Une th\u00e9orie \\(T\\) est un ensemble fini ou non de formules propositionnelles sur \\(\\mathbb{V}\\). </p> <p>Une th\u00e9orie est dite satisfiable s'il existe une valuation qui rend toutes ses formules vraies. Une th\u00e9orie est dite finiment satisfiable si toute sous-th\u00e9orie \\(T' \\subset T\\) finie est satisfiable.</p> <p>Questions</p> <ol> <li>Donner un exemple de th\u00e9orie \u00e0 3 formules satisfiable.</li> <li>Donner un exemple de th\u00e9orie \u00e0 3 formules non satisfiable</li> <li>Donner un exemple de th\u00e9orie infinie satisfiable.</li> <li>D\u00e9montrer que si une th\u00e9orie \\(T\\) est satisfiable alors toute sous-th\u00e9orie \\(T'\\) finie est satisfiable.</li> <li>D\u00e9montrer que si toute les sous-th\u00e9ories finies \\(T'\\) d'une th\u00e9orie \\(T\\) sont satisfiables alors \\(T\\) est satifiable. (Indication : construire par r\u00e9currence une valuation qui convient, on suppose que les valeurs de v\u00e9rit\u00e9 de \\(x_1, \\dots, x_n\\) sont fix\u00e9es correctement, montrer qu'il est possible de fixer la valeur de v\u00e9rit\u00e9 de \\(x_{n+1}\\) de telle mani\u00e8re \u00e0 ce que pour toute sous-th\u00e9orie finie \\(T'\\) il existe une valuation qui la satisfait et qui a pr\u00e9cis\u00e9ment pr\u00e9cis\u00e9ment ces valeurs choisies sur \\(x_1, \\dots, x_{n+1}\\))</li> </ol> <p>On obtient le th\u00e9or\u00e8me de compacit\u00e9 qui \u00e9nonce qu'une th\u00e9orie est satisfiable si et seulement si toutes ses sous-th\u00e9ories finies le sont. Une autre fa\u00e7on de le dire est qu'une th\u00e9orie n'est pas satisifiable si et seulement si elle admet une sous-th\u00e9orie finie qui ne l'est pas. Autrement dit la non satisfiabilit\u00e9 d'une th\u00e9orie infinie n'est jamais due \u00e0 son caract\u00e8re infini : elle provient d'un sous-ensemble fini de formules qui n'est pas satisfiable.</p>"},{"location":"graphes/couplages/","title":"Couplage maximal dans un graphe biparti","text":""},{"location":"graphes/couplages/#1-graphes-bipartis","title":"1. Graphes bipartis","text":"<p>Les graphes bipartis sont une classe de graphes utiles pour mod\u00e9liser des situations pratiques.</p> <p>Notation : Si \\(G = (S, A)\\) est un graphe orient\u00e9 ou non, on notera \\(xy \\in A\\) pour dire l'arc \\((x, y)\\) ou l'ar\u00eate \\(\\{x, y\\}\\) est dans \\(A\\).</p> <p>D\u00e9finition (graphe biparti)</p> <p>Un graphe \\(G = (S, A)\\) orient\u00e9 ou non est biparti s'il existe une partition de \\(S\\) en deux ensembles \\(S = U \\sqcup V\\) tels que :</p> \\[ \\forall xy \\in A, \\quad (x \\in U \\land y \\in V) \\lor (x \\in V \\land y \\in U)\\] <p>On rappelle que partition signifie :</p> <ul> <li>\\(S = U \\cup V\\) : \\(U\\) et \\(V\\) recouvrent tout l'ensemble \u00e0 partitionner</li> <li>\\(U \\cap V = \\varnothing\\) : les parties \\(U\\) et \\(V\\) sont disjointes</li> </ul> <p>On peut remarquer que lorsque un graphe est biparti, il peut admettre plusieurs bipartitions valides. Dans les cas pratiques, la bipartition consid\u00e9r\u00e9e est souvent impos\u00e9e par la mod\u00e9lisation du probl\u00e8me. Dans ce cas, on d\u00e9crit un graphe biparti en donnant la bipartition \u00e0 consid\u00e9rer, on pourra par exemple \u00e9crire : soit \\(G = (U \\sqcup V, A)\\) un graphe biparti.</p> <p>Exemple : un graphe biparti</p> <p> </p> <p>Exemple : Vocabulaire et textes</p> <p>On peut consid\u00e9rer le graphe non orient\u00e9 biparti \\(G = (U \\sqcup V, A)\\) dans lequel \\(U\\) est un ensemble fini de mots (un vocabulaire) et \\(V\\) un ensemble de textes. On construit alors une ar\u00eate \\(mt \\in A\\) lorsque le mot \\(m\\) appara\u00eet dans le texte \\(t\\).</p> <p>Exemples en biologie, en \u00e9cologie et en m\u00e9decine</p> <p>L'image suivante montre plusieurs exemples de mod\u00e9lisations \u00e0 l'aide de graphes bipartis, en biologie, en \u00e9cologie et en m\u00e9decine.  Extrait de \"Bipartite graphs in systems biology and medicine: a survey of methods and applications\", Gigascience, Pavlopoulos et al., 2018 </p> <p>Parfois, un probl\u00e8me traite de graphe biparti sans le dire. Il existe en effet d'autres mani\u00e8res de parler de graphes bipartis sans les nommer. C'est ce que montre la proposition suivante.</p> <p>Proposition</p> <p>Soit \\(G = (S, A)\\) un graphe non orient\u00e9, on a \u00e9quivalence entre :</p> <ol> <li>\\(G\\) est biparti</li> <li>\\(G\\) est 2-colorable</li> <li>\\(G\\) n'admet aucun cycle de longueur impaire</li> </ol> D\u00e9monstration <ul> <li>(1) implique (2) : il suffit de colorer tous les sommets de \\(U\\) en bleu et tous les sommets de \\(V\\) en rouge</li> <li>(2) implique (3) : si on consid\u00e8re par l'absurde un cycle de longueur impaire \\((x_1, \\dots, x_{n-1}, x_n = x_1)\\) de \\(G\\) qui est 2-color\u00e9, alors par imparit\u00e9, la couleur de \\(x_1\\) est \u00e9gale \u00e0 celle de \\(x_{n-1}\\) ce qui est absurde.</li> <li>(3) implique (1) : on travaille composante connexe par composante connexe. Dans une composante connexe, on r\u00e9alise un parcours de graphe en largeur depuis un sommet \\(x\\), tous les sommets situ\u00e9s \u00e0 distance paire de \\(x\\) sont plac\u00e9s dans \\(U\\) et ceux \u00e0 distance impaire dans \\(V\\). S'il existe un arc \\(st \\in A\\) entre \\(s \\in U\\) et \\(t \\in V\\) alors \\(s\\) et \\(t\\) font partie d'un cycle de longueur impaire : c'est absurde. </li> </ul> <p>Cette proposition nous fait aussi remarquer que les graphes acycliques (les arbres et les for\u00eats) sont des graphes bipartis.</p>"},{"location":"graphes/couplages/#2-couplages","title":"2. Couplages","text":"<p>D\u00e9finition (incidence)</p> <p>Soit \\(G = (S, A)\\) un graphe, si \\(xy \\in A\\) est une ar\u00eate (resp. un arc) du graphe alors on dit que \\(xy\\) est incidente au sommet \\(x\\) (et aussi au sommet \\(y\\))</p> <p>D\u00e9finition (couplage)</p> <p>Soit \\(G = (S, A)\\) un graphe, un couplage \\(M\\) est un ensemble d'ar\u00eates (ou d'arcs) qui n'ont pas de sommets en commun, c'est-\u00e0-dire tel qu'il n'existe pas deux ar\u00eates (ou arcs) incidentes \u00e0 un m\u00eame sommet.</p> <p>Exemple : couplage dans un graphe non orient\u00e9</p> <p>Dans le graphe non orient\u00e9 ci-dessous, \\(M = \\{BH, CD, EG\\}\\) est un exemple de couplage, mais il y en a d'autres...  Un exemple de couplage en rouge."},{"location":"graphes/couplages/#cas-des-graphes-bipartis","title":"Cas des graphes bipartis","text":"<p>Exemple : le bal</p> <p>On consid\u00e8re un bal o\u00f9 il y a \\(n\\) danseuses et \\(m\\) danseurs. On construit le graphe biparti \\(G = (U \\sqcup V, A)\\) o\u00f9 \\(U\\) est l'ensemble des danseuses et \\(V\\) l'ensemble des danseurs. Dans ce graphe, il existe une ar\u00eate \\(uv \\in A\\) si \\(u\\) et \\(v\\) sont d'accord pour danser ensemble. On voit sur cet exemple qu'un couplage est une affectation possible danseuses-danseurs o\u00f9 tout le monde est d'accord sur son ou sa partenaire.  Un couplage de cardinal 3, en rouge, pour une instance du probl\u00e8me du bal. </p> <p>Soit \\(G = (U \\sqcup V, A)\\) un graphe biparti, on suppose que les sommets de \\(U\\) et \\(V\\) sont num\u00e9rot\u00e9s : \\(U = \\{u_0, u_1, \\dots, u_{n-1}\\}\\) et \\(V = \\{v_0, v_1, \\dots, v_{m-1}\\}\\). Informatiquement un couplage \\(M\\) peut se repr\u00e9senter par un tableau \\(T\\) de longueur \\(n\\) dans lequel :</p> <ul> <li>Si \\((u_i, v_j) \\in M\\) alors \\(T[i] = j\\)</li> <li>Sinon \\(T[i] = -1\\)</li> </ul> <p>Exercice</p> <ol> <li>\u00c9crire une fonction en langage C v\u00e9rifiant si un couplage repr\u00e9sent\u00e9 avec le codage propos\u00e9 ci-dessus correct : <pre><code>bool verifie(int adj[MAX][MAX], int T[MAX], int n, int m)\n</code></pre> Dans ce prototype <code>MAX</code> designe une constante sup\u00e9rieure \u00e0 \\(n+m\\) et <code>adj</code> est un tableau bi-dimensionnel stockant la matrice d'adjacence du graphe. On suppose que les sommets de \\(U\\) sont les sommets num\u00e9rot\u00e9s de \\(0\\) \u00e0 \\(n-1\\) et les sommets de \\(V\\) les sommets de \\(n\\) \u00e0 \\(n+m-1\\).</li> <li>Que dire du probl\u00e8me de d\u00e9cision dont l'instance est un graphe biparti et une constante enti\u00e8re \\(K\\), et la question est : existe-t-il un couplage de cardinal \\(K\\) ?</li> </ol>"},{"location":"graphes/couplages/#3-couplages-maximaux","title":"3. Couplages maximaux","text":"<p>Je donne la d\u00e9finition g\u00e9n\u00e9rale d'un couplage maximal mais le programme pr\u00e9cise qu'on se place dans le cadre des graphes bipartis.</p> <p>D\u00e9finition (couplage maximal)</p> <p>Soit \\(G = (S, A)\\) un graphe, un couplage \\(M\\) est un couplage maximal si \\(\\mathrm{Card}(M)\\) est maximal parmi tous les couplages possibles.</p> <p>On dira que \\(\\mathrm{Card}(M)\\) est la taille du couplage. Un couplage maximal est donc un couplage de taille maximale.</p> <p>Exemple : crise m\u00e9dicale</p> <p>Une crise m\u00e9dicale surgit dans laquelle \\(n\\) patients ont besoin de soins urgents et \\(m\\) m\u00e9decins sont disponibles. On construit un graphe biparti \\(G = (U \\sqcup V, A)\\) o\u00f9 \\(U\\) est l'ensemble des patients, \\(V\\) l'ensemble des m\u00e9decins, et il existe un ar\u00eate \\((u, v) \\in A\\) ssi le m\u00e9decin \\(v\\) peut traiter le patient \\(u\\). Avec cet exemple, on constate qu'un couplage est une affectation possible d'un m\u00e9decin \u00e0 un un patient. Un couplage maximal correspondra \u00e0 une affectation de m\u00e9decins qui maximise le nombre de patients trait\u00e9s.</p> <p>Attention !</p> <p>Un couplage peut \u00eatre maximal au sens de l'inclusion sans \u00eatre un couplage maximal.</p>"},{"location":"graphes/couplages/#a-recherche-exhaustive","title":"A - Recherche exhaustive","text":"<p>Soit \\(G = (S, A)\\) un graphe. La m\u00e9thode exhaustive peut \u00eatre employ\u00e9e pour d\u00e9terminer un couplage maximal. Par exemple, on construit un arbre binaire de hauteur \\(|A|\\) chaque profondeur repr\u00e9sente le choix de prendre ou de ne pas prendre l'ar\u00eate num\u00e9ro \\(i\\) dans le couplage. Chaque feuille de l'arbre correspond donc \u00e0 une partie de \\(A\\) : on v\u00e9rifie s'il s'agit d'un couplage et conserve celui de cardinal maximum.</p> <p>On peut am\u00e9liorer l'exploration en \u00e9lagant les branches d\u00e8s que deux ar\u00eates choisies dans le couplage sont incidentes \u00e0 un m\u00eame sommet. Cependant, la m\u00e9thode est \u00e9videmment tr\u00e8s co\u00fbteuse dans le pire cas : \\(O(2^{|A|})\\) et inutilisable pour de grands graphe.</p>"},{"location":"graphes/couplages/#b-chemins-augmentants","title":"B - Chemins augmentants","text":"<p>Les chemins augmentants permettent d'obtenir une m\u00e9thode efficace pour la recherche d'un couplage maximal.</p> <p>D\u00e9finition (chemin alternant)</p> <p>Soit \\(G = (S, A)\\) un graphe et \\(M\\) un couplage pour ce graphe. Un chemin est dit alternant relativement \u00e0 \\(M\\), s'il alterne entre une ar\u00eate dans \\(M\\) et une ar\u00eate n'appartenant pas \u00e0 \\(M\\).</p> <p>Remarque</p> <p>Dans la d\u00e9finition de chemin alternant, l'alternance peut commencer ou non par une ar\u00eate dans \\(M\\). Mais ce ne sera plus le cas du chemin augmentant dans la suite du cours.</p> <p>D\u00e9finition (chemin augmentant)</p> <p>Soit \\(G = (S, A)\\) un graphe, \\(M\\) un couplage et \\(C\\) un chemin dans \\(G\\). Le chemin \\(C\\) est dit augmentant pour notre couplage \\(M\\) si :</p> <ol> <li>\\(C\\) est un chemin alternant relativement \u00e0 \\(M\\)</li> <li>\\(C\\) commence et termine par un sommet qui n'est pas appari\u00e9 dans le couplage \\(M\\) (il n'existe pas d'ar\u00eate du couplage incidente \u00e0 ce sommet).</li> </ol> <p>Remarque</p> <p>Ainsi un chemin est augmentant est un alternant qui commence et finit par un sommet non appari\u00e9. Cela implique que l'alternance commence et finit par une ar\u00eate non choisie et que sa longueur est impaire. </p> <p>Dans la suite on utilisera l'op\u00e9rateur de diff\u00e9rence sym\u00e9trique entre deux ensembles :</p> \\[X \\Delta Y = (X \\cup Y) \\setminus (X \\cap Y)\\] <p>Pour simplifier les notations, on confondra par abus un chemin avec son ensemble d'ar\u00eates ce qui permettra aussi d'appliquer cet op\u00e9rateur sur les chemins.</p> <p>Proposition</p> <p>Soit \\(G = (S, A)\\) un graphe, \\(M\\) un couplage de cardinal \\(k\\) et \\(C\\) un chemin augmentant, alors \\(M \\Delta C\\) est un couplage de cardinal \\(k + 1\\).</p> <p>D\u00e9monstration</p> <ul> <li>Comme les sommets de d\u00e9part et d'arriv\u00e9e ne sont pas appari\u00e9s et que \\(C\\) est alternant, \\(C\\) contient n\u00e9cessairement \\(p\\) sommets dans \\(M\\) et \\(p+1\\) sommets dans \\(\\bar{M}\\). Ainsi \\(M' = M \\Delta C\\) contiendra une arete de plus que \\(M\\) (on retire \\(p\\) ar\u00eates et on en ajoute \\(p+1\\), d'ou le cardinal \\(k + 1\\). </li> <li>Il faut maintenant v\u00e9rifier que c'est bien un couplage. Soit \\((x,y)\\) une arete dans \\(M' = M \\Delta C\\). <ul> <li>Si \\((x, y) \\in M \\setminus C\\) : alors (x, y) n'est pas incidente \u00e0 une autre ar\u00eate \\(u\\) de \\(M'\\). En effet, soit \\(u \\in M\\) ce qui est exclus car \\(M\\) est un couplage, soit \\(u \\in C\\) et alors chacune des extremit\u00e9s de \\(u\\) appartiennent \u00e0 un arc de \\(M\\) qui est dans \\(C\\) donc diff\u00e9rent de \\((x, y)\\), c'est exclus car \\(M\\) est un couplge.</li> <li>Si \\((x, y) \\in C \\setminus M\\) : dans le chemin \\(C\\), il appara\u00eet le sous-chemin \\((a, x, y, b)\\) tel que \\((a, x) \\in M\\),  \\((x, y) \\not \\in M\\) et \\((y, b) \\in M\\). Soit \\(u\\) une ar\u00eate de \\(M'\\) incidente \u00e0 \\(x\\) (par exemple) qui n'est pas dans \\(C\\). Alors \\(u \\in M\\), c'est absurde car \\(u\\) et \\((a, x)\\) seraient incidentes \u00e0 un m\u00eame sommet et que \\(M\\) est un couplage. </li> </ul> </li> </ul> <p>Cette proposition est int\u00e9ressante car elle donne une m\u00e9thode pour am\u00e9liorer un couplage \\(M\\) : rechercher un chemin augmentant. Tant qu'on trouve un chemin augmentant dans le graphe, on peut trouver un cardinal plus grand d'une unit\u00e9. On ne sait toutefois pas encore si un couplage qui n'admet pas de chemin augmentant est bien un couplage maximal. C'est l'objet du th\u00e9or\u00e8me suivant.</p> <p>Th\u00e9or\u00e8me (Lemme de Berge, 1953)</p> <p>Un couplage \\(M\\) est maximal si et seulement s'il n'admet pas de chemin augmentant.</p> <p>D\u00e9monstration</p> <ul> <li>La proposition pr\u00e9c\u00e9dente montre le sens direct par contraposition</li> <li>Montrons le sens r\u00e9ciproque : soit \\(G = (S, A)\\) un graphe et \\(M\\) un couplage n'admettant pas de chemin augmentant. Supposons par l'absurde que \\(M\\) ne soit pas maximal et notons \\(M'\\) un meilleur couplage. On consid\u00e8re alors \\(H\\) le sous-graphe de \\(G\\) dont l'ensemble des ar\u00eates est \\(M \\Delta M'\\). Dans ce graphe un sommet ne peut \u00eatre incident qu'\u00e0 au plus deux ar\u00eates : une de \\(M\\) et une de \\(M'\\), les composantes connexes de \\(H\\) sont donc de trois types possibles :<ol> <li>Un sommet isol\u00e9</li> <li>Un cycle alternant entre des ar\u00eates de \\(M\\) et de \\(M'\\)</li> <li>Un chemin alternant entre des ar\u00eates de \\(M\\) et de \\(M'\\) de longueur impaire. </li> </ol> </li> <li>Puisque \\(M'\\) est plus grand que \\(M\\), il en d\u00e9coule que \\(H\\) contient une composante connexe poss\u00e9dant plus d'ar\u00eates de \\(M'\\) que d'ar\u00eates de \\(M\\). Cette composante ne peut \u00eatre que du troisi\u00e8me type : un chemin alternant qui commence par un sommet non appari\u00e9 dans \\(M\\) et qui termine par un sommet non appari\u00e9 dans \\(M\\). Donc c'est un chemin augmentant, c'est absurde.</li> </ul> <p>On obtient donc une m\u00e9thode algorithmique pour construire un couplage de cardinal maximal :</p> <ol> <li>Initialiser avec le couplage vide \\(M = \\varnothing\\)</li> <li>Tant qu'il existe un chemin augmentant \\(C\\), faire \\(M \\gets M \\Delta C\\)</li> <li>Retourner \\(M\\)</li> </ol>"},{"location":"graphes/couplages/#c-calcul-des-chemins-augmentants-avec-le-graphe-residuel","title":"C - Calcul des chemins augmentants avec le graphe r\u00e9siduel","text":"<p>Dans le cas d'un graphe biparti, la recherche de chemins augmentant est facilit\u00e9e. Consid\u00e9rons l'exemple suivant :</p> Un graphe biparti <p>On souhaite calculer un chemin augmentant c'est-\u00e0-dire : qui commence par un sommet non appari\u00e9 de \\(U\\) (par exemple), qui alterne et qui termine par un sommet n\u00e9cessairement dans \\(V\\) (longueur impaire du chemin augmentant) et non appari\u00e9 \u00e9galement. On construit pour cela le graphe r\u00e9siduel du graphe biparti relativement au couplage \\(M\\) actuel. C'est un graphe orient\u00e9 construit \u00e0 partir des sommets de \\(G\\) et de \\(M\\), en utilisant les r\u00e8gles suivantes :</p> <ul> <li>On ajoute un sommet de d\u00e9part \\(s\\) et un sommet cible \\(t\\).</li> <li>Le sommet de d\u00e9part \\(s\\) pointe sur chaque sommet non appari\u00e9 de \\(U\\)</li> <li>Les sommets non appari\u00e9s de \\(V\\) pointent sur le sommet cible \\(t\\)</li> <li>Si \\((u, v) \\in M\\) on a ajoute un arc \\((u, v)\\) pour autoriser le passage de gauche \u00e0 droite</li> <li>Si \\((u, v) \\not \\in M\\) on ajoute un arc \\((v, u)\\) pour autoriser le passage de droite \u00e0 gauche</li> </ul>"},{"location":"graphes/couplages/#1ere-iteration","title":"1\u00e8re it\u00e9ration","text":"<p>Voici initialement (\\(M = \\varnothing\\)) le graphe r\u00e9siduel de notre exemple :</p> Graphe r\u00e9siduel pour le couplage initial vide <p>Un chemin de \\(s\\) \u00e0 \\(t\\) correspond alors \u00e0 un chemin augmentant ! En effet, il commence et termine n\u00e9cessairement par des sommets non appari\u00e9s, et il est bien alternant : comme le graphe est biparti, un chemin alterne avec des arcs de gauche \u00e0 droite (dans \\(M\\)) et de droite \u00e0 gauche (dans \\(\\bar{M}\\)).</p> <p>Voici un exemple de chemin de \\(s\\) \u00e0 \\(t\\) qui correspond \u00e0 un chemin augmentant dans \\(G\\) :</p> Un chemin augmentant <p>Ainsi, ce chemin augmentant nous donne le nouveau couplage \\(M \\gets M \\Delta C = \\{(u_1, v_1)\\}\\). Le graphe r\u00e9siduel doit ensuite \u00eatre mis \u00e0 jour :</p> Mise \u00e0 jour du graphe r\u00e9siduel"},{"location":"graphes/couplages/#2e-iteration","title":"2e it\u00e9ration","text":"<p>On trouve maintenant le chemin am\u00e9liorant</p> <p>qui conduit au couplage \\(M =\\{(u_1, v_1), (u_2, v_2)\\}\\) et au nouveau graphe r\u00e9siduel :</p>"},{"location":"graphes/couplages/#3e-iteration","title":"3e it\u00e9ration","text":"<p>On trouve maintenant le chemin am\u00e9liorant</p> <p>qui conduit au couplage \\(M =\\{(u_1, v_3), (u_2, v_2), (u_3, v_1)\\}\\) et au nouveau graphe r\u00e9siduel :</p>"},{"location":"graphes/couplages/#4e-iteration","title":"4e it\u00e9ration","text":"<p>Enfin, on trouve maintenant le chemin am\u00e9liorant</p> <p>qui conduit au couplage \\(M =\\{(u_1, v_3), (u_2, v_4), (u_3, v_1), (u_4, v_2)\\}\\) et au nouveau graphe r\u00e9siduel :</p> <p>Il n'y a maintenant plus de chemin am\u00e9liorant. Le couplage obtenu est alors un couplage maximal d'apr\u00e8s le th\u00e9or\u00e8me de Berge.</p> <p>Exercice (march\u00e9 de l'emploi)</p> <p>Cinq personnes (\u00e0 gauche sur la figure) sont \u00e0 la recherche d'un emploi. Il y a aussi cinq offres d'emploi (\u00e0 droite sur la figure) disponibles. On dessine une ar\u00eate entre une personne et un emploi lorsque la personne est qualifi\u00e9e pour effectuer ce travail. Combien de personnes au total pourra-t-on employer au maximum ?   R\u00e9soudre le probl\u00e8me en employant l'algorithme des chemins augmentants.</p> <p>Complexit\u00e9</p> <p>Cet algorithme effectue au plus \\(|U|\\) recherches de chemin augmentant. Chaque recherche est un parcours de graphe qui a une complexit\u00e9 \\(O(|U| + |V| + |A|)\\) (complexit\u00e9 lin\u00e9aire). Ainsi la complexit\u00e9 en temps de cet algorithme est :</p> \\[ O(|U|(|U| + |V| + |A|)) \\] <p>Si \\(n = |U| + |V|\\) est le nombre total de sommets alors \\(|A| = O(n^2)\\), ce qui montre que dans le pire cas, cet algorithme est de complexit\u00e9 cubique \\(O(n^3)\\).</p>"},{"location":"graphes/kruskal/","title":"Arbres couvrants de poids minimal","text":""},{"location":"graphes/kruskal/#1-structure-de-donnee-union-find","title":"1. Structure de donn\u00e9e Union-Find","text":""},{"location":"graphes/kruskal/#a-implementation-favorisant-find","title":"A. Impl\u00e9mentation favorisant <code>find</code>","text":""},{"location":"graphes/kruskal/#b-implementation-favorisant-union","title":"B. Impl\u00e9mentation favorisant <code>union</code>","text":""},{"location":"graphes/kruskal/#i-fusion-amelioree","title":"i) Fusion am\u00e9lior\u00e9e","text":""},{"location":"graphes/kruskal/#ii-compression-des-chemins","title":"ii) Compression des chemins","text":""},{"location":"graphes/kruskal/#2-arbres-couvrants","title":"2. Arbres couvrants","text":""},{"location":"graphes/kruskal/#a-rappels","title":"A. Rappels","text":"<p>D\u00e9finition : cycle</p> <p>Soit \\(G = (S, A)\\) un graphe non orient\u00e9, un cycle est un chemin \\((s_0, s_1, \\dots, s_p)\\) (\\(p &gt; 0\\)) v\u00e9rifiant :</p> <ol> <li>\\(\\forall i \\in [|0, p-1|], s_i s_{i+1} \\in A\\)</li> <li>\\(s_0 = s_p\\)</li> <li>une ar\u00eate appara\u00eet au plus une fois dans le chemin</li> </ol> <p>L'entier \\(p\\) est appel\u00e9 la longueur du cycle. Par d\u00e9finition \\(p \\geq 2\\).</p> <p>D\u00e9finitions : arbre et for\u00eat</p> <ul> <li>Un arbre est un graphe acyclique et connexe.</li> <li>Une for\u00eat est un graphe acyclique.</li> </ul> <p>Dans une for\u00eat chaque composante connexe est donc un arbre, d'o\u00f9 la terminologie.</p> <p>Dans un arbre on peut, si on le souhaite, choisir un sommet particulier qu'on appelle racine. Ses voisins sont alors ses enfants, et ainsi de suite. Dans ce cas, ont dit que l'arbre est enracin\u00e9. </p> <p>Proposition</p> <p>Tout arbre de taille au moins 2 poss\u00e8de au moins un sommet de d\u00e9gr\u00e9 1.</p> <p>Proposition</p> <p>Tout arbre de taille \\(n &gt; 0\\) poss\u00e8de \\(n-1\\) ar\u00eates.</p>"},{"location":"graphes/kruskal/#b-arbres-couvrants","title":"B. Arbres couvrants","text":"<p>D\u00e9finition : arbre couvrant</p> <p>Soit \\(G = (S, A)\\) un graphe connexe. Un arbre couvrant de \\(G\\) est un sous-graphe \\(H\\) contenant tous les sommets de \\(G\\) et qui est un arbre, c'est-\u00e0-dire :</p> <ol> <li>\\(H = (S, A')\\) avec \\(A' \\subset A\\)</li> <li>\\(H\\) est un arbre (connexe et acyclique)</li> </ol> <p>On remarque que si \\(G\\) n'est pas connexe, cette d\u00e9finition n'a aucun sens...</p> <p>Remarque</p> <p>Pour d\u00e9crire un arbre couvrant de \\(G = (S, A)\\) il suffit de lister ses ar\u00eates \\(A'\\).</p> <p>Proposition</p> <p>Soit \\(G = (S, A)\\) un graphe connexe et \\(H\\) un sous-graphe de \\(G\\) alors on a \u00e9quivalence entre :</p> <ol> <li>\\(H\\) est un arbre couvrant de \\(G\\)</li> <li>\\(H\\) est acyclique et poss\u00e8de \\(n-1\\) ar\u00eates.</li> </ol> <p>Le sens \\((1) \\Rightarrow (2)\\) est \u00e9vident avec ce qui pr\u00e9c\u00e8de. Pour le sens \\((2) \\Rightarrow (1)\\) on remarque qu'\u00e0 chaque fois qu'on ajoute une ar\u00eate sans cr\u00e9er de cycle, on diminue le nombre de composantes de 1. Donc en en prenant \\(n-1\\) il n'y a plus qu'une seule composante connexe, \\(H\\) est un arbre et poss\u00e8de donc les \\(n\\) sommets de \\(G\\).</p> <p>Algorithme g\u00e9n\u00e9ral pour construire un arbre couvrant \\(H = (S, A')\\) de \\(G = (S, A)\\) :</p> <ol> <li>Initialiser \\(A' \\gets \\varnothing\\)</li> <li>Initialiser une structure union find avec pour singletons les sommets de \\(G\\)</li> <li>Ajouter un arc \\(xy\\) arbitraire mais qui ne cr\u00e9\u00e9 pas de cycle \\(find(x) \\neq find(y)\\)</li> <li>Fusionner les composantes connexes de \\(x\\) et \\(y\\) : \\(union(x, y)\\)</li> <li>Si \\(H\\) n'est pas connexe, aller en 3.</li> </ol>"},{"location":"graphes/kruskal/#3-algorithme-de-kruskal","title":"3. Algorithme de Kruskal","text":"<p>D\u00e9finition : arbre couvrant de poids minimal</p> <p>Soit \\(G = (S, A, p)\\) un graphe non orient\u00e9 pond\u00e9r\u00e9. Un arbre couvrant de poids minimal (ACM) est :</p> <ol> <li>Un arbre couvrant de \\(G\\)...</li> <li>... de poids minimal parmi tous les arbres couvrants de \\(G\\).</li> </ol> <p>Il y a un nombre fini d'arbres couvrants dans un graphe \\(G\\), donc un tel arbre existe n\u00e9cessairement. Il peut cependant il y en avoir plusieurs qui sont de poids minimal.</p> <p>Algorithme de Kruskal</p> <ol> <li>Initialiser \\(A' \\gets \\varnothing\\)</li> <li>Initialiser une structure union find avec pour singletons les sommets de \\(G\\)</li> <li>Trier par ordre de poids croissant les ar\u00eates de G</li> <li>Pour tout arc \\(xy\\) dans l'ordre obtenu :<ul> <li>Si \\(find(x) = find(y)\\) ne rien faire (l'ar\u00eate cr\u00e9\u00e9 un cycle)</li> <li>Sinon \\(A' \\gets A' \\cup \\{xy\\}\\)</li> <li>Et \\(fusion(x, y)\\)</li> </ul> </li> </ol> <p>Complexit\u00e9</p> <p>Proposition</p> <p>L'algorithme de Kruskal construit un arbre couvrant de poids minimal.</p> <p>D\u00e9monstration : on a d\u00e9j\u00e0 vu qu'un tel algorithme construit un arbre couvrant, il reste \u00e0 montrer qu'il est minimal. \u00c0 chaque it\u00e9ration, l'invariant suivant est v\u00e9rifi\u00e9 : il existe un ACM T tel que \\(H \\subset T\\).</p>"},{"location":"i8080/","title":"\u00c9mulateur Intel 8080","text":"<p>Le processeur Intel 8080 est un des tous premiers processeurs grand public, con\u00e7u et fabriqu\u00e9 par la soci\u00e9t\u00e9 Intel en 1974. Dot\u00e9 d'un riche jeu d'instructions (pour l'\u00e9poque) et d'un bus d'adresse sur 16 bits permettant d'adresser 64kio de m\u00e9moire, il a rencontr\u00e9 un franc succ\u00e8s.</p>  Le processeur Intel 8080 (Wikipedia)  <p>L' Intel 8080 a \u00e9t\u00e9 utilis\u00e9 pour la conception des premiers PC dont le plus connu est l'Altair 8080. Des versions proches du i8080, telles que le processeur Zilog Z80, ont \u00e9t\u00e9 utilis\u00e9es comme processeurs des console de jeu GameBoy de Nintendo (1989) et Master System de Sega (1985). Le successeur du Intel 8080 sera le Intel 8086 (1978) qui est le premier processeur de la famille x86. Aujourd'hui la plupart des processeurs grand public sont con\u00e7us sur l'architecture x86-64 et on retrouve dans leurs jeux d'instructions des similitudes avec l'i8080. </p> <ul> <li> <p>L'Altair 8080 (1975)</p> <p></p> </li> <li> <p>Le PC ZX Spectrum (1982)</p> <p></p> </li> <li> <p>La console Master System (Sega)</p> <p></p> </li> <li> <p>Le jeu Space Invaders sur borne d'arcade</p> <p></p> </li> </ul> <p>(cr\u00e9dits : Wikipedia)</p>"},{"location":"i8080/#objectifs","title":"Objectifs","text":"<p>Dans ce projet en langage C, je vous propose :</p> <ul> <li>D'\u00e9crire enti\u00e8rement un programme en langage C qui \u00e9mule le fonctionnement du processeur i8080.</li> <li>De tester son fonctionnement en lui faisant ex\u00e9cuter des petits programmes \u00e9crits par nos soins en langage machine. </li> <li>De r\u00e9aliser des tests plus pouss\u00e9s, en faisant tourner des vrais programmes de diagnostique CPU, garantissant ainsi la fid\u00e9lit\u00e9 du travail obtenu.</li> <li>D'ex\u00e9cuter sur notre processeur le jeu Space Invaders : pour cela il nous faudra aussi impl\u00e9menter une \u00e9mulation du mat\u00e9riel de la borne d'arcade du jeu.</li> </ul>"},{"location":"i8080/#competences-travaillees","title":"Comp\u00e9tences travaill\u00e9es","text":"<p>Ce projet vous permettra de renforcer les comp\u00e9tences suivantes au programme de la MP2I/MPI :</p> <ul> <li>Programmer proprement en langage C</li> <li>Comprendre le fonctionnement d'un ordinateur dans un contexte simple (relativement aux processeurs actuels)</li> <li>Comprendre la repr\u00e9sentation des programmes et des donn\u00e9es en machine (base 2, entiers sign\u00e9s et non sign\u00e9s, compl\u00e9ment \u00e0 2, cha\u00eenes de caract\u00e8res, langage machine...)</li> <li>Comprendre la gestion de la m\u00e9moire d'un ordinateur : en particulier, on impl\u00e9mentera la fameuse Pile d'ex\u00e9cution et on comprendra son int\u00e9r\u00eat, on comprendra les notions de registre, RAM et ROM.</li> </ul> <p>Attention</p> <p>Les connaissances sp\u00e9cifiques pr\u00e9sent\u00e9es ici sur l'architecture, l'\u00e9mulation mat\u00e9rielle et l'i8080 ne sont bien \u00e9videmment pas au programme de MP2I/MPI. Voyez ceci comme un projet pour aiguiser vos comp\u00e9tences et \u00e9largir votre culture en informatique.</p>"},{"location":"i8080/#sources-et-liens-utiles","title":"Sources et liens utiles","text":"<p>Pour r\u00e9aliser ce projet, je me suis bas\u00e9 sur les sources suivantes (mais aussi sur des lectures de forums pour combler les manques).</p> <ul> <li>Intel 8080 Assembly Language Programming Manual rev. B, Intel Corp, 1975 (disponible sur Altairclone.com)</li> <li>Intel 8080 Microcomputer Systems User's Manual, Intel Corp, 1975</li> <li>8080/8085 Assembly language programming manual, Intel Corp, 1981 (disponible sur Altairclone.com)</li> <li>Un magnifique tableau du jeu d'instructions : Intel 8080 instruction set</li> <li>Computer archeology : un site internet fantastique sur lequel des passion\u00e9s ont d\u00e9sassembl\u00e9 et comment\u00e9 l'int\u00e9gralit\u00e9 du code source assembleur du jeu Space Invaders </li> <li>ASM80.com : un \u00e9diteur en ligne magnifique permettant d'\u00e9crire, ex\u00e9cuter et compiler des programmes en assembleur pour i8080 (entre autres...). Merci \u00e0 son auteur !</li> </ul>"},{"location":"i8080/alu/","title":"L'unit\u00e9 arithm\u00e9tique et logique (ALU)","text":"<p>Nouveaux fichiers : <code>alu.h</code> <code>alu.c</code></p> <p>On s'int\u00e9resse maintenant aux calculs arithm\u00e9tiques et logiques r\u00e9alis\u00e9s par le processeur. Le 8080 est capable de r\u00e9aliser :</p> <ul> <li>des additions</li> <li>des soustractions</li> <li>des ET, OR, XOR bit \u00e0 bit</li> <li>des comparaisons</li> </ul> <p>Toutefois plusieurs instructions permettent de r\u00e9aliser chacune de ces op\u00e9rations, par exemple pour additioner on dispose de ADD, ADC, ADI et ACI. Pour \u00e9viter de r\u00e9\u00e9crire plusieurs fois les m\u00eames codes, on rassemble dans cette unit\u00e9 de compilation les fonctions permettant de r\u00e9aliser concr\u00e8tement les op\u00e9rations sur le processeur. On se servira ensuite de ces fonctions pour coder facilement chacune des instructions.</p>"},{"location":"i8080/alu/#1-les-additions","title":"1. Les additions","text":"<p>Dans sa version la plus basique, un processeur r\u00e9alise l'op\u00e9ration d'addition comme on l'a apprise \u00e0 l'\u00e9cole primaire : <pre><code>retenues :      1     1\n                  1 0 0 1 0 (18)\n               +  1 0 0 1 1 (19)\n               ------------\n                1 0 0 1 0 1 (37)\n</code></pre></p>"},{"location":"i8080/alu/#additionneur-1-bit","title":"Additionneur 1 bit","text":"<p>Pour impl\u00e9menter cela, on commence par r\u00e9aliser un circuit capable d'aditionner deux entiers \\(s = a + b\\) ayant 1 bit (donc ils valent 0 ou 1) avec \u00e9ventuellement une retenue d'entr\u00e9e (\\(c_{in}\\)). Cela correspond \u00e0 une colonne dans le calcul ci-dessus.</p> <p>Voil\u00e0 \u00e0 quoi ressemble sch\u00e9matiquement un tel composant : il poss\u00e8de 3 entr\u00e9es \\(a, b, c_{in}\\) et deux sorties \\(s, c_{out}\\).</p>  Additionneur 1 bit  <p>La table de v\u00e9rit\u00e9 impl\u00e9ment\u00e9e est la suivante :</p> \\(a\\) \\(b\\) \\(c_{in}\\) \\(s\\) \\(c_{out}\\) 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 0 1 1 0 1 1 0 0 1 0 1 0 1 0 1 1 1 0 0 1 1 1 1 1 1 <p>Par exemple si sur une colonne du calcul on trouve 1 pour \\(a\\), 1 pour \\(b\\) et qu'on a une retenue (\\(c_{in} = 1\\)), on obtient 11 donc on pose \\(s = 1\\) et on retient 1 (\\(c_{out} = 1\\)).</p>"},{"location":"i8080/alu/#additionneur-8-bits","title":"Additionneur 8-bits","text":"<p>Comment faire maintenant pour additioner des nombres \\(a\\) et \\(b\\) sur 8 bits (avec \u00e9ventuellement une retenue d'entr\u00e9e) ? Facile, il suffit d'assembler 8 additionneurs 1-bit. On fait en sorte que les retenues obtenues sur le calcul d'une colonne soit transmises \u00e0 la colonne suivante. Cela donne le sch\u00e9ma suivant :</p>  Additionneur 8 bit (cliquer pour agrandir)  <p>Dans ce circuit, il y a 3 entr\u00e9es : un entier \\(a\\) sur 8 bits, un entier \\(b\\) sur 8 bits et un bit \u00e9ventuel de retenue \\(c_{in}\\). Les sorties sont la somme \\(s\\) sur 8 bits et \u00e9ventuellement une retenue de sortie \\(c_out\\). Cette retenue signifie que le r\u00e9sultat en fait que le r\u00e9sultat ne tenait pas sur 8 bits et qu'il faudrait un bit suppl\u00e9mentaire pour le r\u00e9pr\u00e9senter.</p> <p>Lorsque le 8080 op\u00e8re une addition, il proc\u00e8de ainsi. De plus il signale gr\u00e2ce au flag CY s'il y a eu une retenue finale ou non (CY est set lorsque \\(c_{out} = 1\\), sinon il est reset). De plus cette retenue est \u00e9galement utile si l'on veur sommer des entiers sur 16-bit, 24-bit, 32-bit, etc : il suffit de les voir comme 2, 3, 4, etc entiers 8-bit et de r\u00e9aliser une addition par bloc de 8-bits. Le flag CY permettra alors de propager correctement les retenues d'un bloc \u00e0 l'autre. </p> <p>On remarque aussi sur le sch\u00e9ma que la retenue \u00e9ventuelle entre le bit 3 et 4 est aussi notifi\u00e9e de la m\u00eame mani\u00e8re que \\(c_{out}\\) gr\u00e2ce au flag AC (retenue auxilaire). Ce flag ne sert presque \u00e0 rien \u00e0 part de permettre en interne l'ex\u00e9cution de l'instruction DAA qu'on expliquera plus tard. Il faudra quand m\u00eame faire attention \u00e0 d\u00e9finir AC correctement.</p> <p>Les autres flags S, Z et P sont d\u00e9finis \u00e0 partir de la valeur de sortie \\(s\\), tel qu'on l'a programm\u00e9 dans <code>flags.c</code> : on pourra utiliser la fonction <code>update_flags_szp</code>.</p>"},{"location":"i8080/alu/#implementation","title":"Impl\u00e9mentation","text":"<p>Nous commencerons par les additions et les soustractions, on cr\u00e9\u00e9 le fichier d'en-t\u00eate :</p> alu.h<pre><code>#ifndef ALU_H\n#define ALU_H\n\n#include &lt;stdint.h&gt;\n#include \"computer.h\"\n\n/* R\u00e9alise l'op\u00e9ration d'addition de a + b + carry et retourne le r\u00e9sultat.\n * carry sert \u00e0 donner la possibilit\u00e9 d'avoir une retenue d'entr\u00e9e, carry = 0 ou 1\n * op_add modifie tous les flags CY, AC, S, Z, P selon le r\u00e9sultat obtenu et\n * le d\u00e9roul\u00e9 de l'addition. */\nuint8_t op_add(Computer *comp, uint8_t a, uint8_t b, uint8_t carry);\n\n#endif\n</code></pre> <p>Exercice</p> <p>Dans un nouveau fichier <code>alu.c</code> impl\u00e9menter l'instruction <code>op_add</code>. Je vous conseille de proc\u00e9der ainsi :</p> <ul> <li>Ajouter une assertion pour garantir que <code>carry</code> vaut 0 ou 1</li> <li>Convertir chaque entr\u00e9e en entier sur 16-bits : cela \u00e9vitera les probl\u00e8mes de d\u00e9passement</li> <li>Calculer la somme <code>a + b + carry</code></li> <li>Si la somme d\u00e9passe le plus grand entier repr\u00e9sentable sur 8 bits (<code>0xFF</code>) alors c'est qu'il y a une retenue (on met \u00e0 jour correctement <code>CY</code></li> <li>Les 8 bits de poids faible de la somme correspondent \u00e0 la valeur de sortie \\(s\\) de la fonction.</li> <li>On v\u00e9rifie s'il y a une retenue auxilaire de la m\u00eame mani\u00e8re, en v\u00e9rifiant si \\(a' + b' + carry\\) d\u00e9passe la valeur maximale sur 4 bits (<code>0xF</code>), avec \\(a'\\) et \\(b'\\) les entiers obtenus \u00e0 partir de \\(a\\) et \\(b\\) en ne gardant que les 4 bits de poids faibles.</li> <li>On n'oublie pas de mettre \u00e0 jour les autres flags en fonction de la valeur de \\(s\\)</li> </ul>"},{"location":"i8080/alu/#2-les-soustractions","title":"2. Les soustractions","text":"<p>Pour les soustractions on peut \u00e9galement proc\u00e9der comme \u00e0 l'\u00e9cole primaire : <pre><code>                              1 0 0 1 1 (19)\n                           -  0 1 1 0 0 (12)\nretunues (emprunts) :      -  1 1  \n                               ------------\n                              0 0 1 1 1 (7)\n</code></pre></p> <p>La diff\u00e9rence est surtout li\u00e9e \u00e0 la retenue (appel\u00e9e emprunt dans le cas de la soustraction) qui devra cette fois \u00eatre retir\u00e9e \u00e0 la colonne sup\u00e9rieure.</p> <p>Toutefois, le processeur 8080 ne proc\u00e8de pas ainsi : il va habilement utiliser les circuits d\u00e9j\u00e0 pr\u00e9sents (l'additionneur 8-bits) et l'astuce du compl\u00e9ment \u00e0 2 pour r\u00e9aliser sa soustraction.</p>"},{"location":"i8080/alu/#transformer-une-soustraction-en-somme","title":"Transformer une soustraction en somme","text":"<p>Remarque</p> <p>Cette section est construite \u00e0 partir de ma compr\u00e9hension des m\u00e9canismes impliqu\u00e9s. J'ai d\u00fb faire quelques recherches \u00e0 gauche et \u00e0 droite car le manuel est peu bavard sur le sujet. Par exemple pour la soustraction avec emprunt, il indique seulement :</p> <p>The Carry bit is internally added to the contents of the specified byte. This value is then subtracted  from the accumulator using two's complement arithmetic.</p> <p>sans pr\u00e9ciser comment la retenue est ajout\u00e9e en interne ni comment est utilis\u00e9 le compl\u00e9ment \u00e0 2.</p> <p>L'id\u00e9e est que comme on travaille sur 8-bits ajouter \\(2^8\\) ne change rien au r\u00e9sultat et donc :  \\(a - b \\equiv a - b + 2^8 = a + (2^8 - 1 - b) + 1\\). Or \\(2^8 - 1 = 0b11111111\\), donc soustraire \\(b\\) \u00e0 ce nombre revient \u00e0 inverser les 0 et les 1 dans \\(b\\). Au final, il suffit donc de calculer : <code>a + ~b + 1</code>. On peut le faire avec les circuits actuels : il suffit de sommer <code>a</code> avec <code>~b</code> et d'utiliser une retenue d'entr\u00e9e \\(c_{in} = 1\\). </p> <p>Vous n'\u00eates pas convaincus ? Regardons sur le m\u00eame exemple <pre><code>19 = 0 0 0 1 0 0 1 1\n12 = 0 0 0 0 1 1 0 0 donc ~12 = 1 1 1 1 0 0 1 1\n\n          0 0 0 1 0 0 1 1 (19)\n        + 1 1 1 1 0 0 1 1 (~12)\n        +               1 (retenue \u00e0 1)\n        ----------------- \n      (1) 0 0 0 0 0 1 1 1 (7)\n</code></pre> Cela marche ! A ceci pr\u00e8s que cela provoque une retenue finale CY = 1 dans l'addition, alors qu'il n'y a pas d'emprunt final fait dans la soustraction. Pour r\u00e9soudre cela, on ajoute une \u00e9tape finale qui consiste \u00e0 inverser le flag CY (on ne le fera pas pour AC).</p> <p>A l'inverse si on effectue un r\u00e9sultat conduisant \u00e0 une valeur n\u00e9gative, par exemple \\(19 - 25\\) : <pre><code>19 = 0 0 0 1 0 0 1 1\n25 = 0 0 0 1 1 0 0 1 donc ~25 = 1 1 1 0 0 1 1 0\n\n          0 0 0 1 0 0 1 1 (19)\n        + 1 1 1 0 0 1 1 0 (~25)\n        +               1 (retenue \u00e0 1)\n        ----------------- \n      (0) 1 1 1 1 1 0 1 0 (250)\n</code></pre> Non je n'ai pas fait d'erreur, rappelez-vous qu'on travaille ici avec des entiers non sign\u00e9s sur 8 bits, c'est-\u00e0-dire modulo 256. La valeur du r\u00e9sultat \\(-6\\) est donc bien congrue \u00e0 \\(256 + (-6) = 250\\). Cela marche !</p> <p>Remarquer que cette fois-ci il n'y a pas de retenue finale dans l'addition, et comme on va inverser CY, on aura au final CY = 1 (set). Cela marque le fait que cette op\u00e9ration dans sa globalit\u00e9 a provoqu\u00e9 un emprunt qu'il faudra \u00e9ventuellement propager dans le cas d'une soustraction par blocs.</p> <p>Une autre fa\u00e7on de le voir est qu'en proc\u00e9dant ainsi pour le calcul de \\(a - b\\), le flag CY vaudra 1 lorsque \\(a &lt; b\\) et 0 sinon : il sera donc tr\u00e8s utile pour permettre de comparer deux valeurs. </p> En base 10 : \u00e7a marche aussi ! <p>Remarquer que l'astuce du compl\u00e9ment \u00e0 2 n'a rien de sp\u00e9cifique \u00e0 la base 2 : si je veux calculer par exemple \\(124 - 012\\), je peux transformer cela en addition : \\(124 + 987 + 1\\). En effet, j'ai simplement pris le \"compl\u00e9ment \u00e0 9\" de chaque chiffre de 012. On obtient : 124 + 987 + 1 = (1)112. En ignorant le premier chiffre (1 = pas d'emprunt) on retrouve bien le r\u00e9sultat de la soustraction !</p>"},{"location":"i8080/alu/#et-sil-y-a-un-emprunt","title":"Et s'il y a un emprunt ?","text":"<p>Maintenant que se passe-t-il si l'on souhaite effectuer la soustraction \\(a - b\\) sachant qu'il y a eu un empr\u00fbnt pr\u00e9alable (par exemple, si on a effectu\u00e9 des soustractions par bloc de 8-bits et que le bloc en dessous de nous a provoqu\u00e9 une retenue). Il faut donc alors calculer \\(a - b - 1\\).</p> <p>Pas de probl\u00e8me on refait un peu d'arithm\u00e9tique : \\(a - b - 1 \\equiv a - b - 1 + 2^8 = a + (2^8 - 1 - b)\\). Autrement dit, on retrouve le m\u00eame calcul que pr\u00e9c\u00e9demment, sauf qu'on effectue l'addition sans retenue d'entr\u00e9e : \\(c_{in} = 0\\) : c'est m\u00eame encore plus simple !</p> <p>R\u00e9sum\u00e9</p> <p>Pour conclure, on retiendra :</p> <ul> <li>Pour calculer \\(a - b\\) sans emprunt : on applique le calcul de somme <code>a + ~b</code> avec une retenue initiale <code>carry = 1</code>, puis on inverse le flag <code>CY</code> \u00e0 la fin.</li> <li>Pour calculer \\(a - b\\) avec un emprunt de 1 : on applique le calcul de somme <code>a + ~b</code> sans retenue initiale <code>carry = 0</code>, puis on inverse le flag <code>CY</code> \u00e0 la fin</li> </ul>"},{"location":"i8080/alu/#implementation_1","title":"Impl\u00e9mentation","text":"<p>Ajouter au fichier d'en-t\u00eate : alu.h<pre><code>/* R\u00e9alise l'op\u00e9ration de soustraction de a - b - borrow et retourne le r\u00e9sultat.\n * borrow sert \u00e0 donner la possibilit\u00e9 d'avoir une retenue d'entr\u00e9e (emprunt)\n * borrow = 0 ou 1\n * op_sub modifie tous les flags CY, AC, S, Z, P selon le r\u00e9sultat obtenu et\n * le d\u00e9roul\u00e9 de la soustraction. */\nuint8_t op_sub(Computer *comp, uint8_t a, uint8_t b, uint8_t borrow);\n</code></pre></p> <p>Exercice</p> <p>Dans le fichier <code>alu.c</code>, impl\u00e9mentez la fonction <code>op_sub</code>. Cette fonction proc\u00e9dera comme indiqu\u00e9 ci-dessus : on provoquera le bon appel \u00e0 <code>op_add</code> puis on inverse le flag CY \u00e0 la fin. C'est donc <code>op_add</code> qui d\u00e9termine la valeur des autres flags.</p>"},{"location":"i8080/alu/#3-les-operations-logiques-bit-a-bit","title":"3. Les op\u00e9rations logiques bit \u00e0 bit","text":"<p>On va pouvoir souffler avec quelques op\u00e9rations plus simples \u00e0 comprendre : le AND, le XOR et le OR bit \u00e0 bit. Ce sont exactement les m\u00eames op\u00e9rations que <code>&amp;</code>, <code>^</code> et <code>|</code> en langage C.</p> <p>Le seul point d'attention est de mettre \u00e0 jour correctement les flags. Les flags S, Z, et P se mettent \u00e0 jour normalement en fonction du r\u00e9sultat : on peut utiliser notre fonction <code>update_flags_szp</code> pour cela. Pour les flags CY (Carry) et AC (Auxiliary Carry), les r\u00e8gles sont les suivantes :</p> Op\u00e9ration CY AC AND reset d\u00e9fini comme le OU des deux bits 3 des op\u00e9randes XOR reset reset OR reset reset <p>Dans l'exemple : <pre><code>bit      7654 3210                  \n\n         1010 1010\n    AND  0110 0110\n    --------------\n         0010 0010\n</code></pre> le flag CY sera reset (dans tous les cas), et le flag AC sera set car les bits 3 (c'est-\u00e0-dire les 4e bits en comptant de la droite vers la gauche) valent respectivement <code>1</code> et <code>0</code> et que <code>1 OU 0 = 1</code>.</p> <p>Remarques</p> <p>Je vous ai mach\u00e9 ici beaucoup de travail de recherche dans les documentations... En effet :</p> <p>Le Intel 8080 Assembly Language Programming Manual stipule que le flag AC n'est pas modifi\u00e9, mais cela est contredit par d'autres sources y compris de chez Intel : le Intel 8080 Microcomputer Systems Users Manual indique que AC est affect\u00e9, mais sans dire comment. Enfin le 8080/8085 Assembly Programming Manual explique (p 1-12) que AC est affect\u00e9 comme expliqu\u00e9 ci-dessus...</p> <p>Cet exemple doit vous rappeler \u00e0 quel point la sp\u00e9cification et la documentation est importante en informatique</p> <p>Bon, passons \u00e0 la programmation. On ajoute dans le fichier d'en-t\u00eate les prototypes pour ces trois op\u00e9rations.</p> alu.h<pre><code>/* Ces fonctions calculent l'op\u00e9ration bit \u00e0 bit entre a et b\n * et retournent le r\u00e9sultat.\n * Tous les flags : CY AC S Z P sont affect\u00e9s */\nuint8_t op_and(Computer *comp, uint8_t a, uint8_t b);\nuint8_t op_xor(Computer *comp, uint8_t a, uint8_t b);\nuint8_t op_or(Computer *comp, uint8_t a, uint8_t b);\n</code></pre> <p>Exercice</p> <p>Dans le fichier <code>alu.c</code>, proposer une impl\u00e9mentation des ces trois fonctions. On utilisera \u00e9videmment les op\u00e9rateurs <code>&amp;</code>, <code>^</code> et <code>|</code> du langage C pour effectuer les calculs.</p>"},{"location":"i8080/alu/#4-tester-tester-et-tester","title":"4. Tester, tester et tester !","text":"<p>Apr\u00e8s avoir compil\u00e9 tout cela, je vous encourage sinc\u00e8rement \u00e0 \u00e9crire des tests unitaires fournis pour vos fonctions <code>op_XXX</code>. En particulier : v\u00e9rifier non seulement la valeur du r\u00e9sultat, mais aussi que les flags sont correctement d\u00e9finis apr\u00e8s chaque op\u00e9ration. Ces fonctions sont source d'erreur, en particulier sur les flags... </p>"},{"location":"i8080/architecture/","title":"Architecture g\u00e9n\u00e9rale du processeur","text":"<p>Nouveaux fichiers : <code>computer.h</code> <code>computer.c</code></p> <p>Commen\u00e7ons par pr\u00e9senter le processeur i8080 du point de vue de son mode de fonctionnement. Nous ne rentrerons pas dans les d\u00e9tails de l'architecture mat\u00e9rielle de ce processeur.</p>"},{"location":"i8080/architecture/#1-composants-du-processeur","title":"1. Composants du processeur","text":"<p>Voici un sch\u00e9ma des principaux composants d'un processeur i8080 (en jaune):</p> <pre><code>block-beta\n  columns 3\n  block:cpu:3\n      columns 3\n      block\n          columns 1\n          alu[\\\"Unit\u00e9 arithm\u00e9tique et logique (ALU)\"/]\n          control[[\"Unit\u00e9 de contr\u00f4le\"]]\n          decode([\"D\u00e9codeur d'instructions\"])\n      end\n      block:reg\n        columns 2\n        a[\"Accumulateur (A)\"] f[\"Flags\"] b[\"B\"] c[\"C\"] d[\"D\"] e[\"E\"] h[\"H\"] l[\"L\"]\n      end\n      block:pcsp\n        columns 2\n        sp[\"Stack pointer\"]:1\n        pc[\"Program counter\"]:1\n      end\n  end\n  blockArrowId6&lt;[\"Bus de donn\u00e9es\"]&gt;(up, down)\n  space\n  blockArrowId4&lt;[\"Bus d'adresses\"]&gt;(down)\n  mem[\"M\u00e9moire 64kio (programmes + donn\u00e9es)\"]:3\n  io[(\"P\u00e9riph\u00e9riques E/S\")]:3\n  style mem fill:#bbf,stroke:blue\n  style io fill:#bfb,stroke:green</code></pre> <p>\u00c0 l'interieur d'un processeur i8080, on trouve :</p> <ol> <li>Les registres : Ce sont des m\u00e9moires tr\u00e8s rapides qui servent \u00e0 stocker les valeurs qui vont \u00eatre manipul\u00e9es par le proceseur. Ils sont au nombre de 10. Parmi ces registres, deux jouent un r\u00f4le particulier : PC qui contient l'adresse de l'instruction en cours d'ex\u00e9cution, et SP qui contient l'adresse du sommet de la pile d'ex\u00e9cution (nous expliquerons tout cela par la suite).<ul> <li>Registre A (8 bits) : ce registre particulier est appel\u00e9 accumulateur</li> <li>Registre B (8 bits)</li> <li>Registre C (8 bits)</li> <li>Registre D (8 bits)</li> <li>Registre E (8 bits)</li> <li>Registre H (8 bits)</li> <li>Registre L (8 bits)</li> <li>Registre PC program counter (16 bits)</li> <li>Registre SP stack pointer (16 bits)</li> </ul> </li> <li>L'unit\u00e9 arithm\u00e9tique et logique (ALU) : un ensemble de circuits qui permet d'effectuer certains calculs, l'i8080 est capable d'effectuer des additions, des soustractions, des d\u00e9calages binaires, et des op\u00e9rations logiques bit \u00e0 bit : le AND, le OR et le XOR (ou exclusif), et c'est tout...</li> <li>Les flags (drapeaux) aussi appel\u00e9s conditions : ce sont des valeurs binaires qui servent \u00e0 donner des informations sur les r\u00e9sultats des calculs effectu\u00e9s, ils sont au nombre de 5 :<ul> <li>Sign (S) : signe</li> <li>Zero (Z) : z\u00e9ro</li> <li>Auxiliary carry (AC) : retenue auxiliaire</li> <li>Parity (P) : parit\u00e9</li> <li>Carry (CY) : retenue</li> </ul> </li> <li>La m\u00e9moire : le processeur est reli\u00e9 \u00e0 la m\u00e9moire de l'ordinateur par un bus de donn\u00e9es de 8 bits et un bus d'adresses de 16 bits : cela signifie qu'on dispose de \\(2^{16}\\) adresses et que chaque adresse repr\u00e9sente 1 octet de la m\u00e9moire. Le processeur i8080 est ainsi capable de travailler avec une m\u00e9moire de 64kio. </li> <li>Entr\u00e9es / Sorties : le processeur est capable d'envoyer ou recevoir un octet \u00e0 un p\u00e9riph\u00e9rique de l'ordinateur, chaque p\u00e9riph\u00e9rique est rep\u00e9r\u00e9 par un num\u00e9ro de port unique cod\u00e9 aussi sur 8 bits, on peut donc en th\u00e9orie brancher jusqu'\u00e0 256 p\u00e9riph\u00e9riques I/O sur le processeur.</li> <li>Une unit\u00e9 de contr\u00f4le : un composant charg\u00e9 d'orchestrer l'ex\u00e9cution du processeur, elle contient en particulier un d\u00e9codeur capable de lire le langage machine et d\u00e9terminer quelles instructions doivent \u00eatre ex\u00e9cut\u00e9es.</li> </ol> <p>Voici un autre sch\u00e9ma, tir\u00e9 du manuel utilisateur de l'Intel 8080, qui montre comment les 40 pins du proceseur sont connect\u00e9es avec l'ext\u00e9rieur. On y retrouve, l'alimentation l'\u00e9lectrique, le bus d'adresse, le bus de donn\u00e9es, l'horloge (entr\u00e9es \\(\\Phi_1\\) et \\(\\Phi_2\\)) qui cadence le processeur \u00e0 2Mhz, et d'autres entr\u00e9es/sorties de contr\u00f4le que je ne d\u00e9taille pas. Toutes les connexions de la partie droite du sch\u00e9ma vont vers le p\u00e9riph\u00e9rique m\u00e9moire de l'ordinateur.</p>  Interface du i8080 (source : manuel Intel 8080)  <p>Avec ces informations, on peut d\u00e9j\u00e0 commencer par d\u00e9finir des types en C pour repr\u00e9senter un ordinateur contenant un processeur i8080.</p> computer.h<pre><code>#ifndef COMPUTER_H\n#define COMPUTER_H\n\n#include &lt;stdint.h&gt;\n\nstruct cpu_s {\n    uint8_t regA;\n    uint8_t regB;\n    uint8_t regC;\n    uint8_t regD;\n    uint8_t regE;\n    uint8_t regH;\n    uint8_t regL;\n    uint16_t pc;\n    uint16_t sp;\n    uint8_t flags; // Pour m\u00e9moriser les 5 flags\n};\ntypedef struct cpu_s Cpu;\n\nstruct computer_s {\n    Cpu cpu;\n    uint8_t mem[65536];\n};\ntypedef struct computer_s Computer;\n\nextern void comp_init(Computer *comp);\n\n#endif\n</code></pre> <p>Noter que dans un processeur 8080 r\u00e9el, il n'y a pas de registre 8-bit nomm\u00e9 FLAGS. Nous d\u00e9cidons ici de coder l'ensemble des flags sur un octet, ce qui sera pratique quand on voudra g\u00e9n\u00e9rer le Program Status Word (PSW) (voir plus loin).</p> <p>Exercice</p> <p>\u00c9crire dans le fichier <code>computer.c</code> ci-dessous l'impl\u00e9mentation de la fonction <code>comp_init</code>. Cette fonction initialisera toute la m\u00e9moire de l'ordinateur \u00e0 la valeur <code>0</code>. Elle initialisera le registre <code>PC</code> \u00e0 la valeur <code>0x0000</code> (premi\u00e8re adresse m\u00e9moire) et le registre <code>SP</code> \u00e0 la valeur <code>0xFFFF</code> (derni\u00e8re adresse m\u00e9moire). computer.c<pre><code>#include &lt;stdint.h&gt;\n#include \"computer.h\"\n\nvoid comp_init(Computer *comp) {\n    /// A COMPLETER\n}\n</code></pre> On pourra tester que ce code compile avec : <pre><code>gcc -c computer.c\n</code></pre></p>"},{"location":"i8080/architecture/#2-rappels-sur-la-representation-binaire","title":"2. Rappels sur la repr\u00e9sentation binaire","text":"<p>Vous l'aurez compris, notre \u00e9mulateur va intensivement manipuler des valeurs cod\u00e9es sur 8 ou 16 bits et il faudra \u00eatre \u00e0 l'aise avec les r\u00e9pr\u00e9sentations binaires pour s'en sortir. Je fais ici quelques rappels, en cas de doutes r\u00e9f\u00e9rez-vous \u00e0 votre cours de MP2I.</p> <p>Le type <code>uint8_t</code> repr\u00e9sente une valeur enti\u00e8re non sign\u00e9e cod\u00e9e sur exactement 8 bits. Ainsi les valeurs possibles pour un type <code>uint8_t</code> sont :</p> Base Plus petite valeur Plus grande valeur 10 <code>0</code> \\(2^8 - 1\\) = <code>255</code> 2 <code>0b00000000</code> <code>0b11111111</code> 16 <code>0x00</code> <code>0xFF</code> <p>Remarquez l'utilisation du pr\u00e9fixe <code>0b</code> pour indiquer que la valeur litt\u00e9rale qui suit est cod\u00e9e en base 2, et le pr\u00e9fixe <code>0x</code> pour la base 16. Ces pr\u00e9fixes peuvent bien \u00e9videmment \u00eatre utilis\u00e9s en langage C.</p> <p>Le type <code>uint16_t</code> repr\u00e9sente une valeur enti\u00e8re non sign\u00e9e cod\u00e9e sur exactement 16 bits. Ainsi les valeurs possibles pour un type <code>uint16_t</code> sont :</p> Base Plus petite valeur Plus grande valeur 10 <code>0</code> \\(2^{16} - 1\\) = <code>65535</code> 2 <code>0b0000000000000000</code> <code>0b1111111111111111</code> 16 <code>0x0000</code> <code>0xFFFF</code> <p>La repr\u00e9sentation hexad\u00e9cimale est la plus pratique car elle est compacte tout en conservant une correspondance avec la repr\u00e9sentation binaire : = chaque chiffre hexad\u00e9cimal correspond \u00e0 4 bits de l'entier cod\u00e9 (ce n'est pas le cas avec la base 10...) :</p> Chiffre hexad\u00e9cimal Bits Chiffre hexad\u00e9cimal Bits 0 0000 8 1000 1 0001 9 1001 2 0010 A 1010 3 0011 B 1011 4 0100 C 1100 5 0101 D 1101 6 0110 E 1110 7 0111 F 1111 <p>Ainsi si on veut \u00e9crire la valeur binaire 16 bits suivante : <code>0b1111011100010001</code>, il sera plus commode d'utiliser la base hexad\u00e9cimale : <code>0xF711</code> </p> <p>Les valeurs de type <code>uint8_t</code> et <code>uint16_t</code> sont des entiers sign\u00e9s comme les autres et on peut utiliser les op\u00e9rations classiques sur les entiers. Par exemple on peut \u00e9crire en C : <pre><code>uint8_t val = 0x1a + 0b00111110 * 2;\n</code></pre> En cas de d\u00e9passement d'entier sur un calcul en <code>uint8_t</code>, tout se passe comme si on travaillait sur \\(\\mathbb{Z}/8\\mathbb{Z}\\) (de m\u00eame, sur \\(\\mathbb{Z}/16\\mathbb{Z}\\) pour <code>uint16_t</code>). </p>"},{"location":"i8080/architecture/#les-operateurs-de-decalage","title":"Les op\u00e9rateurs de d\u00e9calage","text":"<p>En langage C, l'op\u00e9rateur <code>&lt;&lt;</code> correspond \u00e0 un d\u00e9calage des bits d'un entier vers la gauche. La valeur de <code>n &lt;&lt; k</code> est obtenue en consid\u00e9rant \\(n\\) en binaire et en d\u00e9calant ses bits de \\(k\\) rangs vers la gauche. Par exemple, si on travaille sur <code>uint8_t</code> : <code>0b11001101 &lt;&lt; 3</code> donnera <code>0b01101000</code>. Ainsi, les 3 bits les plus forts ont \u00e9t\u00e9 perdus, tandis que 3 bits \u00e0 0 on \u00e9t\u00e9 introduits par la droite. Math\u00e9matiquement, cela revient \u00e0 multiplier par \\(2^k\\).</p> <p>De m\u00eame, il existe l'op\u00e9rateur <code>&gt;&gt;</code> qui d\u00e9cale les bits de la m\u00eame mani\u00e8re (en ins\u00e9rant des 0) mais vers la droite. Math\u00e9matiquement calculer <code>n &gt;&gt; k</code> revient \u00e0 effectuer la division enti\u00e8re de \\(n\\) par \\(2^k\\).</p> <p>Ces op\u00e9rateurs sont tr\u00e8s utiles lorsqu'on veut lire des bits particuliers d'un nombre ou \u00e0 l'inverse construire un nombre \u00e0 partir de ses bits. Par exemple si on poss\u00e8de un entier sur 4 bits <code>u</code> (not\u00e9 <code>uuuu</code> en base 2) cod\u00e9 sur <code>uint8_t</code> et un autre entier 4 bits <code>v</code> (not\u00e9 <code>vvvv</code> en base 2) et que l'on souhaite construire l'entier qui dont les bits sont <code>uuuuvvvv</code>, on \u00e9crira tout simplement <code>(u &lt;&lt; 4) + v</code>.</p>"},{"location":"i8080/architecture/#les-operateurs-logiques-bit-a-bit","title":"Les op\u00e9rateurs logiques bit \u00e0 bit","text":"<p>En C, on peut utiliser les 4 op\u00e9rateurs bit \u00e0 bit suivants :</p> Op\u00e9rateur Symbole Syntaxe NON bit \u00e0 bit ~ ~x ET bit \u00e0 bit &amp; x &amp; y OU bit \u00e0 bit | x | y XOR (ou exclusif) bit \u00e0 bit ^ x ^ y <p>Un op\u00e9rateur bit \u00e0 bit prend deux entiers <code>x</code> et <code>y</code> (un seul pour le NON) et forme un nouvel entier en appliquant la fonction logique correspondante sur les bits de la repr\u00e9sentation en base 2 de <code>x</code> et <code>y</code>. Par exemple, <code>17 &amp; 12 = 5</code> car :</p> bits 7 6 5 4 3 2 1 0 21 0 0 0 1 0 1 0 1 13 0 0 0 0 1 1 0 1 5 0 0 0 0 0 1 0 1 <p>Utilisation de masques binaires</p> <p>Une application particuli\u00e8rement utile de l'op\u00e9rateur <code>&amp;</code>, dont on se servira pour \u00e9crire le d\u00e9codeur, est l'application de masques binaires </p> <p>Supposons qu'on dispose d'un entier sur 8 bits que l'on \u00e9crira <code>a = a7 a6 a5 a4 a3 a2 a1 a0</code> et qu'on ne souhaite conserver que les bits <code>a4</code>, <code>a3</code> et <code>a2</code>. Cela est possible en calculant : <code>a &amp; 0b00011100</code> qui vaudra en base 2 : <code>0 0 0 a4 a3 a2 0 0</code>. La valeur <code>00011100</code> est un masque binaire qui en conjonction avec l'op\u00e9rateur <code>&amp;</code> permet de s\u00e9lectionner des bits qui nous int\u00e9ressent et d'annuler tous les autres.</p> <p>Une autre application int\u00e9ressante est le calcul de modulo par une puissance de 2. En effet, calculer <code>n % 8</code> par exemple correspond \u00e0 ne conserver que les 3 bits les plus \u00e0 droite de <code>n</code> (car \\(8 = 2^3\\)). Ceci peut \u00eatre calcul\u00e9 en temps constant par application d'un masque <code>n &amp; 0x07</code> (car <code>0x07 = 0b00000111</code>). </p>"},{"location":"i8080/architecture/#3-execution-dun-programme","title":"3. Ex\u00e9cution d'un programme","text":"<p>Le mode de fonctionnement d'un i8080 est tr\u00e8s simple. Le programme \u00e0 ex\u00e9cuter est cod\u00e9 en langage machine (binaire) dans la m\u00e9moire de l'ordinateur. Le registre PC (program counter) contient l'adresse m\u00e9moire de l'instruction \u00e0 ex\u00e9cuter.</p> <p>Une instruction peut \u00eatre cod\u00e9e sur 1 octet, 2 octets ou 3 octets selon le type d'instruction. Le processeur d\u00e9code l'instruction, lit le nombre d'octets n\u00e9cessaires pour cela, puis l'ex\u00e9cute. Cela a en g\u00e9n\u00e9ral pour effet de modifier les valeurs des registres et/ou des flags.</p> <p>Le processeur met ensuite \u00e0 jour son registre PC pour aller \u00e0 l'instruction suivante en m\u00e9moire (donc selon le type d'instructions on incr\u00e9mentera PC de 1, 2 ou 3).</p>"},{"location":"i8080/architecture/#langage-machine-et-jeu-dinstructions","title":"Langage machine et jeu d'instructions","text":"<p>Vous vous demandez sans doute comment le processeur fait pour savoir si l'instruction \u00e0 lire est cod\u00e9e sur 1, 2 ou 3 octets, mais aussi comment il fait pour savoir de quelle instruction il s'agit. C'est tr\u00e8s simple, le processeur commence par lire le premier octet (celui \u00e0 l'adresse PC) et selon la valeur lue, il peut d\u00e9terminer le type d'instruction.</p> <p>Voici quelques exemples :</p> <ul> <li>si la valeur est <code>0x00</code>, l'instruction lue est <code>NOP</code> : l'instruction qui ne fait rien. (C'est une instruction sur 1 octet).</li> <li>si la valeur est <code>0xD3</code>, l'instruction lue est <code>OUT</code> qui signifie envoyer le contenu du registre accumulateur sur le p\u00e9riph\u00e9rique de sortie. (C'est une instruction sur 2 octets, le 2e octet pr\u00e9cise le port)</li> <li>si la valeur est <code>0x81</code>, l'instruction lue est <code>ADD</code> qui signifie ajouter la valeur d'un registre dans l'accumulateur, quel registre ? Pour <code>0x81</code> il s'agit du registre C. En fait plusieurs valeurs correspondent \u00e0 des instructions de type <code>ADD</code> selon le registre source. De mani\u00e8re g\u00e9n\u00e9rale, une instruciton <code>ADD</code> a pour forme : <code>0x11001RRR</code> o\u00f9 <code>RRR</code> est une valeur sur 3 bits qui indique le registre \u00e0 utiliser, il ya donc 8 instructions de type <code>ADD</code> et on les note souvent <code>ADD A</code>, <code>ADD B</code>, <code>ADD H</code>, etc selon la valeur \u00e0 sommer.</li> </ul> <p>Il y a au total environ 80 types d'instructions diff\u00e9rentes sur un processeur 8080, c'est ce qu'on appelle son jeu d'instructions. Pour s'y retrouver, il faut lire attentativement la documentation :</p> <ul> <li>les manuels Intel (liens sur la page d'accueil)</li> <li>un tableau qui r\u00e9sume tout (mais qui ne dit pas tout) : Intel 8080 instruction set.</li> </ul> <p>Apprenez \u00e0 lire ce dernier tableau. On y retrouve beaucoup d'informations : le d\u00e9codage de chaque instruction d\u00e9j\u00e0, mais aussi le nombre d'octets de l'instruction, le nombre de cycles d'horloges n\u00e9cessaires pour l'ex\u00e9cuter, les flags affect\u00e9s par l'op\u00e9ration.</p> <p>Je donne un exemple de lecture : si le premier octet d'instruction est <code>0x16</code>, on lit dans le tableau que \u00e7a correspond \u00e0 la case <code>MVI B, d8 (2 7)</code>, ce qui signifie que c'est une instruction de type <code>MVI</code> sur 2 octets, qui va travailler avec le registre <code>B</code> et <code>d8</code>. <code>d8</code> signifie <code>data 8-bit</code> et repr\u00e9sente la valeur sur le 2e octet de l'instruction. Enfin le 7 signifie que l'instruction s'ex\u00e9cutera en 7 cycles processeur.</p> <p>Pour mener \u00e0 bien notre projet d'\u00e9mulation, il faudra donc d\u00e9j\u00e0 impl\u00e9menter en C chaque op\u00e9ration du jeu d'instructions, puis programmer la logique d'ex\u00e9cution (d\u00e9codage, ex\u00e9cution, mise \u00e0 jour du PC). Cela fait beaucoup d'instructions \u00e0 impl\u00e9menter mais je vais vous guider.</p>"},{"location":"i8080/carry/","title":"Les instructions du carry bit","text":"<p>Nouveaux fichiers : <code>carry.h</code> <code>carry.c</code></p> <p>On s'attaque maintenant \u00e0 la programmation des instructions du i8080. Pour chaque instruction du jeu d'instruction, on \u00e9crira dans le projet une fonction <code>void instr_XXX(Computer *comp)</code> o\u00f9 <code>XXX</code> est le nom de l'instruction programm\u00e9e. Cette fonction mettra \u00e0 jour <code>comp</code> en ex\u00e9cutant l'instruction <code>XXX</code>.</p> <p>Et le program counter ?</p> <p>Sauf mention du contraire, les fonctions <code>instr_XXX</code> ne s'occuperont pas de mettre \u00e0 jour le registre program counter (PC).</p> <p>Dans le manuel Intel, ces fonctions sont regroup\u00e9es par cat\u00e9gories :</p> <ul> <li>Les instructions du carry bit</li> <li>Les instructions \u00e0 registre unique : single register</li> <li>Les instructions de transfert de donn\u00e9es : data transfer</li> <li>Les instructions registre vers accumulateur</li> <li>Les instructions de d\u00e9calage : rotate</li> <li>Les instructions travaillant sur les paires de registres</li> <li>Les instructions imm\u00e9diates</li> <li>Les instructions \u00e0 adressage direct</li> <li>Les instructions de sauts, d'appels de routines et de retour</li> <li>Les instructions d'entr\u00e9es / sorties</li> <li>Les interruptions</li> </ul> <p>Je fais le choix de suivre le m\u00eame regroupement (donc le plus souvent une unit\u00e9 de compilation pour chaque cat\u00e9gorie), ce qui vous permettra aussi de vous r\u00e9f\u00e9rer plus facilement \u00e0 la section de manuel concern\u00e9e, si besoin.</p>"},{"location":"i8080/carry/#1-instructions-du-carry-bit","title":"1. Instructions du carry bit","text":"<p>Ici, on fait r\u00e9f\u00e9rence au drapeau carry (CY) qui sert \u00e0 indiquer une retenue dans un calcul.</p> <p>Le processeur i8080 propose 2 instructions pour le manipuler :</p> <ul> <li>STC (set carry) : set le flag CY</li> <li>CMC (complement carry) : compl\u00e9mente le flag CY, c'est-\u00e0-dire que s'il vaut 0 alors on le set, s'il vaut 1 alors on le reset.</li> </ul>"},{"location":"i8080/carry/#2-implementation","title":"2. Impl\u00e9mentation","text":"<p>Ajoutez le fichier d'en-t\u00eate suivant dans votre projet :</p> carry.h<pre><code>#ifndef CARRY_H\n#define CARRY_H\n\n#include \"computer.h\"\n\nextern void instr_cmc(Computer *comp);\nextern void instr_stc(Computer *comp);\n\n#endif\n</code></pre> <p>Exercice</p> <p>\u00c9crire dans un nouveau fichier <code>carry.c</code> les des deux fonctions :</p> <ol> <li><code>void instr_stc(Computer *comp)</code></li> <li><code>void instr_cmc(Computer *comp)</code></li> </ol> <p>qui impl\u00e9mentent STC et CMC respectivement.</p> <p>NB : Il vous faudra d\u00e9terminer les instructions <code>#include</code> \u00e0 utiliser, je ne les indiquerai plus syst\u00e9matiquement.</p> <p>Attention</p> <p>Les valeurs des flags sont modifi\u00e9es ou lues gr\u00e2ce \u00e0 nos fonctions set, reset et get d\u00e9finies pr\u00e9c\u00e9demment. C'est d'ailleurs pour cela qu'on les a d\u00e9finies. Cette remarque reste valable pour toute la suite du projet.</p> <p>Exercice</p> <ol> <li>Mettre \u00e0 jour le <code>Makefile</code> avec la nouvelle unit\u00e9 <code>carry</code>.</li> <li>Ajouter dans <code>main.c</code> quelques tests unitaires.</li> <li>Re-compiler l'ensemble du projet.</li> </ol> <p>Voil\u00e0 \u00e7a fait 2 instructions de faites, plus que 73...</p>"},{"location":"i8080/datatransfer/","title":"Les instructions de transfert","text":"<p>Nouveaux fichiers : <code>datatransfer.h</code> <code>datatransfer.c</code> <code>instr.h</code></p> <p>Fichiers modifi\u00e9s : <code>computer.h</code> <code>computer.c</code></p> <p>Les instructions de transfert de donn\u00e9es servent \u00e0 copier une donn\u00e9e sur 8 bits depuis un registre (ou la m\u00e9moire) vers un autre registre (ou la m\u00e9moire).</p> <p>Note</p> <p>Les instructions de cette section ne modifient aucun flag.</p>"},{"location":"i8080/datatransfer/#1-linstruction-mov-move","title":"1. L'instruction MOV (move)","text":"<p>L'instruction MOV est une instruction sur 1 octet qui a pour forme : <pre><code>    01DDDSSS\n</code></pre> Les trois bits <code>DDD</code> d\u00e9signent la destination et les trois bits <code>SSS</code> d\u00e9signent la source. Les sources et les destinations sont d\u00e9sign\u00e9es selon les conventions suivantes :</p> Source / Destination Code Registre B <code>000</code> Registre C <code>001</code> Registre D <code>010</code> Registre E <code>011</code> Registre H <code>100</code> Registre L <code>101</code> M\u00e9moire <code>110</code> Registre A <code>111</code> <p>Il y a donc possiblement 64 valeurs d'octet du langage machine qui correspondent \u00e0 une instruction MOV, c'est d'ailleurs pourquoi le tableau du jeu d'instructions est fourni en instructions MOV. Par exemple, l'instruction <code>0x6A = 0b 0110 1010 = 0b 01 101 010</code> correspond \u00e0 lire la donn\u00e9e situ\u00e9e dans le registre D et \u00e0 la copier (en \u00e9crasant) dans le registre L, ce que l'on notera plus pr\u00e9cis\u00e9ment MOV L,D.</p> <p>Attention</p> <p>Il est interdit d'avoir MEM \u00e0 la fois comme source et destination. Le code <code>0b01110110</code> est reserv\u00e9e pour une autre instruction (l'instruction HLT). Par contre tous les autres cas sont valides, m\u00eame si la source et la destination sont les m\u00eames.</p>"},{"location":"i8080/datatransfer/#les-paires-de-registres","title":"Les paires de registres","text":"<p>Lorsque la source ou la destination est la m\u00e9moire, l'adresse m\u00e9moire concern\u00e9e est celle indiqu\u00e9e par la paire de registres HL. Le registre H contient les 8 bits de poids fort de l'adresse (d'o\u00f9 son nom HIGH), tandis que le registre L contient les 8 bits de poids faible (d'o\u00f9 son nom LOW). Par exemple si H contient <code>0x4A</code> et L contient <code>0xB3</code>, l'adresse m\u00e9moire d\u00e9sign\u00e9e est <code>0x4AB3</code>.</p> <p>Ce processeur fonctionnera souvent ainsi, lorsqu'il veut repr\u00e9senter certaines valeurs sur 16 bits il utilise une paire de registres 8 bits pour la m\u00e9moriser. Les paires de registres utilis\u00e9es sont :</p> <ul> <li>Paire de registres HL : registre H + registre L</li> <li>Paire de registres BC : registre B + registre C</li> <li>Paire de registres DE : registre D + registre E</li> <li>Program status word PSW : registre A + flags</li> </ul> <p>Dans le dernier cas, <code>flags</code> d\u00e9signe l'octet qui repr\u00e9sente l'\u00e9tat des flags, dans le format que nous avons utilis\u00e9.</p> <p>Pour nous faciliter le travail dans ce projet, nous \u00e9crivons d\u00e8s \u00e0 pr\u00e9sent des petites fonctions pour lire la valeur 16 bit cod\u00e9e sur une paire de registres. Ajoutez les prototypes suivants \u00e0 <code>computer.h</code></p> computer.h<pre><code>extern uint16_t read_HL(Computer *comp);\nextern uint16_t read_BC(Computer *comp);\nextern uint16_t read_DE(Computer *comp);\nextern uint16_t read_PSW(Computer *comp);\n</code></pre> <p>Exercice</p> <p>Impl\u00e9mentez ces quatre fonctions dans <code>computer.c</code></p>"},{"location":"i8080/datatransfer/#implementation-de-linstruction","title":"Impl\u00e9mentation de l'instruction","text":"<p>Nous remarquons donc que contrairement aux instructions STC et CMC, nous avons cette fois besoin pour impl\u00e9menter MOV de conna\u00eetre l'octet de l'instruction en cours d'ex\u00e9cution afin d'en d\u00e9coder la source et la destination. Il faudra adapter notre prototype de fonction dans ce sens.</p> <p>Cr\u00e9er le fichier d'en-t\u00eate : datatransfer.h<pre><code>#ifndef DATATRANSFER_H\n#define DATATRANSFER_H\n\n#include \"computer.h\"\n#include &lt;stdint.h&gt;\n\n/* Ex\u00e9cute l'instruction MOV sur l'ordinateur comp.\n * instr est la valeur d'octet de l'instruction */\nextern void instr_mov(Computer *comp, uint8_t instr);\n\n#endif\n</code></pre> Nous ne voulons surtout pas non plus \u00e9crire directement dans notre programme les valeurs de codes registres du tableau ci-dessus. Cela nuirait grandement \u00e0 la lisibilit\u00e9 du programme et serait source d'erreurs. Nous allons plut\u00f4t d\u00e9finir des constantes dans un fichier <code>instr.h</code>. Ce fichier d'en-t\u00eate nous servira \u00e0 d\u00e9finir toutes les constantes qui concernent le jeu d'instructions i8080.</p> instr.h<pre><code>#ifndef INSTR_H\n#define INSTR_H\n\n// Constantes pour d\u00e9signer les registres ou la m\u00e9moire\n#define REGB 0b000\n#define REGC 0b001\n#define REGD 0b010\n#define REGE 0b011\n#define REGH 0b100\n#define REGL 0b101\n#define MEM  0b110\n#define REGA 0b111\n\n#endif\n</code></pre> <p>Exercice</p> <p>Dans un nouveau fichier <code>datatransfer.c</code>, \u00e9crire l'impl\u00e9mentation de la fonction <code>instr_mov</code>. Je vous conseille de proc\u00e9der ainsi :</p> <ol> <li>D\u00e9coder <code>instr</code> pour r\u00e9cup\u00e9rer les codes de source et de destination.</li> <li>En distinguant selon le cas du code de source, lire la valeur \u00e0 copier.</li> <li>En distinguant selon le cas du code de destination, \u00e9crire la valeur au bon emplacement.</li> </ol> <p>Il faudra aussi refuser le cas source = destination = MEM, par exemple avec un <code>assert</code>.</p>"},{"location":"i8080/datatransfer/#2-les-instructions-ldax-load-accumulator-et-stax-store-accumulator","title":"2. Les instructions LDAX (load accumulator) et STAX (store accumulator)","text":"<p>Comme leur nom l'indique, les instructions LDAX et STAX servent \u00e0 charger ou sauvegarder la valeur de l'accumulateur (registre A) dans la m\u00e9moire. Ces instructions ont le format suivant :</p> <pre><code>LDAX : 000X1010\nSTAX : 000X0010\n</code></pre> <p>Lorsque <code>X</code> vaut 0, l'adresse m\u00e9moire concern\u00e9e est donn\u00e9e par la paire de registres BC, sinon lorsque <code>X</code> vaut 1, l'adresse m\u00e9moire concern\u00e9e est donn\u00e9e par la paire de registres DE.</p> <p>Ajouter au fichier <code>datatransfer.h</code> les prototypes suivants : datatransfer.h<pre><code>extern void instr_ldax(Computer *comp, uint8_t instr);\nextern void instr_stax(Computer *comp, uint8_t instr);\n</code></pre> Remarquer encore une fois que le param\u00e8tre <code>instr</code> est utilis\u00e9 pour pouvoir r\u00e9cup\u00e9rer la valeur de <code>X</code>.</p> <p>Exercice</p> <p>Dans le fichier <code>datatransfer.c</code> impl\u00e9mentez les fonctions <code>instr_ldax</code> et <code>instr_stax</code>.</p> <p>Je vais le dire une derni\u00e8re fois (cela doit faire partie de votre boucle de travail) :</p> <ol> <li>Mettre \u00e0 jour le <code>Makefile</code> pour compiler <code>datatransfer.o</code></li> <li>Ajouter quelques tests dans <code>main.c</code></li> <li>Recompiler le projet et tester</li> </ol>"},{"location":"i8080/direct/","title":"Les instructions \u00e0 adressage direct","text":"<p>Nouveaux fichiers : <code>direct.h</code> <code>direct.c</code></p> <p>Une instruction \u00e0 adressage direct manipule une case m\u00e9moire dont l'adresse est donn\u00e9e directement dans l'instruction elle m\u00eame. C'est donc une instruction longue sur 3 octets :</p> <ul> <li>Le premier octet repr\u00e9sente le code d'instruction (utilis\u00e9 par le d\u00e9codeur d'instructions)</li> <li>Le deuxi\u00e8me octet repr\u00e9sente les 8 bits de poids faible de l'adresse concern\u00e9e</li> <li>Le troisi\u00e8me octet reper\u00e9sente les 8 bits de poids fort de l'adresse concern\u00e9e</li> </ul> <p>Il y a 4 instructions \u00e0 adressage direct :</p> <ul> <li>LDA (load accumlator direct) et STA (store accumulator direct) : charge ou sauvegarde une donn\u00e9e dans l'accumulateur</li> <li>LHLD (load HL direct) et SHLD (store HL direct) : charge ou sauvegarde une donn\u00e9e dans la paire de registres HL</li> </ul> <p>Par exemple : <pre><code>Instruction : 00110010     10011001      11110000\n              Code de STA  low_adr       high_adr\n\nInterpr\u00e9tation : sauvegarder la valeur de l'accumulateur \u00e0 l'adresse : 0b 11110000 10011001 = 0xF099\n</code></pre></p> <p>Attention</p> <p>Attention \u00e0 ne pas confondre avec LDAX et STAX que nous avons d\u00e9j\u00e0 d\u00e9finies dans <code>datatransfer</code>.</p> <p>Pour les instructions LHLD et SHLD, lorsqu'on sauvegarde ou restaure depuis la m\u00e9moire \u00e0 l'adresse adr (= high_adr.low_adr), on commence par traiter les bits de poids faibles (c'est-\u00e0-dire L) \u00e0 l'adresse adr, puis les bits de poids forts (c'est-\u00e0-dire H) \u00e0 l'adresse adr+1.</p>"},{"location":"i8080/direct/#1-implementation","title":"1. Impl\u00e9mentation","text":"<p>Tout cela se traduit par le fichier d'en-t\u00eate suivant : direct.h<pre><code>#ifndef DIRECT_H\n#define DIRECT_H\n\n#include \"computer.h\"\n#include &lt;stdint.h&gt;\n\nextern void instr_lda(Computer *comp, uint8_t low_adr, uint8_t high_adr);\nextern void instr_sta(Computer *comp, uint8_t low_adr, uint8_t high_adr);\nextern void instr_lhld(Computer *comp, uint8_t low_adr, uint8_t high_adr);\nextern void instr_shld(Computer *comp, uint8_t low_adr, uint8_t high_adr);\n\n#endif\n</code></pre></p> <p>Exercice</p> <p>Dans un nouveau fichier direct.c, proposez une impl\u00e9mentation de ces 4 instructions.</p> <p>Attention</p> <p>Aucun flag n'est modifi\u00e9 par ces instructions.</p>"},{"location":"i8080/flags/","title":"Les flags","text":"<p>Nouveaux fichiers : <code>flags.h</code> <code>flags.c</code> Fichiers modifi\u00e9s: <code>computer.c</code></p> <p>Dans la section pr\u00e9c\u00e9dente, nous avons expliqu\u00e9 que le processeur garde en m\u00e9moire 5 \u00e9tats binaires appel\u00e9s flags. Ces flags sont :</p> <ul> <li>Sign (S) : signe</li> <li>Zero (Z) : z\u00e9ro</li> <li>Auxiliary carry (AC) : retenue auxiliaire</li> <li>Parity (P) : parit\u00e9</li> <li>Carry (CY) : retenue</li> </ul> <p>Chaque flag poss\u00e8de une valeur binaire 0 ou 1. Selon la terminologie Intel, l'op\u00e9ration set sur un flag consiste \u00e0 mettre sa valeur \u00e0 1, tandis que l'op\u00e9ration reset consiste \u00e0 mettre sa valeur \u00e0 0. Nous allons impl\u00e9menter ici ces op\u00e9rations ce qui nous permettra de nous familiariser en douceur avec les op\u00e9rations bit \u00e0 bit.</p> <p>Dans notre impl\u00e9mentation, nous avons d\u00e9cid\u00e9 d'enregistrer la valeur de ces 5 flags dans un seul octet (champ <code>flag</code> de la structure <code>Cpu</code>). Les bits de cet octet seront d\u00e9finis selon le format suivant :</p> 7 6 5 4 3 2 1 0 S Z 0 AC 0 P 1 CY <p>Noter que les bits 1, 3 et 5 seront toujours fix\u00e9s \u00e0 des valeurs pr\u00e9cises (1, 0 et 0 respectivement). Pourquoi ce format ? Tout simplement car certaines op\u00e9rations du processeur permettent de lire l'ensemble des flags sous forme d'un octet avec ce format pr\u00e9cis\u00e9ment. En adoptant la m\u00eame convention que le processeur, on s'\u00e9conomise du travail par la suite. </p> <p>Exercice (\u00e0 faire !)</p> <p>Compl\u00e9ter la fonction <code>comp_init</code> d\u00e9finie \u00e0 la partie pr\u00e9c\u00e9dente pour qu'elle initialise correctement la valeur de <code>flags</code>. On consid\u00e9rera qu'initialement tous les flags sont \u00e0 la valeur 0.</p>"},{"location":"i8080/flags/#1-fonctions-dacces-aux-flags","title":"1. Fonctions d'acc\u00e8s aux flags","text":"<p>Nous allons maintenant programmer les fonctions set et reset qui permettent la manipulation des flags, ainsi qu'une op\u00e9ration get qui nous permet de lire la valeur d'un flag.</p> <p>Nous programmons les fonctions qui concernent les flags, dans une unit\u00e9 de compilation sp\u00e9cifique. On cr\u00e9\u00e9 donc le fichier <code>flags.h</code> que je donne dans son int\u00e9gralit\u00e9 :</p> Fichier d'en-t\u00eate <code>flags.h</code> flags.h<pre><code>#ifndef FLAGS_H\n#define FLAGS_H\n\n#include &lt;stdbool.h&gt;\n#include \"computer.h\"\n\n/* Format du pseudo-registre flags :\n * S Z 0 AC 0 P 1 CY\n *\n * S = Sign\n * Z = Zero\n * AC = Auxiliary carry\n * P = Parity\n * CY = Carry\n */\n\n/* Fonction d'acc\u00e8s aux flags */\n\nextern void set_flag_s(Computer *comp);\nextern void reset_flag_s(Computer *comp);\nextern bool get_flag_s(Computer *comp);\n\nextern void set_flag_z(Computer *comp);\nextern void reset_flag_z(Computer *comp);\nextern bool get_flag_z(Computer *comp);\n\nextern void set_flag_ac(Computer *comp);\nextern void reset_flag_ac(Computer *comp);\nextern bool get_flag_ac(Computer *comp);\n\nextern void set_flag_p(Computer *comp);\nextern void reset_flag_p(Computer *comp);\nextern bool get_flag_p(Computer *comp);\n\nextern void set_flag_cy(Computer *comp);\nextern void reset_flag_cy(Computer *comp);\nextern bool get_flag_cy(Computer *comp);\n\n/* Fonctions pratiques pour d\u00e9finir correctement\n * les flags S, Z, et P */\n\nextern void update_flag_s(Computer *comp, uint8_t val);\nextern void update_flag_z(Computer *comp, uint8_t val);\nextern void update_flag_p(Computer *comp, uint8_t val);\nextern void update_flags_szp(Computer *comp, uint8_t val);\n\n#endif\n</code></pre> <p>Impl\u00e9mentons maintenant ensemble les fonctions set, reset et get pour le flag AC (auxiliary carry) :</p> <p>flags.c<pre><code>#include &lt;stdbool.h&gt;\n#include \"computer.h\"\n\nvoid set_flag_ac(Computer *comp) {\n    comp-&gt;cpu.flags = comp-&gt;cpu.flags | 0b00010000;\n}\n\nvoid reset_flag_ac(Computer *comp) {\n    comp-&gt;cpu.flags = comp-&gt;cpu.flags &amp; 0b11101111;\n}\n\nbool get_flag_ac(Computer *comp) {\n    return ((comp-&gt;cpu.flags &amp; 0b00010000) &gt; 0);\n}\n</code></pre> Comprenez-vous ce code ? Pour set le flag AC, j'ai utilis\u00e9 un OU bit \u00e0 bit. Comme la valeur <code>0b00010000</code> contient un 1 au bit 4, et que x OU 1 vaut toujours 1, le bit 4 aura pour valeur 1 dans le r\u00e9sultat. C'est parfait car cela correspond au bit pour coder AC. Comme 0 est neutre pour le OU cela ne change pas les autres bits de <code>flags</code>.</p> <p>Pour le reset j'ai utilis\u00e9 une logique similaire mais cette fois-ci j'utilise un ET bit \u00e0 bit.</p> <p>Enfin pour le get, j'utilise un masque binaire pour observer uniquement le bit d'int\u00e9ret et je teste si le r\u00e9sultat est nul ou non.</p> <p>Exercice</p> <p>En suivant la m\u00eame m\u00e9thode, impl\u00e9menter les fonctions d'acc\u00e8s aux autres flags : S, Z, P et CY</p> <p>Remarque</p> <p>Comme les op\u00e9rations bit \u00e0 bit se font \u00e0 co\u00fbt constant \\(O(1)\\), toutes les op\u00e9rations set, reset et get d\u00e9finies ainsi auront aussi un co\u00fbt constant.</p>"},{"location":"i8080/flags/#2-mise-a-jour-des-flags","title":"2. Mise \u00e0 jour des flags","text":"<p>Nous allons maintenant nous int\u00e9resser \u00e0 la signification pr\u00e9cise des flags Z, S et P.</p>"},{"location":"i8080/flags/#a-le-flag-zero-z","title":"A. Le flag zero (Z)","text":"<p>Lorsque le processeur ex\u00e9cute certaines instructions, si le r\u00e9sultat du calcul est 0 alors le flag Z est set, sinon il est reset. Pour mettre \u00e0 jour le flag zero en fonction d'une valeur (<code>val</code>) de r\u00e9sultat de calcul on ajoute donc la fonction suivante dans <code>flags.c</code> :</p> flags.c<pre><code>(...)\n\nvoid update_flag_z(Computer *comp, uint8_t val) {\n    if (val == 0) {\n        set_flag_z(comp);\n    } else {\n        reset_flag_z(comp);\n    }\n}\n</code></pre>"},{"location":"i8080/flags/#b-le-flag-sign-s","title":"B. Le flag sign (S)","text":"<p>Le flag sign fait r\u00e9f\u00e9rence au bit de signe dans la repr\u00e9sentation par compl\u00e9ment \u00e0 2. En effet, vous savez qu'une valeur sur 8-bit peut \u00eatre utilis\u00e9e pour coder un entier sign\u00e9 repr\u00e9sentant une valeur entre \\(-128\\) et \\(127\\) \u00e0 l'aide de la m\u00e9thode du compl\u00e9ment \u00e0 2.</p> <p>Rappel sur le compl\u00e9ment \u00e0 2</p> <p>Pour coder une valeur \\(x\\) comprise entre \\(-128\\) et \\(127\\) sur un octet.</p> <ul> <li> <p>Si x est positif ou nul : on le code normalement : par exemple \\(x = 70 = 64 + 4 + 2\\) sera cod\u00e9 <code>0b01000110</code></p> </li> <li> <p>Si x est strictement n\u00e9gatif : par exemple \\(x = -3\\), on commence par coder 3 normalement (<code>0b00000011</code>), puis on inverse les bits (<code>0b11111100</code>), enfin on ajoute 1 au r\u00e9sultat et on obtient <code>0b11111101</code></p> </li> </ul> <p>Cette repr\u00e9sentation, permet d'utiliser les m\u00eames circuits que l'addition pour calculer une soustraction. En effet, pour calculer \\(70 - 3\\), on calcule simplement \\(70 + (-3)\\), ce qui fonctionne avec cette repr\u00e9sentation : <code>0b01000110 + 0b11111101 = 0b01000011</code> qui vaut bien 67 !</p> <p>De plus on remarque que dans le premier cas (\\(x \\geq 0\\)), le bit de poids fort (bit 7) vaut toujours 0, et dans le second cas (\\(x &lt; 0\\)) il vaut toujours 1. Cet bit est donc appel\u00e9 bit de signe, il permet imm\u00e9diatement de savoir si la valeur sign\u00e9e cod\u00e9e est positive ou n\u00e9gative. </p> <p>Pour r\u00e9sumer, le flag S doit \u00eatre reset si le bit de poids fort du r\u00e9sultat est 0 et il doit \u00eatre set si le bit de poids de fort est 1.</p> <p>Exercice</p> <p>\u00c9crire l'impl\u00e9mentation de la fonction <code>update_flag_s</code></p>"},{"location":"i8080/flags/#c-le-flag-parity-p","title":"C. Le flag parity (P)","text":"<p>Le flag parity (P) est set s'il y a un nombre pair de bits ayant pour valeur 1 dans le r\u00e9sultat, sinon il reset. Par exemple si la valeur du r\u00e9sultat est 5 qui se code <code>0b00000101</code> en binaire, parity vaudra 1 car il y a 2 bit 1 dans le r\u00e9sultat.</p> <p>Pi\u00e8ge</p> <p>Attention, le nom du flag est trompeur. Ce flag ne teste pas si le r\u00e9sultat d'un calcul est pair.</p> <p>Exercice</p> <p>\u00c9crire l'impl\u00e9mentation de la fonction <code>update_flag_p</code></p> <p>Exercice</p> <p>\u00c9crire l'impl\u00e9mentation de la fonction <code>update_flags_szp</code> qui met \u00e0 jour simultan\u00e9ment les flags S, Z et P en fonction d'un r\u00e9sultat de calcul.</p>"},{"location":"i8080/flags/#d-les-autres","title":"D. Les autres","text":"<p>Les autres flags (CY et AC) sont des bits de retenues utilis\u00e9s dans les calculs d'addition et de soustraction. Nous les verrons \u00e0 ce moment l\u00e0.</p>"},{"location":"i8080/immediate/","title":"Les instructions imm\u00e9diates","text":"<p>Nouveaux fichiers : <code>immediate.h</code> <code>immediate.c</code></p> <p>Fichiers modifi\u00e9s : <code>instr.h</code></p> <p>Les instructions imm\u00e9diates sont des instructions qui r\u00e9alisent leur tache en traitant des donn\u00e9es cod\u00e9es dans l'instruction elle-m\u00eame. Ces donn\u00e9es sont donc imm\u00e9diatement disponibles. Typiquement, ce sont des instructions sur 2 ou 3 octets : le premier octet d\u00e9crit l'op\u00e9ration \u00e0 effectuer et l'octet ou les octets suivants sont les donn\u00e9es \u00e0 traiter.</p> <p>Parmi ces instructions, on trouve :</p> <ul> <li>LXI (load register pair immediate) sur 3 octets : permet de charger une valeur 16-bit dans une paire de registre. Le premier octet indique que l'op\u00e9ration est LXI et donne la paire de registres. Les deux autres octets sont la valeur \u00e0 charger.</li> <li>MVI (move immediate data ) sur 2 octets : permet de charger une valeur dans un registre ou dans la m\u00e9moire. Le premier octet indique que l'op\u00e9ration est MVI et pr\u00e9cise le registre. Le second octet est la valeur \u00e0 charger.</li> <li>Les op\u00e9rations arithm\u00e9tiques et logiques (ADI, ACI, SUI, SBI, ANI, ORI, XRI, CPI), sur deux octets : le premier octet d\u00e9crit l'op\u00e9ration \u00e0 effectuer, le second octet d\u00e9crit la valeur \u00e0 utiliser. Par exemple ADI ajoute la valeur donn\u00e9e \u00e0 l'accumulateur (c'est l'\u00e9quivalent d'un <code>+=</code> en C).</li> </ul> <p>Bien s\u00fbr, pour impl\u00e9menter les op\u00e9rations arithm\u00e9tiques et logiques, nous nous servirons de nos fonctions <code>op_XXX</code> cod\u00e9es dans l'unit\u00e9 <code>alu</code>. Cela permettra \u00e9galement de mettre \u00e0 jour correctement les flags.</p> <p>On ajoute le fichier d'en-t\u00eate suivant : immediate.c<pre><code>#ifndef IMMEDIATE_H\n#define IMMEDIATE_H\n\n#include \"computer.h\"\n#include &lt;stdint.h&gt;\n\nvoid instr_lxi(Computer *comp, uint8_t instr, uint8_t low_data, uint8_t high_data);\nvoid instr_mvi(Computer *comp, uint8_t instr, uint8_t data);\nvoid instr_adi(Computer *comp, uint8_t data);\nvoid instr_aci(Computer *comp, uint8_t data);\nvoid instr_sui(Computer *comp, uint8_t data);\nvoid instr_sbi(Computer *comp, uint8_t data);\nvoid instr_ani(Computer *comp, uint8_t data);\nvoid instr_ori(Computer *comp, uint8_t data);\nvoid instr_xri(Computer *comp, uint8_t data);\nvoid instr_cpi(Computer *comp, uint8_t data);\n\n#endif\n</code></pre></p>"},{"location":"i8080/immediate/#1-instruction-lxi","title":"1. Instruction LXI","text":"<p>L'instruction LXI est cod\u00e9e sur trois octets, sert \u00e0 enregistrer une valeur donn\u00e9e dans une paire de registres. Elle a le format suivant : <pre><code>00RR0001    low_data(8 bits)    high_data(8 bits)\n</code></pre> o\u00f9 les deux bits <code>RR</code> servent \u00e0 pr\u00e9ciser la paire de registre avec les conventions suivantes :</p> <code>RR</code> Paire de registres (ou registre) <code>00</code> BC <code>01</code> DE <code>10</code> HL <code>11</code> SP <p>Remarquer que dans le dernier cas, il ne s'agit pas d'une paire de registres mais simplement du registre SP (Stack pointer). En effet, rappelez-vous que c'est un des deux seuls registres 16-bits du processeur et qu'il faut donc lui fournir une donn\u00e9e sur 16 bits.</p> <p>Pour \u00e9viter d'\u00e9crire \u00e0 la main dans le code ces constantes arbitraire, nous allons proprement ajouter les constantes ad\u00e9quates dans le fichier <code>instr.h</code> existant :</p> instr.h<pre><code>// Constantes pour les paires de registres \n\n#define PAIR_BC 0b00\n#define PAIR_DE 0b01\n#define PAIR_HL 0b10\n#define PAIR_SP Ob11\n</code></pre> <p>Enfin concernant la donn\u00e9e 16 bits \u00e0 enregistrer dans la paire de registres (ou SP), elle est cod\u00e9e sur les 2 octets <code>low_data</code> et <code>high_data</code>. <code>low_data</code> repr\u00e9sente les 8 bits de poids faible de la valeur et <code>high_data</code> les 8 bits de poids fort.</p> <p>Exercice</p> <p>Dans un nouveau fichier <code>immediate.c</code>, impl\u00e9menter la fonction <code>instr_lxi</code>. Pour cela il faudra :</p> <ol> <li>D\u00e9coder l'argument <code>instr</code> pour d\u00e9terminer la paire de registre (ou SP) \u00e0 modifier</li> <li>Enregistrer la valeur donn\u00e9e par <code>low_data</code> et <code>high_data</code> dans la paire de registres d\u00e9sign\u00e9e (ou SP)</li> </ol> <p>Remarquer que dans le cas de SP, il sera n\u00e9cessaire de reformer un entier 16 bits \u00e0 partir des deux entiers 8 bits donn\u00e9s.</p>"},{"location":"i8080/immediate/#2-instruction-mvi","title":"2. Instruction MVI","text":"<p>L'instruction MVI est comparable \u00e0 l'instruction LXI sauf qu'elle enregistre une valeur sur 8 bits au lieu d'une valeur sur 16 bits. Elle a pour forme : <pre><code>00RRR110    data(8 bits)\n</code></pre> Dans le premier octet, <code>RRR</code> d\u00e9signe le registre \u00e0 modifier avec exactement les m\u00eames conventions que pour l'instruction <code>MOV</code> d\u00e9j\u00e0 trait\u00e9e. On rappelle tout de m\u00eame les conventions :</p> Registre (ou m\u00e9moire) Code Registre B <code>000</code> Registre C <code>001</code> Registre D <code>010</code> Registre E <code>011</code> Registre H <code>100</code> Registre L <code>101</code> M\u00e9moire <code>110</code> Registre A <code>111</code> <p>Dans le cas de la valeur <code>110</code>, la donn\u00e9e ne sera pas enregistr\u00e9e dans un registre mais dans la m\u00e9moire de l'ordinateur. L'adresse m\u00e9moire \u00e0 utiliser sera alors celle pr\u00e9cis\u00e9e par la paire de registres HL.</p> <p>Nous rappelons \u00e9galement que toutes ces constantes sont d\u00e9j\u00e0 d\u00e9finies dans <code>instr.h</code> (<code>REGA</code>, ..., <code>REGL</code>, <code>MEM</code>).</p> <p>La donn\u00e9e \u00e0 enregistrer est tout simplement le second octet (<code>data</code>) de l'instruction.</p> <p>Exercice</p> <p>Dans le fichier <code>immediate.c</code>, impl\u00e9menter la fonction <code>instr_mvi</code>. Pour cela il faudra :</p> <ol> <li>D\u00e9coder l'argument <code>instr</code> pour d\u00e9terminer le registre \u00e0 modifier</li> <li>Dans le cas de <code>MEM</code> : r\u00e9cup\u00e9rer l'adresse stock\u00e9e dans HL.</li> <li>Enregistrer la valeur <code>data</code> au bon endroit.</li> </ol>"},{"location":"i8080/immediate/#3-les-instructions-arithmetiques-et-logiques-immediates","title":"3. Les instructions arithm\u00e9tiques et logiques imm\u00e9diates","text":"<p>Ce sont des instructions sur 2 octets ayant pour format : <pre><code>code instruction(8 bits)    data(8 bits)\n</code></pre> Le code d'instruction ne contient aucune donn\u00e9e donc nous n'auront pas besoin de le manipuler ici. Il sert simplement \u00e0 d\u00e9crire l'op\u00e9ration \u00e0 effectuer. Toutes ces op\u00e9rations s'accumulent dans le registre A (d'o\u00f9 son nom). Par exemple, ADI ajoute la valeur data dans le registre A. Ce sera donc le seul registre modifi\u00e9 par les op\u00e9rations ci-dessous.</p> <p>D\u00e9crivons maintenant chacune des op\u00e9rations. Dans le tableau ci-dessous je note \\(d\\) la valeur sur 8 bits \u00e0 manipuler et \\(A\\) le registre A.</p> Instruction Effet Description ADI \\(A \\gets A + d\\) Ajoute \\(d\\) dans l'accumulateur ACI \\(A \\gets A + d + 1\\) Ajoute \\(d\\) dans l'accumulateur avec une retenue d'entr\u00e9e SUI \\(A \\gets A - d\\) Soustrait \\(d\\) de l'accumulateur SBI \\(A \\gets A - d - 1\\) Soustrait \\(d\\) de l'accumulateur avec une retenue d'entr\u00e9e (emprunt) ANI \\(A \\gets A \\text{ AND } d\\) R\u00e9alise le ET bit \u00e0 bit de \\(A\\) et \\(d\\) ORI \\(A \\gets A \\text{ OR } d\\) R\u00e9alise le OU bit \u00e0 bit de \\(A\\) et \\(d\\) XRI \\(A \\gets A \\text{ XOR } d\\) R\u00e9alise le OU exclusif bit \u00e0 bit de \\(A\\) et \\(d\\) CPI \\(\\varnothing \\gets A - d\\) R\u00e9alise en interne la soustraction de \\(A\\) par \\(d\\) sans changer \\(A\\) (permet de comparer) <p>La derni\u00e8re op\u00e9ration m\u00e9rite une explication. Lorsqu'on ex\u00e9cute <code>CPI d</code> aucun registre n'est modifi\u00e9, cependant l'op\u00e9ration \\(A - d\\) est r\u00e9alis\u00e9e en interne et les drapeaux sont modifi\u00e9s par cette soustraction. On peut alors regarder ensuite :</p> <ul> <li>Le flag Z (Zero) : s'il est set les deux valeurs sont \u00e9gales, s'il est reset elles sont diff\u00e9rentes</li> <li>Le flag CY (Carry) : s'il est set c'est que \\(d &gt; A\\), s'il est reset c'est que \\(d \\leq A\\).</li> </ul> <p>On comprend maintenant le but de cette op\u00e9ration qui est de comparer deux valeurs.</p> <p>Attention</p> <p>Ce n'est plus \u00e0 vous de modifier les flags ici, ils se modifieront automatiquement par l'appel \u00e0 la fonction <code>op_sub</code></p> <p>Exercice</p> <p>Impl\u00e9menter dans <code>immediate.c</code> les instructions <code>instr_adi</code>, <code>instr_aci</code>, ..., <code>instr_cpi</code>. Pour cela :</p> <ul> <li>Chaque instruction fera un seul appel \u00e0 l'une des fonctions <code>op_XXX</code> de l'unit\u00e9 <code>alu</code>. Il faudra utiliser correctement les param\u00e8tres carry et borrow de <code>op_add</code> et <code>op_sub</code></li> <li>Enregistrer le r\u00e9sultat dans le registre A (sauf pour <code>CPI</code> bien s\u00fbr)</li> </ul> <p>Remarque</p> <p>Les appels de fonction <code>op_XXX</code> mettront correctement les drapeaux \u00e0 jour, on n'a pas \u00e0 s'en pr\u00e9occuper ici.</p>"},{"location":"i8080/makefile/","title":"Makefile et tests unitaires","text":"<p>Nouveaux fichiers : <code>Makefile</code> <code>main.c</code></p> <p>Le projet avance bien et comporte d\u00e9j\u00e0 plusieurs fichiers source. Le projet final en comportera bien davantage, il est donc temps de regrouper tous les fichiers <code>computer.c</code>, <code>computer.h</code>, <code>flags.h</code>, <code>flags.c</code> dans un m\u00eame r\u00e9pertoire (si ce n'est pas d\u00e9j\u00e0 fait) et d'y ajouter un fichier nomm\u00e9 <code>Makefile</code>. Le but de ce fichier est de permettre \u00e0 un outil nomm\u00e9 <code>make</code> de r\u00e9aliser en une seule commande la compilation ou la re-compilation du projet.</p>"},{"location":"i8080/makefile/#1-le-fichier-makefile","title":"1. Le fichier Makefile","text":"<p>Je vous donne une version de base du fichier <code>Makefile</code>, \u00e0 placer dans votre r\u00e9pertoire :</p> Makefile<pre><code># Nom du compilateur\nCC=gcc\n# Options du compilateur\nCFLAGS= -Wall -O2\n\n# Liste des unit\u00e9s de compilation :\nOBJ= computer.o flags.o\n\n.PHONY: clean # cibles fictives (ne correspond pas \u00e0 un fichier r\u00e9el)\n\n# cible principale (doit \u00eatre plac\u00e9e en premier dans le Makefile)\ni8080: $(OBJ) main.c\n    $(CC) $(CFLAGS) -o i8080 $(OBJ) main.c\n\n# cibles pour compiler les objets\n# la commande est toujours la m\u00eame, seules les d\u00e9pendances\n# sont \u00e0 d\u00e9finir. \n# NB: Le fichier source .c doit \u00eatre indiqu\u00e9 en dernier.\n\ncomputer.o: computer.h computer.c\n    $(CC) $(CFLAGS) -c $&lt;\n\nflags.o: computer.h flags.h flags.c\n    $(CC) $(CFLAGS) -c $&lt;\n\n# r\u00e8gle pour nettoyer et ne garder que les sources\nclean:\n    rm -f *.o\n    rm -f i8080\n</code></pre> <p>Le format g\u00e9n\u00e9ral d'un Makefile est le suivant : le fichier contient une liste de cibles qui sont des fichiers \u00e0 produire. Les cibles sont suivies d'un deux points <code>:</code>. Ici, les cibles sont <code>computer.o</code>, <code>flags.o</code> et <code>i8080</code>. Comme cette derni\u00e8re cible est plac\u00e9e en premier dans le fichier c'est ce fichier qui sera compil\u00e9 par d\u00e9faut.</p> <p>Une cible est suivie apr\u00e8s les <code>:</code> de la liste de ses d\u00e9pendances, c'est-\u00e0-dire des fichiers qui sont utilis\u00e9s dans la compilation pour produire la cible. Sous la cible, indent\u00e9e par une tabulation, on trouve la commande de compilation \u00e0 ex\u00e9cuter pour produire la cible. Par exemple, j'ai indiqu\u00e9 que le programme principal <code>i8080</code> a besoin de tous les fichiers objets <code>.o</code> (regroup\u00e9s dans une variable <code>OBJ</code>) et du fichier <code>main.c</code>. De m\u00eame, j'ai pr\u00e9cis\u00e9 que la compilation de <code>flags</code> d\u00e9pend de <code>computers.h</code> et <code>flags.h</code> car on fait des <code>#include</code> de ces en-t\u00eates, mais aussi du fichier <code>flags.c</code> \u00e9videmment.</p> <p>Attention : utilisation de <code>$&lt;</code></p> <p>La variable automatique <code>$&lt;</code> fait r\u00e9f\u00e9rence \u00e0 la derni\u00e8re d\u00e9pendance list\u00e9e. C'est pourquoi mes commandes de compilation ne sont correctes que si on a pris soin de placer le fichier source <code>.c</code> en dernier dans la liste de d\u00e9pendance. J'ai proc\u00e9d\u00e9 ainsi pour avoir toujours la m\u00eame commande de compilation pour chaque unit\u00e9. Je ne me pr\u00e9occupe alors que de la liste de d\u00e9pendances \u00e0 chaque fois.</p> <p>La cible <code>clean</code> est une fausse cible car elle ne produit aucun fichier. C'est pourquoi elle est marqu\u00e9e comme <code>.PHONY</code>. </p> <p>Utilisation de la commande Make</p> <p>Si le fichier <code>Makefile</code> est pr\u00e9sent dans le r\u00e9pertoire alors la commande <code>make</code> compile ou recompile l'ensemble du projet. De plus la commande <code>make clean</code> permet de nettoyer le r\u00e9pertoire en supprimant tous les fichiers compil\u00e9s et en ne gardant que les sources.</p>"},{"location":"i8080/makefile/#2-tests-unitaires","title":"2. Tests unitaires","text":"<p>Normalement, si vous tapez maintenant <code>make</code>, vous obtiendrez une erreur : <code>make: don't know how to make main.c. Stop</code>. Le programme <code>make</code> se plaint de ne pas pouvoir compiler le projet car il ne sait pas comment produire le fichier <code>main.c</code>. Pas \u00e9tonnant : c'est \u00e0 nous de produire ce fichier, il n'existe pas encore.</p> <p>\u00c9crivons le fichier <code>main.c</code> qui contiendra la fonction <code>main</code> (point d'entr\u00e9e de tout programme C). Pour l'instant on se contentera d'ex\u00e9cuter quelques tests unitaires. Le but d'un test unitaire est de tester le bon fonctionnement d'une fonction ou d'un petit ensemble de fonctions, ind\u00e9pendemment de tout le reste du projet. </p> main.c<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;assert.h&gt;\n\n#include \"computer.h\"\n#include \"flags.h\"\n\nvoid test_flags() {\n    Computer comp;\n    comp_init(&amp;comp);\n\n    assert(get_flag_z(&amp;comp) == false);\n    assert(get_flag_s(&amp;comp) == false);\n    assert(get_flag_p(&amp;comp) == false);\n    assert(get_flag_cy(&amp;comp) == false);\n    assert(get_flag_ac(&amp;comp) == false);\n\n    update_flags_szp(&amp;comp, 0b10011001);\n    assert(get_flag_z(&amp;comp) == false);\n    assert(get_flag_s(&amp;comp) == true);\n    assert(get_flag_p(&amp;comp) == true);\n\n    // A COMPLETER AVEC D'AUTRES TESTS\n}\n\nvoid test_all() {\n    printf(\"Tests du module flags...\\n\");\n    test_flags();\n\n    // A COMPLETER AVEC D'AUTRES TESTS\n}\n\nint main(int argc, char *argv[]) {\n    test_all();\n    return EXIT_SUCCESS;\n}\n</code></pre> <p>Voil\u00e0, maintenant <code>make</code> devrait fonctionner et produire un ex\u00e9cutable <code>i8080</code>. Si cet ex\u00e9cutable ne produit aucune erreur <code>assert</code> alors tous les tests ont fonctionn\u00e9 !</p> <p>\u00c9crivez des tests !</p> <p>Dans toute la suite, je n'\u00e9crirai pas forc\u00e9ment des tests unitaires pour les fonctions propos\u00e9es. Cependant, je vous encourage vivement \u00e0 le faire ! En particulier, si vous constatez que votre programme ne compile pas ou ne marche pas correctement et que vous n'arrivez pas \u00e0 savoir pourquoi, alors \u00e9crivez et ex\u00e9cutez des tests unitaires !</p>"},{"location":"i8080/makefile/#3-faire-croitre-le-projet","title":"3. Faire cro\u00eetre le projet","text":"<p>Dans la suite, on fera petit \u00e0 petit cro\u00eetre le projet en y ajoutant des unit\u00e9s de compilation. \u00c0 chaque fois que \u00e7a sera le cas, il faudra :</p> <ol> <li>Ajouter le fichier objet <code>fichier.o</code> dans la liste <code>OBJ</code></li> <li>Ajouter une cible <code>fichier.o : d\u00e9pendances fichier.c</code></li> <li>Sous la r\u00e8gle indiquer la commande de compilation (c'est la m\u00eame pour toutes les unit\u00e9s) : <code>$(CC) $(CFLAGS) -c $&lt;</code> (on n'oublie pas la tabulation devant la commande).</li> </ol> <p>En proc\u00e9dant ainsi, les compilations et recompilations seront nettement facilit\u00e9es. En particulier <code>make</code> d\u00e9termine automatiquement quel(s) fichier(s) doivent \u00eatre recompil\u00e9s et dans quel ordre.</p>"},{"location":"i8080/regtoacc/","title":"Les instructions registre vers accumulateur","text":"<p>Nouveaux fichiers : <code>regtoacc.h</code> <code>regtoacc.c</code></p> <p>Les instructions registre vers accumulateur sont similaires aux instructions arithm\u00e9tiques et logiques imm\u00e9diates. La diff\u00e9rence est que la donn\u00e9e \u00e0 utiliser est cette fois localis\u00e9e dans un registre (ou la m\u00e9moire). Les op\u00e9rations sont les m\u00eames.</p>"},{"location":"i8080/regtoacc/#1-descrition-des-instructions","title":"1. Descrition des instructions","text":"<p>Les instructions de cette section mesurent un seul octet qui a pour forme : <pre><code>01XXXRRR\n</code></pre> o\u00f9 <code>XXX</code> est un code d\u00e9signant le type d'op\u00e9ration (inutile dans cette section du tutoriel) et <code>RRR</code> est le code pr\u00e9cisant le registre (ou la m\u00e9moire) dans lequel on lit la donn\u00e9e. On utilise les conventions habituelles d\u00e9j\u00e0 d\u00e9finies dans <code>instr.h</code> \u00e0 savoir :</p> Registre (ou m\u00e9moire) Code Registre B <code>000</code> Registre C <code>001</code> Registre D <code>010</code> Registre E <code>011</code> Registre H <code>100</code> Registre L <code>101</code> M\u00e9moire <code>110</code> Registre A <code>111</code> <p>Dans le cas de la valeur <code>110</code>, la donn\u00e9e ne sera pas lue depuis un registre mais depuis la m\u00e9moire de l'ordinateur. L'adresse m\u00e9moire \u00e0 utiliser sera alors celle pr\u00e9cis\u00e9e par la paire de registres HL.</p> <p>Voici la liste des 8 instructions registre vers accumulateur et leur description. On constate que ce sont les m\u00eames op\u00e9rations que les op\u00e9rations imm\u00e9diates sauf que la donn\u00e9e \\(d\\) est celle lue depuis le registre source (ou la m\u00e9moire).</p> Instruction Effet Description ADD \\(A \\gets A + d\\) Ajoute \\(d\\) dans l'accumulateur ADC \\(A \\gets A + d + 1\\) Ajoute \\(d\\) dans l'accumulateur avec une retenue d'entr\u00e9e SUB \\(A \\gets A - d\\) Soustrait \\(d\\) de l'accumulateur SBB \\(A \\gets A - d - 1\\) Soustrait \\(d\\) de l'accumulateur avec une retenue d'entr\u00e9e (emprunt) ANA \\(A \\gets A \\text{ AND } d\\) R\u00e9alise le ET bit \u00e0 bit de \\(A\\) et \\(d\\) ORA \\(A \\gets A \\text{ OR } d\\) R\u00e9alise le OU bit \u00e0 bit de \\(A\\) et \\(d\\) XRA \\(A \\gets A \\text{ XOR } d\\) R\u00e9alise le OU exclusif bit \u00e0 bit de \\(A\\) et \\(d\\) CMP \\(\\varnothing \\gets A - d\\) R\u00e9alise en interne la soustraction de \\(A\\) par \\(d\\) sans changer \\(A\\) (permet de comparer) <p>Ainsi CMP permet de comparer l'accumulateur avec n'importe quel autre registre (ou la m\u00e9moire). Il s'utilise comme CPI.</p>"},{"location":"i8080/regtoacc/#2-implementation","title":"2. Impl\u00e9mentation","text":"<p>Pour l'impl\u00e9mentation on ajoute le fichier d'en-t\u00eate suivant : regtoacc.c<pre><code>#ifndef REGTOACC_H\n#define REGTOACC_H\n\n#include \"computer.h\"\n#include &lt;stdint.h&gt;\n\nvoid instr_add(Computer *comp, uint8_t instr);\nvoid instr_adc(Computer *comp, uint8_t instr);\nvoid instr_sub(Computer *comp, uint8_t instr);\nvoid instr_sbb(Computer *comp, uint8_t instr);\nvoid instr_ana(Computer *comp, uint8_t instr);\nvoid instr_ora(Computer *comp, uint8_t instr);\nvoid instr_xra(Computer *comp, uint8_t instr);\nvoid instr_cmp(Computer *comp, uint8_t instr);\n\n#endif\n</code></pre> Remarquons que contrairement aux instructions imm\u00e9diates, nous avons ajout\u00e9 le param\u00e8tre <code>instr</code> qui est n\u00e9cessaire pour d\u00e9coder le registre source (ou la m\u00e9moire).</p> <p>Exercice</p> <p>Impl\u00e9menter dans un nouveau fichier <code>regtoacc.c</code> les instructions <code>instr_add</code>, <code>instr_adc</code>, ..., <code>instr_cmp</code>. Pour cela :</p> <ul> <li>Commencer par d\u00e9coder <code>instr</code> pour d\u00e9terminer la donn\u00e9e \\(d\\) \u00e0 utiliser</li> <li>Chaque instruction fera un seul appel \u00e0 l'une des fonctions <code>op_XXX</code> de l'unit\u00e9 <code>alu</code>. Il faudra utiliser correctement les param\u00e8tres carry et borrow de <code>op_add</code> et <code>op_sub</code></li> <li>Enregistrer le r\u00e9sultat dans le registre A (sauf pour <code>CMP</code> bien s\u00fbr)</li> </ul> <p>Remarque</p> <p>Les appels de fonction <code>op_XXX</code> mettront correctement les drapeaux \u00e0 jour, on n'a pas \u00e0 s'en pr\u00e9occuper ici.</p>"},{"location":"i8080/rotate/","title":"Les instructions de d\u00e9calage","text":"<p>Nouveaux fichiers : <code>rotate.h</code> <code>rotate.c</code></p> <p>Les instructions de d\u00e9calage sont appel\u00e9es rotations pour le 8080 et consistent \u00e0 d\u00e9caler les bits du registre accumulateur vers la gauche ou la droite, \u00e0 l'image des op\u00e9rateurs <code>&lt;&lt;</code> et <code>&gt;&gt;</code> en langage C. Vous savez qu'en programmation, les op\u00e9rateurs de d\u00e9calage ont un co\u00fbt constant et c'est justement gr\u00e2ce \u00e0 l'existence de circuits dans le processeur qui les r\u00e9alisent.</p> <p>Sur le Intel 8080, il existe 4 instructions de d\u00e9calage : RLC (rotate accumulator left), RRC (rotate accumulator right), RAL (rotate accumulator left through carry), RAR (rotate accumulator right through carry). Oui je ne me suis pas tromp\u00e9 dans les noms des instructions, c'est vrai qu'elles sont un peu trompeuses.</p>"},{"location":"i8080/rotate/#1-les-instructions-rlc-et-rrc","title":"1. Les instructions RLC et RRC","text":""},{"location":"i8080/rotate/#rlc","title":"RLC","text":"<p>L'instruction RLC (rotate accumulator left) correspond \u00e0 effectuer la rotation suivante : <pre><code>flowchart RL\n    subgraph acc[\"Registre A (accumulateur)\"]\n        a0 --&gt; a1\n        a1 --&gt; a2\n        a2 --&gt; a3\n        a3 --&gt; a4\n        a4 --&gt; a5\n        a5 --&gt; a6\n        a6 --&gt; a7\n        a7 --&gt; a0\n    end\n    a7 --&gt; CY\n    style CY fill:#bbf,stroke:blue</code></pre> Cela ressemble au <code>&lt;&lt;</code> du langage C, sauf que le bit de poids fort <code>a7</code> n'est pas perdu mais est d\u00e9plac\u00e9 en <code>a0</code>. Le flag de retenue <code>CY</code> est modifi\u00e9 pour prendre la valeur initiale de <code>a7</code></p> <p>Voici un exemple concret : <pre><code>            CY  Accumulateur\navant RLC : X   11101110\napr\u00e8s RLC : 1   11011101\n</code></pre></p>"},{"location":"i8080/rotate/#rrc","title":"RRC","text":"<p>L'instruction RRC (rotate accumulator right) est similaire \u00e0 RLC sauf qu'elle effectue le d\u00e9placement vers la droite : <pre><code>flowchart LR\n    subgraph acc[\"Registre A (accumulateur)\"]\n        a7 --&gt; a6\n        a6 --&gt; a5\n        a5 --&gt; a4\n        a4 --&gt; a3\n        a3 --&gt; a2\n        a2 --&gt; a1\n        a1 --&gt; a0\n        a0 --&gt; a7\n    end\n    a0 --&gt; CY\n    style CY fill:#bbf,stroke:blue</code></pre> Cette fois ci, le flag <code>CY</code> prend la valeur du bit de poids faible <code>a0</code>.</p> <p>Par exemple : <pre><code>            Accumulateur CY\navant RRC : 11101110     X\napr\u00e8s RRC : 01110111     0\n</code></pre></p>"},{"location":"i8080/rotate/#2-les-instructions-ral-et-rar","title":"2. Les instructions RAL et RAR","text":"<p>Les instructions RAL (rotate accumulator left through carry) et RAR (rotate accumulator right through carry) effectuent des rotations vers la gauche ou la droite comme RLC et RRC sauf que le bit du flag de retenue CY est inclus dans la rotation : on fait donc tourner un mot de 9 bits.</p>"},{"location":"i8080/rotate/#ral","title":"RAL","text":"<p>Voici sch\u00e9matiquement le fonctionnement de RAL : <pre><code>flowchart RL\n    subgraph acc[\"Registre A (accumulateur)\"]\n        a0 --&gt; a1\n        a1 --&gt; a2\n        a2 --&gt; a3\n        a3 --&gt; a4\n        a4 --&gt; a5\n        a5 --&gt; a6\n        a6 --&gt; a7\n        a7\n    end\n    a7 --&gt; CY\n    CY --&gt; a0\n    style CY fill:#bbf,stroke:blue</code></pre> La diff\u00e9rence avec RLC est que la nouvelle valeur de <code>a0</code> est cette fois l'ancienne valeur de <code>CY</code> (et non plus l'ancienne valeur de <code>a7</code>.</p> <p>Par exemple : <pre><code>            CY  Accumulateur\navant RAL : 0   11101110\napr\u00e8s RAL : 1   11011100\n</code></pre></p>"},{"location":"i8080/rotate/#rar","title":"RAR","text":"<p>De m\u00eame pour RAR, sauf que le flag CY est plac\u00e9 \u00e0 droite du registre A : <pre><code>flowchart LR\n    subgraph acc[\"Registre A (accumulateur)\"]\n        a7 --&gt; a6\n        a6 --&gt; a5\n        a5 --&gt; a4\n        a4 --&gt; a3\n        a3 --&gt; a2\n        a2 --&gt; a1\n        a1 --&gt; a0\n        a0\n    end\n    a0 --&gt; CY\n    CY --&gt; a7\n    style CY fill:#bbf,stroke:blue</code></pre> La diff\u00e9rence avec RRC est donc que la nouvelle valeur de <code>a7</code> est cette fois l'ancienne valeur de <code>CY</code> (et non plus l'ancienne valeur de <code>a0</code>).</p> <p>Par exemple : <pre><code>            Accumulateur CY\navant RAR : 11101110     1\napr\u00e8s RAR : 11110111     0\n</code></pre></p>"},{"location":"i8080/rotate/#3-implementation","title":"3. Impl\u00e9mentation","text":"<p>On ajoute le fichier d'en-t\u00eate suivant :</p> rotate.h<pre><code>#ifndef ROTATE_H\n#define ROTATE_H\n\n#include \"computer.h\"\n\nextern void instr_rlc(Computer *comp);\nextern void instr_rrc(Computer *comp);\nextern void instr_ral(Computer *comp);\nextern void instr_rar(Computer *comp);\n\n#endif\n</code></pre> <p>Exercice</p> <p>Dans un nouveau fichier <code>rotate.c</code>, \u00e9crire l'impl\u00e9mentation des 4 fonctions d\u00e9clar\u00e9es dans <code>rotate.h</code>. Comme expliqu\u00e9, ces fonctions agiront sur le registre A et le flag de retenue CY.</p> <p>Indication</p> <p>Bien s\u00fbr il faut impl\u00e9menter ces fonctions en se servant des op\u00e9rateurs <code>&gt;&gt;</code> et <code>&lt;&lt;</code> du langage C. Pensez simplement \u00e0 \"sauvegarder\" le bit perdu lors d'un tel d\u00e9calage.</p> <p>Au risque de me r\u00e9p\u00e9ter, \u00e0 chaque nouvelle unit\u00e9 de compilation :</p> <p>Exercice</p> <ol> <li>Mettre \u00e0 jour le <code>Makefile</code> pour pouvoir compiler <code>rotate.o</code>.</li> <li>Ajouter dans <code>main.c</code> quelques tests unitaires (par exemple les exemples propos\u00e9s ci-dessus)</li> <li>Re-compiler l'ensemble du projet et tester.</li> </ol>"},{"location":"ia/appr_supervise/","title":"Apprentissage supervis\u00e9","text":""},{"location":"ia/appr_supervise/#introduction","title":"Introduction","text":"<p>L'apprentissage automatique est un domaine majeur de l'intelligence articiel. Il consiste \u00e0 concevoir des algorithmes capables de reconna\u00eetre ou de classer certaines donn\u00e9es afin de pouvoir prendre automatiquement certaines d\u00e9cisions.</p> <p>Dans le cas de l'apprentissage supervis\u00e9 le processus se d\u00e9roule en 2 \u00e9tapes :</p> <ol> <li>Apprentissage : L'algorithme r\u00e9alise un pr\u00e9-traitement sur un ensemble de donn\u00e9es annot\u00e9es, c'est-\u00e0-dire d\u00e9j\u00e0 class\u00e9es</li> <li>Classement : On pr\u00e9sente ensuite une ou des donn\u00e9es non class\u00e9es \u00e0 l'algorithme qui va classer ces donn\u00e9es \u00e0 partir de ce qu'il a appris lors de la 1\u00e8re \u00e9tape.</li> </ol> <p>Plus pr\u00e9cis\u00e9ment, </p>"},{"location":"ia/appr_supervise/#1-donnees-discretes-binaires","title":"1. Donn\u00e9es discr\u00e8tes binaires","text":""},{"location":"ia/appr_supervise/#a-arbres-de-decision","title":"A. Arbres de d\u00e9cision","text":""},{"location":"ia/appr_supervise/#b-un-peu-de-theorie-de-linformation","title":"B. Un peu de th\u00e9orie de l'information","text":""},{"location":"ia/appr_supervise/#c-algorithme-id3","title":"C. Algorithme ID3","text":""},{"location":"ia/appr_supervise/#2-donnees-quantitatives","title":"2. Donn\u00e9es quantitatives","text":""},{"location":"ia/appr_supervise/#a-methode-des-k-plus-proches-voisins","title":"A. M\u00e9thode des k-plus proches voisins","text":""},{"location":"ia/appr_supervise/#b-arbres-de-recherche-k-dimensionnels","title":"B. Arbres de recherche k-dimensionnels","text":""},{"location":"itc/","title":"Ressources pour le cours d'informatique","text":""},{"location":"itc/#resumes-de-cours","title":"R\u00e9sum\u00e9s de cours","text":"<ol> <li>R\u00e9visions et compl\u00e9ments sur le langage Python</li> <li>Bases de donn\u00e9es</li> <li>Programmation dynamique</li> <li>Intelligence artificielle</li> </ol>"},{"location":"itc/#bases-de-donnees","title":"Bases de donn\u00e9es","text":"<ul> <li>Base de donn\u00e9e pizzeria</li> <li>Disquaire</li> <li>Lignes transport STAS</li> <li>M\u00e9t\u00e9o</li> <li>Bulletins</li> <li>Chinook</li> </ul>"},{"location":"itc/#travaux-pratiques","title":"Travaux pratiques","text":"<ul> <li>R\u00e9visions sur les listes</li> <li>R\u00e9visions sur les graphes [sujet] [fichier]</li> <li>SQL 1 : requ\u00eates, jointures</li> <li>SQL 2 : fonctions d'agr\u00e9gation</li> <li>Recherche de motif dans une s\u00e9quence ADN [sujet] [fiche r\u00e9ponse]</li> <li>Alignement optimal de s\u00e9quences ADN sujet fichier r\u00e9ponses</li> <li>D\u00e9tection de langue [sujet] [ressources]</li> </ul>"},{"location":"langages/automates/","title":"Automates finis","text":"<p>Dans le chapitre sur les langages r\u00e9guliers, nous avons d\u00e9fini les mots et les langages formels. Nous avons d\u00e9crit une certaine famille de langages appel\u00e9e langages r\u00e9guliers, qui sont d\u00e9crits par un motif appel\u00e9 expression r\u00e9guli\u00e8re.</p> <p>Une faiblesse des expressions r\u00e9guli\u00e8res est qu'il est a priori difficile d'\u00e9noncer un algorithme g\u00e9n\u00e9ral permettant de v\u00e9rifier si un mot \\(u\\) appartient au langage d\u00e9not\u00e9 par une expression r\u00e9guli\u00e8re. Le formalisme est expressif, facile \u00e0 utiliser de notre point de vue, mais difficile \u00e0 mettre en oeuvre sur une machine.</p> <p>Dans ce chapitre on introduit la notion d'automate est qui une machine simple permettant de reconna\u00eetre des mots, et donc des langages. Contrairement aux expressions r\u00e9guli\u00e8res, ce formalisme s'impl\u00e9mente facilement et efficacement sur un ordinateur.</p> <p>Les automates sont aussi tr\u00e8s importants en informatique car ils constitue un premier exemple de machine formelle, c'est-\u00e0-dire une repr\u00e9sentation abstraite d'une machine capable de calculer. L'exemple le plus c\u00e9l\u00e8bre de machine formelle est la machine de Turing mais pour bien la comprendre, il faut commencer par comprendre les automates.</p> <p>Dans tout ce chapitre, on se fixe un alphabet \\(\\Sigma\\) sur lequel on travaille.</p>"},{"location":"langages/automates/#1-automates-finis-deterministes","title":"1. Automates finis d\u00e9terministes","text":""},{"location":"langages/automates/#a-definition","title":"A. D\u00e9finition","text":"<p>Commen\u00e7ons par donner une vision intuitive de la machine que nous allons construire :</p> <ul> <li>un automate est une machine qui se situe \u00e0 tout moment dans un certain \u00e9tat; elle a un nombre fini d'\u00e9tats possibles;</li> <li>un automate prend en entr\u00e9e un mot qu'elle lit de gauche \u00e0 droite, lettre par lettre;</li> <li>lorsque l'automate est dans un \u00e9tat \\(q\\) et qu'il lit une lettre \\(c\\), alors il transite vers un \u00e9tat \\(\\delta(q, c)\\) qui ne d\u00e9pend que de l'\u00e9tat actuel \\(q\\) et de la lettre lue \\(c\\).</li> </ul> <p>Voici la d\u00e9finition formelle de cette machine :</p> <p>D\u00e9finition</p> <p>Un automate fini d\u00e9terministe (afd) est un quadruplet \\(A = (Q, q_0, F, \\delta)\\) o\u00f9 :</p> <ul> <li>\\(Q\\) est un ensemble fini d'\u00e9tats;</li> <li>\\(q_0 \\in Q\\) est un \u00e9tat particulier appel\u00e9 \u00e9tat initial;</li> <li>\\(F \\subset Q\\) est un ensemble d'\u00e9tats finaux;</li> <li>\\(\\delta : Q \\times \\Sigma \\to Q\\) est la fonction de transition de l'automate.</li> </ul> <p>La fonction de transition \\(\\delta\\) n'est pas n\u00e9cessairement d\u00e9finie sur \\(Q \\times \\Sigma\\) en entier, autrement dit, pour certains \u00e9tats \\(q\\) et certaines lettres \\(c\\), \\(\\delta(q, c)\\) peut ne pas \u00eatre d\u00e9fini. Dans ce cas, on dit que l'automate bloque \u00e0 la lecture de \\(c\\) dans l'\u00e9tat \\(q\\).</p> <p>Un automate se repr\u00e9sente plus volontier sous forme d'un graphe orient\u00e9, par exemple ainsi :</p> <p>Dans cette repr\u00e9sentation :</p> <ul> <li>les sommets du graphe repr\u00e9sentent les \u00e9tats de l'automate</li> <li>les arcs repr\u00e9sentent les transitions, l'\u00e9tiquette d'un arc est la lettre lue</li> <li>une fl\u00e8che entrante marque l'\u00e9tat initial</li> <li>un trait double entoure les \u00e9tats finaux</li> </ul> <p>Ainsi, dans cet exemple, l'automate repr\u00e9sent\u00e9 est \\(A = (Q, q_0, F, \\delta)\\) o\u00f9 :</p> <ul> <li>\\(Q = \\{q_0, q_1, q_2\\}\\)</li> <li>\\(q_0 = q_0\\)</li> <li>\\(F = \\{q_1, q_2\\}\\)</li> <li>\\(\\delta\\) est la fonction de transition que l'on peut repr\u00e9senter sous forme de table de transition de l'automate :</li> </ul> \u00e9tat \\(q\\) \u00a0lettre \\(c\\) \u00a0arriv\u00e9e \\(\\delta(q, c)\\) \\(q_0\\) \\(a\\) \\(q_0\\) \\(q_0\\) \\(b\\) \\(q_1\\) \\(q_1\\) \\(a\\) \\(q_0\\) \\(q_1\\) \\(b\\) \\(q_2\\) \\(q_2\\) \\(a\\) \\(q_0\\) <p>Remarque</p> <p>Dans certains textes, les \u00e9tats finaux peuvent \u00eatre marqu\u00e9s par une fl\u00e8che sortante plut\u00f4t qu'un trait double.</p>"},{"location":"langages/automates/#b-calcul-dun-automate","title":"B. Calcul d'un automate","text":"<p>Nous avons d\u00e9fini formellement un automate et il nous reste maintenant \u00e0 d\u00e9crire son fonctionnement c'est-\u00e0-dire d\u00e9crire comment cette machine calcule.</p> <p>Un automate est une machine capable de lire des mots. Lorsque l'automate est dans un \u00e9tat \\(q_1\\) et que l'on lit une lettre \\(c\\), l'automate transitionne vers l'\u00e9tat \\(q_2 = \\delta(q, c)\\) (sauf s'il y a blocage). Pour tout \u00e9tat \\(q_1\\) et \\(q_2\\) et toute lettre \\(c \\in \\Sigma\\), on notera :</p> \\[ q_1 \\longrightarrow^c q_2 \\] <p>lorsque \\(q_2 = \\delta(q_1, c)\\).</p> <p>Notation alternative</p> <p>Il est aussi possible de noter \\(q_1.c = q_2\\) lorsque \\(\\delta(q_1, c) = q_2\\).</p> <p>D\u00e9finition (calcul)</p> <p>Un calcul d'un automate fini d\u00e9terministe \\(A = (Q, q_0, F, \\delta)\\) est un chemin dans l'automate, c'est-\u00e0-dire une suite d'\u00e9tats :</p> \\[ u_0 \\longrightarrow^{w_1} u_1 \\longrightarrow^{w_2} u_2 \\longrightarrow^{w_3} \\cdots \\longrightarrow^{w_{n-1}} u_{n-1} \\longrightarrow^{w_n} u_n \\] <p>o\u00f9 les \\(w_i\\) sont des lettres lues et qui v\u00e9rifie bien :</p> \\[ \\forall k \\in \\{0, \\dots, n-1\\}, u_{k+1} = \\delta(u_k, w_k). \\] <p>Exemple (calcul d'un automate)</p> <p>Dans l'automate :  </p> \\[ q_0 \\longrightarrow^a q_0 \\longrightarrow^b q_1 \\longrightarrow^b q_2 \\longrightarrow^a q_0 \\longrightarrow^b q_1 \\] <p>est un calcul de l'automate qui correspond \u00e0 la lecture du mot \\(abbab\\) depuis l'\u00e9tat \\(q_0\\) et qui m\u00e8ne en \\(q_1\\).</p> <p>On remarque que pour un \u00e9tat de d\u00e9part \\(q\\), et un mot \\(u\\) donn\u00e9, il ne peut exister qu'un seul calcul depuis cet \u00e9tat, c'est pour cette raison que l'on dit que l'automate est d\u00e9terministe : il n'a qu'un seul comportement possible \u00e0 la lecture d'un mot en entr\u00e9e. Cela peut \u00eatre rendu explicite par la d\u00e9finition de la fonction de transition \u00e9tendue :</p> <p>D\u00e9finition (fonction de transition \u00e9tendue)</p> <p>Soit \\(A = (Q, q_0, F, \\delta)\\) un automate fini d\u00e9terministe. On d\u00e9finit la fonction de transition \u00e9tendue \\(\\delta^* : Q \\times \\Sigma^* \\to Q\\) par :</p> \\[ \\begin{cases} \\forall q \\in Q,\\ \\delta^*(q, \\varepsilon) = q  \\\\ \\forall q \\in Q, \\ \\forall u \\in \\Sigma^*, \\ \\forall c \\in \\Sigma, \\ \\delta^*(q, uc) = \\delta(\\delta^*(q, u), c) \\\\ \\end{cases} \\] <p>Ainsi, la fonction \\(\\delta^*\\) \u00e9tend la fonction \\(\\delta\\) aux mots. Tout comme la fonction \\(\\delta\\), elle n'est pas forc\u00e9ment d\u00e9finie sur \\(Q \\times \\Sigma^*\\) : la lecture d'un mot peut provoquer un blocage.</p> <p>Notations alternatives</p> <p>Il est aussi possible de noter :</p> <ul> <li>\\(q_1.u = q_2\\) </li> <li>ou encore \\(q_1 \\rightarrow^u q_2\\)</li> </ul> <p>lorsque \\(\\delta^*(q_1, u) = q_2\\). La premi\u00e8re notation, plus math\u00e9matique, montre qu'on peut faire agir le mono\u00efde \\(\\Sigma^*\\) sur l'ensemble d'\u00e9tats \\(Q\\). La seconde notation met en \u00e9vidence la notion de chemin dans l'automate.</p>"},{"location":"langages/automates/#c-langage-reconnu","title":"C. Langage reconnu","text":"<p>D\u00e9finition (mot reconnu)</p> <p>Soit \\(A = (Q, q_0, F, \\delta)\\) un automate fini d\u00e9terministe. Un mot \\(u \\in \\Sigma^*\\) est reconnu (on dit aussi accept\u00e9) par \\(A\\) lorsque \\(\\delta^*(q_0, u) \\in F\\).</p> <p>Autrement dit, un mot est reconnu est par un automate si sa lecture \u00e0 partir l'\u00e9tat initial \\(q_0\\) :</p> <ol> <li>ne provoque pas de blocage </li> <li>m\u00e8ne l'automate dans un de ses \u00e9tats finaux</li> </ol> <p>D\u00e9finition (langage reconnu)</p> <p>Soit \\(A = (Q, q_0, F, \\delta)\\) un automate fini d\u00e9terministe. Le langage reconnu (aussi appel\u00e9 langage accept\u00e9) par l'automate \\(A\\), not\u00e9 \\(\\mathcal{L}(A)\\) est :</p> \\[ \\mathcal{L}(A) = \\{ u \\in \\Sigma^*, \\delta^*(q, u) \\in F \\} \\] <p>Autrement dit, le langage reconnu est l'ensemble des mots reconnus par l'automate.</p> <p>D\u00e9finition (langage reconnaissable)</p> <ul> <li>Un langage \\(L\\) est dit reconnaissable par automate fini s'il existe un automate fini d\u00e9terministe \\(A\\) tel que \\(\\mathcal{L}(A) = L\\).</li> <li>L'ensemble des langages sur \\(\\Sigma\\) reconnaissables par automate fini est appel\u00e9 classe des langages reconnaissables. Elle sera not\u00e9ee \\(\\def\\rec#1{{\\text{REC}(#1)}} \\rec{\\Sigma}\\) dans ce cours.</li> </ul> <p>\u00c9tudions maintenant quelques exemples de langages pouvant \u00eatre reconnus par automate fini d\u00e9terministe.</p> <p>Exemple : mots commen\u00e7ant par ...</p> <p>On souhaite reconna\u00eetre par automate le langage des mots sur \\(\\Sigma = \\{a, b\\}\\) qui commencent par \\(aba\\), c'est-\u00e0-dire ayant \\(aba\\) pour pr\u00e9fixe. Pour cela, on peut proposer l'automate suivant :   La derni\u00e8re fl\u00e8che, tout \u00e0 droite, est \u00e9tiquet\u00e9e par \\(a, b\\), ce qui signifie qu'il y a en r\u00e9alit\u00e9 2 transitions. On utilise souvent cette notation pour all\u00e9ger les figures. L'automate peut se lire en deux parties :</p> <ul> <li>Une premi\u00e8re phase o\u00f9 on lit le pr\u00e9fixe \\(aba\\), remarquer comme on utilise le blocage pour rejeter les mots qui ne commencent pas par \\(aba\\)</li> <li>Une seconde phase o\u00f9 on boucle sur l'\u00e9tat final, ce qui signifie qu'on accepte maintenant toute suite de lettres</li> </ul> <p>Exemple : mots contenant un nombre impair de \\(a\\)</p> <p>On souhaite reconna\u00eetre par automate le langage des mots sur \\(\\Sigma = \\{a, b\\}\\) contenant un nombre impair de \\(a\\). Pour cela, on peut proposer l'automate suivant :   Dans cet exemple, les \u00e9tats de l'automate servent \u00e0 reprensenter les classes de congruence du nombre de \\(a\\) modulo 2. Plus simplement, dans l'\u00e9tat \\(q_0\\) le nombre de \\(a\\) lus est pair et dans l'\u00e9tat \\(q_1\\) le nombre de \\(a\\) lus est impair. Cela explique que la lecture d'un \\(a\\) fait passer d'un \u00e9tat \u00e0 l'autre, tandis que la lecture d'un \\(b\\) ne change pas l'\u00e9tat.</p> <p>Conseil</p> <p>Autant que possible, faites en sorte que chaque \u00e9tat de l'automate ait une signification propore comme dans les exemples pr\u00e9c\u00e9dents. Cela facilite \u00e0 la fois la conception et la justification de l'automate.</p> <p>Exercice</p> <p>En vous inspirant de l'exemple pr\u00e9c\u00e9dent, proposer un automate pour reconna\u00eetre les mots sur \\(\\Sigma = \\{a, b\\}\\) dont le nombre de \\(b\\) est de la forme \\(3k + 1\\) avec \\(k \\in \\mathbb{N}\\).</p> <p></p> <p>Exemple difficile : mots finissant par \\(ababa\\)</p> <p>On souhaite reconna\u00eetre le langage des mots sur \\(\\Sigma = \\{a, b\\}\\) finissant par \\(ababa\\), c'est-\u00e0-dire ayant \\(ababa\\) pour suffixe. Voici un automate fini d\u00e9terministe reconnaissant ce langage.   Cet automate impl\u00e9mente en fait l'algorithme de recherche de motif de Knuth-Morris-Pratt (KMP). L'\u00e9tat \\(q_i\\) repr\u00e9sente le pr\u00e9fixe de longueur \\(i\\) de \\(ababab\\). \u00catre dans l'\u00e9tat \\(q_i\\) signifie que le plus long pr\u00e9fixe de \\(ababa\\) qui est actuellement en fin de mot lu, c'est-\u00e0-dire qui est suffixe du mot lu, est celui de longueur \\(i\\).</p> <ul> <li>Les transitions vers la droite sont faciles \u00e0 comprendre : si on lit la bonne lettre, on gagne une lettre dans le pr\u00e9fixe de \\(ababa\\).</li> <li>Les transitions retour, c'est-\u00e0-dire quand on lit la mauvaise lettre, sont plus ardues. Prenons un exemple :<ul> <li>Lorsqu'on est dans \\(q_3\\), le plus long suffixe du mot lu qui est aussi pr\u00e9fixe de \\(ababa\\) est \\(aba\\), autrement dit le mot lu est de la forme \\(waba\\). Si on lit maintenant un \\(a\\), le mot est \\(wabaa\\), alors le plus long suffixe de \\(wabaa\\) qui est pr\u00e9fixe de \\(ababa\\) est \\(a\\). C'est pourquoi on retourne en \\(q_1\\) et pas en \\(q_0\\). On constate en fait que malgr\u00e9 l'erreur de lettre, une partie de la lecture de \\(ababa\\) a d\u00e9j\u00e0 commenc\u00e9 et qu'il ne faut pas reprendre la recherche depuis le d\u00e9but.</li> <li>De m\u00eame lorsqu'on est dans \\(q_5\\), le mot lu a pour forme \\(wababa\\). Si on lit maintenant un \\(b\\), le mot lu sera \\(wababab\\), et on s'aper\u00e7oit que le plus long suffixe de ce mot qui est aussi pr\u00e9fixe de \\(ababa\\) est \\(abab\\), donc on revient en \\(q_4\\). Vous pouvez tester cela en regardant la lecture du mot \\(ababababa\\) par exemple.</li> </ul> </li> </ul>"},{"location":"langages/automates/#d-programmation","title":"D. Programmation","text":"<p>Nous avions promis que les automates \u00e9taient bien plus simples \u00e0 mettre en oeuvre sur un ordinateur que les expressions r\u00e9guli\u00e8res. Voici donc un exemple d'impl\u00e9mentation en OCaml.</p> <pre><code>    type etat = int;; (* Les etats sont representes par des numeros de 0 \u00e0 |A|-1*)\n\n    type auto = {\n        taille: int; (* nombre d'\u00e9tats *)\n        init: etat;\n        final: etat list;\n        trans: (char * etat) list array; (* table de transitions *)\n    };;\n</code></pre> <p>Le seul point d\u00e9licat de cette repr\u00e9sentation est la table de transitions, c'est-\u00e0-dire la mani\u00e8re dont on repr\u00e9sente la fonction de transition \\(\\delta\\). La repr\u00e9sentation choisie est un tableau <code>trans</code> dans lequel chaque case <code>trans.(i)</code> contient les transitions sortantes de l'\u00e9tat \\(i\\). Ces transitions sont repr\u00e9sent\u00e9es sous forme d'une liste de couples \\((c, j)\\) o\u00f9 \\(c\\) est la lettre lue et \\(j\\) l'\u00e9tat d'arriv\u00e9e de la transition.  Cette repr\u00e9sentation est analogue \u00e0 celle des listes d'adjacence pour les graphes orient\u00e9s.</p> <p>Remarque</p> <p>Ces listes sont appel\u00e9es listes associatives. Elles servent \u00e0 associer un \u00e9tat d'arriv\u00e9e (valeur) \u00e0 une lettre lue (clef). Autrement dit il s'agit d'une impl\u00e9mentation concr\u00e8te de la structure de donn\u00e9es abstraite de dictionnaire. On a choisi les listes associatives par simplicit\u00e9 mais nous aurions aussi pu utiliser une table de hachage ou encore un arbre binaire de recherche.</p> <p>D\u00e9finition d'un automate</p> <p>D\u00e9finissons en OCaml l'automate vu en d\u00e9but de chapitre :  <pre><code>let a1 = {\n    taille = 3;\n    init = 0;\n    final = [1; 2];\n    trans = [|\n        [('a', 0); ('b', 1)]; (* transitions sortantes de l'etat 0 *)\n        [('a', 0); ('b', 2)];\n        [('a', 0)]\n    |]\n};;\n</code></pre></p> <p>Un avantage de l'utilisation des listes associatives est que la fonction <code>List.assoc</code> est d\u00e9j\u00e0 programm\u00e9e pour vous dans la biblioth\u00e8que OCaml (sa programmation ne devrait poser aucun probl\u00e8me, faites-le en exercice). Cette fonction a pour signature <code>List.assoc : 'a -&gt; ('a * 'b) list -&gt; 'b'</code>, elle prend en argument une clef et une liste associative et renvoie la valeur associ\u00e9e \u00e0 cette clef. Si la clef n'existe pas dans la liste, alors l'exception <code>Not_found</code> est lev\u00e9e.</p> <p>Pour nous, les clefs sont les lettres lues, les valeurs les \u00e9tats d'arriv\u00e9e et l'exception <code>Not_found</code> est d\u00e9clench\u00e9e lorsqu'il y a blocage. Impl\u00e9mentons la fonction de calcul d'un automate : <pre><code>(* lit le mot u dans auto depuis l'etat q *)\nlet calcul auto q u =\n    let n = String.length u in (* le mot est une cha\u00eene de caract\u00e8res *)\n    let etat_courant = ref q in (* on se sert d'une r\u00e9f\u00e9rence pour m\u00e9moriser l'\u00e9tat courant *)\n    for i = 0 to n-1 do\n        let nouvel_etat = List.assoc u.[i] auto.trans.(!etat_courant) in\n        etat_courant := nouvel_etat\n    done;\n    !etat_courant\n;;\n</code></pre> Remarquons que cette fonction l\u00e8ve aussi l'exception <code>Not_found</code> en cas de blocage. Nous pouvons maintenant programmer la fonction qui teste si un mot est accept\u00e9 ou non par un automate : <pre><code>let est_reconnu auto u =\n    try\n        (* on calcule l'etat d'arriv\u00e9e en fin de lecture du mot *)\n        let etat_fin = calcul auto auto.init u in\n        (* on teste s'il est final *)\n        List.mem etat_fin auto.final\n    with\n        (* Si Not_found est lev\u00e9, il y a blocage, le mot n'est pas accept\u00e9 *)\n        Not_found -&gt; false \n;;\n</code></pre></p> <p>Les automates sont efficaces !</p> <p>Les automates se programment assez rapidement mais surtout ils sont efficaces. La lecture d'un mot \\(u\\) est de complexit\u00e9 lin\u00e9aire \\(O(|u|)\\). Encore mieux, l'automate lit en fait une et une seule fois chaque lettre de gauche \u00e0 droite.</p>"},{"location":"langages/automates/#2-operations-classiques-sur-les-automates","title":"2. Op\u00e9rations classiques sur les automates","text":""},{"location":"langages/automates/#a-accessibilite-et-emondage","title":"A. Accessibilit\u00e9 et \u00e9mondage","text":"<p>D\u00e9finition (accessibilit\u00e9)</p> <p>Soit \\(A = (Q, q_0, \\delta, F)\\) un automate fini d\u00e9terministe et \\(q \\in Q\\) un \u00e9tat.</p> <ul> <li>On dit que \\(q\\) est accessible s'il existe un mot \\(u\\) tel que \\(q_0 \\rightarrow^u q\\)</li> <li>On dit que \\(q\\) est co-accessible s'il existe un mot \\(u\\) et un \u00e9tat final \\(q_F \\in F\\) tels que \\(q \\rightarrow^u q_F\\)</li> </ul> <p>Remarque : un \u00e9tat utile est accessible et co-accessible</p> <ul> <li>Un \u00e9tat qui n'est pas accessible n'est jamais atteint lors d'un calcul depuis l'\u00e9tat \\(q_0\\), il est donc inutile.</li> <li>Un calcul qui atteint un \u00e9tat qui n'est pas co-accessible n'aboutira jamais \u00e0 un \u00e9tat final. </li> </ul> <p>Le calcul des \u00e9tats accessibles peut s'obtenir simplement en r\u00e9alisant un parcours de graphe depuis l'\u00e9tat \\(q_0\\), en igonorant les \u00e9tiquettes des transitions. </p> <p>Le calcul des \u00e9tats co-accessibles peut s'obtenir de la m\u00eame mani\u00e8re, en inversant le sens des transitions et en ex\u00e9cutant un parcours \u00e0 partir de chaque \u00e9tat final.</p> <p>Proposition</p> <p>Soit \\(L\\) un langage reconnaissable par automate fini d\u00e9terministe, alors il existe un automate fini d\u00e9terministe \\(A\\) qui reconna\u00eet \\(L\\) et dont tous les \u00e9tats sont accessibles et co-accessibles.</p> D\u00e9monstration <p>Il suffit de calculer tous les \u00e9tats accessibles et co-accessibles d'un automate reconnaissant \\(L\\), puis de lui supprimer les \u00e9tats qui ne le sont pas. Ce faisant, on supprime bien s\u00fbr les transitions qui partent ou qui pointent d'un \u00e9tat supprim\u00e9. Comme un calcul r\u00e9ussi passe n\u00e9cessairement par des \u00e9tats accessibles et co-accessibles, cela ne change pas le langage reconnu par l'automate.</p> <p>Vocabulaire</p> <p>Lorsqu'on \u00e9limine les \u00e9tats non accessibles et non co-accessibles d'un automate, on dit qu'on \u00e9monde cet automate.</p> <p>Exemple</p> <p>Consid\u00e9rons l'automate :   Les \u00e9tats accessibles sont : \\(q_0, q_1, q_2, q_3, q_4\\)</p> <p>Les \u00e9tats co-accessibles sont \\(q_0, q_1, q_2, q_3, q_5\\)</p> <p>Les \u00e9tats \\(q_4\\) et \\(q_5\\) sont donc inutiles.</p> <p>Si on \u00e9monde l'automate on obtient :  </p>"},{"location":"langages/automates/#b-completion-dun-automate","title":"B. Compl\u00e9tion d'un automate","text":"<p>D\u00e9finition (automate complet)</p> <p>Soit \\(A = (Q, q_0, \\delta, F)\\) un automate fini d\u00e9terministe. On dit que cet automate est complet lorsque \\(\\delta(q, c)\\) est d\u00e9fini pour tout \u00e9tat \\(q \\in Q\\) et toute lettre \\(c \\in \\Sigma\\).</p> <p>Dans un automate complet, il n'y a jamais de blocage.</p> <p>Proposition</p> <p>Soit \\(L\\) un langage reconnaissable par automate fini d\u00e9terministe, alors il existe un automate fini d\u00e9terministe complet \\(A\\) qui reconna\u00eet \\(L\\).</p> D\u00e9monstration <p>Soit \\(A = (Q, q_0, \\delta, F)\\) un automate qui reconna\u00eet \\(L\\) et qui n'est pas d\u00e9j\u00e0 complet. On construit l'automate \\(A' = (Q', q_0, \\delta', F)\\) avec \\(Q' = Q \\cup \\{q_\\infty\\}\\) o\u00f9 \\(q_\\infty\\) est un nouvel \u00e9tat (\\(q_\\infty \\not \\in Q\\).) appel\u00e9 \u00e9tat puits. On d\u00e9finit \\(\\delta'\\) ainsi :</p> \\[ \\forall q \\in Q',\\ \\forall c \\in \\Sigma, \\delta'(q, c) = \\begin{cases} \\delta(q, c) &amp; \\text{si c'est d\u00e9fini}\\\\ q_\\infty &amp; \\text{sinon} \\end{cases} \\] <p>Alors \\(A'\\) est complet et de plus \\(\\mathcal{L}(A) = \\mathcal{L}(A')\\). En effet :</p> <ul> <li>si \\(u \\in \\mathcal{L}(A)\\) alors il existe un calcul dans \\(A\\) \u00e9tiquet\u00e9 par \\(u\\) mentant de l'\u00e9tat \\(q_0\\) \u00e0 un \u00e9tat final. Ce calcul existe donc aussi dans \\(A'\\), donc \\(u \\in \\mathcal{L}(A')\\).</li> <li>r\u00e9ciproquement, si \\(u \\in \\mathcal{L}(A')\\) alors il existe un calcul dans \\(A'\\) \u00e9tiquet\u00e9 par \\(u\\) menant de l'\u00e9tat \\(q_0\\) \u00e0 un \u00e9tat final. Comme \\(q_\\infty\\) n'est pas co-accessible, ce calcul ne passe pas par \\(q_\\infty\\) et c'est donc aussi un calcul dans \\(A\\), donc \\(u \\in \\mathcal{L}(A)\\).</li> </ul> <p>Point m\u00e9thode</p> <p>Pour compl\u00e9ter un automate (qui n'est pas d\u00e9j\u00e0 complet) :</p> <ol> <li>On ajoute un \u00e9tat puits \\(q_\\infty\\)</li> <li>Pour tout \u00e9tat, on ajoute toutes les transitions sortantes manquantes, en les faisant pointer vers \\(q_\\infty\\)</li> <li>On n'oublie pas de r\u00e9aliser l'\u00e9tape 2 aussi pour l'\u00e9tat puits \\(q_\\infty\\)</li> </ol> <p>Exemple</p> <p>Soit l'automate suivant sur \\(\\Sigma = \\{a, b\\}\\) qui n'est pas complet:  </p> <p>En appliquant l'algorithme de compl\u00e9tion, on obtient :  </p> <p>Attention</p> <p>On peut \u00e9monder un automate, on peut compl\u00e9ter un automate, mais on ne peut pas toujours faire les deux op\u00e9rations \u00e0 la fois puisque l'\u00e9tat puits que l'on ajoute dans la compl\u00e9tion n'est pas co-accessible.</p>"},{"location":"langages/automates/#c-automate-complementaire","title":"C. Automate compl\u00e9mentaire","text":"<p>Soit \\(\\Sigma\\) un alphabet et \\(L\\) un langage, on note \\(\\bar{L} = \\{u \\in \\Sigma^*, u \\not \\in L\\}\\) le langage compl\u00e9mentaire de L.</p> <p>Proposition</p> <p>Si \\(L\\) est un langage reconnaissable par automate fini d\u00e9terministe alors \\(\\bar{L}\\) l'est aussi.</p> D\u00e9monstration <p>Soit \\(L\\) un langage reconnu par l'automate fini d\u00e9terministe \\(A\\). On donne un algorithme pour construire un automate fini d\u00e9terministe \\(A'\\) qui reconna\u00eet \\(\\bar{L}\\).</p> <ul> <li>On commence par compl\u00e9ter l'automate \\(A\\) et on obtient un automate complet \\(A_c = (Q, q_0, \\delta, F)\\) qui reconna\u00eet \\(L\\).</li> <li>On construit alors \\(A'\\) en inversant les \u00e9tats finaux et non finaux dans \\(A_c\\) c'est-\u00e0-dire que \\(A_c = (Q, q_0, \\delta, Q \\setminus F)\\).</li> </ul> <p>On a alors \\(\\mathcal{L}(A') = \\bar{L}\\), en effet pour tout \\(u \\in \\Sigma^*\\):</p> \\[ \\begin{align} u \\in \\mathcal{L}(A') &amp; \\Leftrightarrow \\delta^*(q_0, u) \\in Q \\setminus F \\\\ &amp; \\Leftrightarrow \\delta^*(q_0, u) \\not \\in F \\\\ &amp; \\Leftrightarrow u \\not \\in \\mathcal{L}(A_c) \\quad \\text{ car } A_c \\text{ est complet} \\\\ &amp; \\Leftrightarrow u \\not \\in \\mathcal{L}(A) \\\\ &amp; \\Leftrightarrow u \\not \\in L\\\\ &amp; \\Leftrightarrow u \\in \\bar{L} \\end{align} \\] <p>Dans la d\u00e9monstration, on remarque l'importance de compl\u00e9ter l'automate : cela permet de n'avoir qu'une seule cause de non non-accceptation \u00e0 savoir le fait que la lecture du mot aboutit dans un \u00e9tat non final.</p> <p>Point m\u00e9thode</p> <p>Pour construire un automate fini d\u00e9terministe \\(A'\\) reconnaissant le compl\u00e9mentaire de \\(\\mathcal{L}(A)\\), on applique les \u00e9tapes :</p> <ol> <li>On compl\u00e8te \\(A\\)</li> <li>On inverse les \u00e9tats finaux et non finaux</li> </ol> <p>Exemple : mots qui ne commencent pas par \\(aba\\)</p> <p>Soit l'automate suivant sur \\(\\Sigma = \\{a, b\\}\\) reconnaissant les mots qui commencent par \\(aba\\) :  </p> <p>On souhaite construire l'automate compl\u00e9mentaire c'est-\u00e0-dire un automate qui reconna\u00eet les mots qui ne commencent pas par \\(aba\\). On commence par compl\u00e9ter l'automate :   </p> <p>Puis, on inverse les \u00e9tats finaux et non finaux :  </p> <p>Encore une fois, on peut constater sur l'exemple que l'oubli de l'\u00e9tape de compl\u00e9tion donne un automate compl\u00e9mentaire faux.</p>"},{"location":"langages/automates/#d-automate-produit","title":"D. Automate produit","text":"<p>L'automate produit de deux automates \\(A_1\\) et \\(A_2\\) est un automate qui fait calculer simultan\u00e9ment \\(A_1\\) et \\(A_2\\). On le d\u00e9finit ainsi :</p> <p>D\u00e9finition (automate produit)</p> <p>Soit \\(A_1 = (Q_1, q_0^1, \\delta_1, F_1)\\) et \\(A_2 = (Q_2, q_0^2, \\delta_2, F_2)\\) deux automates finis d\u00e9terministes. On d\u00e9finit l'automate produit de \\(A_1\\) et \\(A_2\\), not\u00e9 \\(A = A_1 \\times A_2\\), par \\(A = (Q, q_0, \\delta, F)\\) avec :</p> <ul> <li>\\(Q = Q_1 \\times Q_2\\) : les \u00e9tats sont des couples \\((q_1, q_2)\\) qui d\u00e9crivent l'\u00e9tat actuel des automates \\(A_1\\) et \\(A_2\\)</li> <li>\\(q_0 = (q_0^1, q_0^2)\\)</li> <li>\\(F = F_1 \\times F_2\\) : un \u00e9tat est final si les deux automates \\(A_1\\) et \\(A_2\\) sont dans un \u00e9tat final</li> <li>Pour tout \\(q_1 \\in Q_1\\), \\(q_2 \\in Q_2\\) et \\(c \\in \\Sigma\\), \\(\\delta((q_1, q_2), c)\\) n'est d\u00e9fini que lorsque \\(\\delta_1(q_1, c)\\) et \\(\\delta_2(q_2, c)\\) sont d\u00e9finis, c'est-\u00e0-dire qu'aucun des deux automates \\(A_1\\) et \\(A_2\\) ne bloque. Dans ce cas, on pose :</li> </ul> \\[ \\delta((q_1, q_2), c) = \\left( \\delta_1(q_1, c), \\delta_2(q_2, c) \\right) \\] <p>Il r\u00e9sulte de cette d\u00e9finition que l'automate produit accepte uniquement les mots qui sont accept\u00e9s par \\(A_1\\) et \\(A_2\\).</p> <p>Exemple : mots qui commencent par \\(aba\\) ayant un nombre pair de \\(b\\)</p> <p>On souhaite construire un automate qui reconna\u00eet les mots sur \\(\\Sigma =\\{a, b\\}\\) qui commencent par \\(aba\\) et qui contiennent un nombre pair de \\(b\\). Pour cela on part des deux automates suivants \\(A_1\\) et \\(A_2\\) :   Le langage reconnu par \\(A_1\\) est l'ensemble des mots qui commencent par \\(aba\\) et celui de \\(A_2\\) est l'ensemble des mots ayant un nombre pair de \\(b\\). Pour all\u00e9ger les \u00e9critures dans la construction de l'automate produit on a not\u00e9 avec des lettres capitales les \u00e9tats de \\(A_1\\) et des num\u00e9ros pour les \u00e9tats de \\(A_2\\).</p> <p>Pour construire l'automate produit, on ne repr\u00e9sente en g\u00e9n\u00e9ral que les \u00e9tats accessibles, les autres \u00e9tats \u00e9tant inutiles. On proc\u00e8de donc en partant de l'\u00e9tat initial \\((A, 0)\\) et en construisant de proche en proche les \u00e9tats rencontr\u00e9s. On obtient :  </p> <p>Cet automate reconna\u00eet les mots qui commencent par \\(aba\\) et qui contiennent un nombre pair de \\(b\\). Remarquons encore une fois que l'on n'a pas repr\u00e9sent\u00e9 les \u00e9tats non accessibles (\\((A, 1)\\), \\((B, 1)\\) et \\((C, 0)\\)) bien qu'ils fassent partie de la d\u00e9finition de l'automate produit.</p> <p>On constante sur l'exemple pr\u00e9c\u00e9dent que l'automate produit reconna\u00eet les mots qui sont reconnus par les deux automates \u00e0 la fois. D\u00e9montrons maintenant formellement ce r\u00e9sultat.</p> <p>Proposition</p> <p>Soit \\(A_1\\) et \\(A_2\\) deux automates finis d\u00e9terministes et \\(A_1 \\times A_2\\) leur automate produit, alors :</p> \\[ \\mathcal{L}(A_1 \\times A_2) = \\mathcal{L}(A_1) \\cap \\mathcal{L}(A_2) \\] D\u00e9monstration <p>Nous allons d'abord d\u00e9montrer par r\u00e9currence la propri\u00e9t\u00e9 suivante :</p> \\[ P(n) : \\quad \\forall u \\in \\Sigma^n,\\  \\forall q_1 \\in Q_1,\\  \\forall q_2 \\in Q_2,\\  \\delta^*((q_1, q_2), u) = \\left( \\delta_1^*(q_1, u), \\delta_2^*(q_2, u) \\right) \\text{ (sous r\u00e9serve d'existence)} \\] <ul> <li>Initialisation : pour tout couple d'\u00e9tats \\((q_1, q_2)\\), on a \\(\\delta^*((q_1, q_2), \\varepsilon) = (q_1, q_2) = (\\delta_1^*(q_1, \\varepsilon), \\delta_2^*(q_2, \\varepsilon))\\)</li> <li>H\u00e9r\u00e9dit\u00e9 : On suppose \\(P(n)\\) vrai et on montre \\(P(n+1)\\). Soit \\(u\\) un mot de longueur \\(n+1\\) que l'on d\u00e9compose en \\(u = v.c\\) avec \\(c \\in \\Sigma\\) et \\((q_1, q_2)\\) un couple d'\u00e9tats. Alors on a (sous r\u00e9serve d'existence) :</li> </ul> \\[ \\begin{align} \\delta^*((q_1, q_2), u) &amp;= \\delta^*((q_1, q_2), vc) \\\\ &amp;= \\delta(\\delta^*((q_1, q_2), v), c) \\\\ &amp;= \\delta\\left((\\delta_1^*(q_1, v), \\delta_2^*(q_2, v)), c\\right) \\text{ par hypoth\u00e8se de r\u00e9currence} \\\\ &amp;= \\left( \\delta_1(\\delta_1^*(q_1, v), c), \\delta_2(\\delta_2^*(q_2, v), c)\\right) \\text{ par d\u00e9finition de l'automate produit}\\\\ &amp;= (\\delta_1^*(q_1, vc), \\delta_2^*(q_2, vc)) \\\\ &amp;= (\\delta_1^*(q_1, u), \\delta_2^*(q_2, u))\\\\ \\end{align} \\] <p>Puis pour tout mot \\(u \\in \\Sigma^*\\) on a :</p> \\[ \\begin{align*} u \\in \\mathcal{L}(A_1 \\times A_2) &amp;\\Leftrightarrow \\delta^*(q_0, u) \\in F\\\\ &amp;\\Leftrightarrow \\delta^*((q_0^1, q_0^2), u) \\in F \\\\ &amp;\\Leftrightarrow (\\delta_1^*(q_0^1, u), \\delta_2^*(q_0^2, u)) \\in F \\text{ d'apr\u00e8s la propri\u00e9t\u00e9 d\u00e9montr\u00e9e ci-dessus}\\\\ &amp;\\Leftrightarrow (\\delta_1^*(q_0^1, u), \\delta_2^*(q_0^2, u)) \\in F_1 \\times F_2\\\\  &amp;\\Leftrightarrow \\delta_1^*(q_0^1, u) \\in F_1 \\text { et } \\delta_2^*(q_0^2, u) \\in F_2 \\\\  &amp;\\Leftrightarrow u \\in \\mathcal{L}(A_1) \\text { et } u \\in \\mathcal{L}(A_2) \\\\  &amp;\\Leftrightarrow u \\in \\mathcal{L}(A_1) \\cap \\mathcal{L}(A_2) \\end{align*} \\] <p>Donc \\(\\mathcal{L}(A_1 \\times A_2) = \\mathcal{L}(A_1) \\cap \\mathcal{L}(A_2)\\)</p> <p>Corollaire</p> <p>Si \\(L_1\\) et \\(L_2\\) sont des langages reconnaissables par automate alors \\(L_1 \\cap L_2\\) est aussi reconnaissable par automate.</p> <p>Remarque</p> <p>Si \\(A_1\\) poss\u00e8de \\(n\\) \u00e9tats et \\(A_2\\) poss\u00e8de \\(m\\) \u00e9tats alors \\(A_1 \\times A_2\\) poss\u00e8de \\(nm\\) \u00e9tats. M\u00eame si tous ces \u00e9tats ne sont pas n\u00e9cessairement accessibles, dans le pire cas, on peut aboutir \u00e0 de grands automates avec cette construction.</p> <p>Attention</p> <p>Calculer un automate produit \u00e0 la main n\u00e9cessite une grande concentration. L'algorithme est facile \u00e0 appliquer mais la moindre petite erreur conduit \u00e0 un automate compl\u00e8tement faux. V\u00e9rifiez bien votre r\u00e9sultat en faisant calculer votre automate produit sur des mots tests. </p> <p>Exercice</p> <ol> <li>Donner un automate \\(A_1\\) reconnaissant les mots sur \\(\\Sigma = \\{a, b\\}\\) ayant un nombre impair de \\(a\\).</li> <li>Donner un automate \\(A_2\\) reconnaissant les mots sur \\(\\Sigma = \\{a, b\\}\\) dont le nombre de \\(b\\) est de la forme \\(3k + 1\\) avec \\(k \\in \\mathbb{N}\\)</li> <li>En d\u00e9duire un automate \\(A\\) qui reconna\u00eet les mots sur \\(\\Sigma = \\{a, b\\}\\) ayant un nombre impair de \\(a\\) et un nombre de \\(b\\) de la forme \\(3k + 1\\).</li> </ol>"},{"location":"langages/automates/#3-automates-finis-non-deterministes","title":"3. Automates finis non d\u00e9terministes","text":"<p>Les automates finis d\u00e9terministes sont simples et faciles \u00e0 impl\u00e9menter sur ordinateur. L'inconv\u00e9nient principal est qu'ils peuvent \u00eatre difficile \u00e0 concevoir d'un point de vue humain.</p> <p>Prenons l'exemple du langage \\(L\\) sur \\(\\Sigma = \\{a, b\\}\\) des mots qui finissent par \\(ababa\\). \u00c9crire une expression r\u00e9guli\u00e8re qui d\u00e9note \\(L\\) est tr\u00e8s facile : \\(e = (a|b)*ababa\\). Par contre, concevoir un automate fini d\u00e9terministe qui reconna\u00eet ce langage est nettement plus complexe, comme on l'a vu dans l'exemple plus haut.</p> <p>On aimerait dessiner un automate simple ayant cette allure :       Dans cet automate on lit un certain nombre de lettres \\(a\\) ou \\(b\\) en bouclant sur l'\u00e9tat initial, puis on termine la lecture en lisant \\(ababa\\).</p> <p>Malheureusement, cette figure ne correspond pas \u00e0 celle d'un automate fini d\u00e9terministe. En effet \\(\\delta(q_0, a)\\) aurait 2 images, ce qui est impossible pour une fonction... Une autre fa\u00e7on de le dire est que lorsqu'on est dans l'\u00e9tat \\(q_0\\) et qu'on lit un \\(a\\), on ne sait pas s'il faut aller en \\(q_1\\) ou rester en \\(q_0\\) : cet automate est non d\u00e9terministe.</p> <p>Nous allons voir dans cette partie qu'il est tout \u00e0 fait possible de travailler avec ce type de machine non d\u00e9terministe.</p>"},{"location":"langages/automates/#a-definition_1","title":"A. D\u00e9finition","text":"<p>D\u00e9finition (automate fini non d\u00e9terministe)</p> <p>Un automate fini non d\u00e9terministe est un quadruplet \\(A = (Q, I, F, T)\\) dans lequel :</p> <ul> <li>\\(Q\\) est l'ensemble fini des \u00e9tats</li> <li>\\(I \\subset Q\\) est l'ensemble des \u00e9tats initiaux</li> <li>\\(F \\subset Q\\) est l'ensemble des \u00e9tats finaux</li> <li>\\(T \\subset Q \\times \\Sigma \\times Q\\) est l'ensemble des transitions</li> </ul> <p>On remarque deux diff\u00e9rences par rapport aux automates finis d\u00e9terministes :     1. La possibilit\u00e9 d'avoir plusieurs \u00e9tats initiaux (on d\u00e9marre de mani\u00e8re non d\u00e9terministe).     2. Les transitions qui sont not\u00e9es sont forme de triplets : le triplet \\((q, c, q')\\) signifie que l'automate peut transiter de \\(q\\) \u00e0 \\(q'\\) en listant la lettre \\(c\\). Ce que l'on notera \\(q \\rightarrow^c q'\\) comme on l'a fait avec les automates d\u00e9terministes.</p> <p>Un automate d\u00e9terministe est un automate non d\u00e9terministe</p> <p>On peut toujours voir un automate fini d\u00e9terministe \\(A = (Q, q_0, \\delta, F)\\) comme un automate fini non d\u00e9terministe. Dans ce cas :</p> <ol> <li>L'ensemble d'\u00e9tats initiaux est le singleton \\(I = \\{q_0\\}\\).</li> <li>On peut construire \\(T\\) it\u00e9rativement. Pour tout \u00e9tat \\(q \\in Q\\) et toute lettre \\(c \\in \\Sigma\\), si \\(\\delta(q, c)\\) est d\u00e9fini alors on a ajoute la transition \\((q, c, \\delta(q, c))\\) dans \\(T\\).</li> </ol> <p>La plupart du temps on fera l'abus et on dira qu'un automate d\u00e9terministe n'est qu'un cas particulier d'automate non d\u00e9terministe.</p> <p>Exemple</p> <p>L'automate non d\u00e9terministe ci-dessus   est d\u00e9fini par \\(A = (Q, I, F, T)\\) avec :</p> <ul> <li>\\(Q = \\{q_0, q_1, q_2, q_3, q_4, q_5\\}\\)</li> <li>\\(I = \\{q_0\\}\\)</li> <li>\\(F = \\{q_5\\}\\)</li> <li>\\(T = \\{(q_0, a, q_0), (q_0, b, q_0), (q_0, a, q_1), (q_1, b, q_2), (q_2, a, q_3), (q_3, b, q_4), (q_4, a, q_5)\\}\\)</li> </ul>"},{"location":"langages/automates/#b-calcul-non-deterministe","title":"B. Calcul non d\u00e9terministe","text":"<p>Il y a deux fa\u00e7ons de voir le calcul dans un automate non d\u00e9terministe :</p> <ul> <li>vision clonage : \u00e0 chaque fois qu'on est confront\u00e9 \u00e0 un choix non d\u00e9terministe, on imagine que le processus se clone, chaque clone envisage une des possibilit\u00e9s offertes. Si l'un des clones r\u00e9ussit le calcul, alors le calcul est consid\u00e9r\u00e9 r\u00e9ussi.</li> <li>vision oracle : si \u00e0 chaque fois qu'on est confront\u00e9 \u00e0 un choix non d\u00e9terminsite, il existe un oracle capable de me dire le bon chemin qui me m\u00e8nera vers un calcul r\u00e9ussi, alors le calcul est r\u00e9ussi.</li> </ul> <p>Ces deux visions sont \u00e9quivalentes, mais il est peut-\u00eatre plus simple de comprendre la premi\u00e8re. Formalisons cela, en d\u00e9finissant la fonction de transition \\(\\delta\\) puis la fonction de transition \u00e9tendue \\(\\delta^*\\) d'un automate non d\u00e9terministe.</p> <p>D\u00e9finition (fonction de transition d'un automate non d\u00e9terministe)</p> <p>Soit \\(A = (Q, I, F, T)\\) un automate fini non d\u00e9terministe, alors sa fonction de transition est l'application \\(\\delta : Q \\times \\Sigma \\to \\mathfrak{P}(Q)\\) d\u00e9finie par :</p> \\[ \\forall q \\in Q, \\ \\forall c \\in \\Sigma, \\ \\delta(q, c) = \\{ q' \\in Q, (q, c, q') \\in T\\} \\] <p>Ainsi \\(\\delta(q, c)\\) donne l'ensemble des \u00e9tats qu'on peut atteindre en lisant \\(c\\) depuis \\(q\\). Notons que contrairement aux automates non d\u00e9terministes \\(\\delta\\) est cette fois une application, c'est-\u00e0-dire d\u00e9finie sur \\(Q \\times \\Sigma\\) en entier. La notion de blocage correspond donc au cas o\u00f9 \\(\\delta(q, c) = \\varnothing\\).</p> <p>D\u00e9finiton (fonction de transtion \u00e9tendue)</p> <p>Soit \\(A = (Q, I, F, T)\\) un automate fini non d\u00e9terministe. La fonction de transtion \u00e9tendue est l'application \\(\\delta^* : Q \\times \\Sigma^* \\to \\mathfrak{P}(Q)\\) d\u00e9finie par :</p> \\[ \\forall q \\in Q,\\  \\begin{cases} \\delta^*(q, \\varepsilon) = \\{q\\} \\\\ \\forall v \\in \\Sigma^*, \\ \\forall c \\in \\Sigma, \\delta^*(q, v.c) = \\displaystyle \\bigcup_{q' \\in \\delta^*(q, v)} \\delta(q', c)\\\\ \\end{cases} \\] <p>Cette fonction doit se comprendre ainsi : \\(\\delta^*(q, u)\\) est l'ensemble des \u00e9tats atteints par mes clones (ou moi) lorsque je pars de l'\u00e9tat \\(q\\) et que je lis \\(u\\). Dans la d\u00e9finition pour calculer \\(\\delta^*(q, v.c)\\), on commence par regarder tous les \u00e9tats \\(q'\\) atteints par mes clones (ou moi) lors de la lecture de \\(v\\), puis pour chacun de ces \u00e9tats on ajoute au r\u00e9sultat les \u00e9tats qu'on peut atteindre en lisant la derni\u00e8re lettre \\(c\\).</p> <p>Exemple de calcul</p> <p>Reprenons l'automate cens\u00e9 reconna\u00eetre les mots finissant par \\(ababa\\) :    et effectuons le calcul pas \u00e0 pas de \\(\\delta^*(q_0, abab)\\) (lecture de \\(abab\\) depuis \\(q_0\\)) :</p> <ul> <li>\\(\\delta^*(q_0, \\varepsilon) = \\{q_0\\}\\)</li> <li>\\(\\delta^*(q_0, a) = \\{q_0, q_1\\}\\)</li> <li>\\(\\delta^*(q_0, ab) = \\{q_0, q_2\\}\\) </li> <li>\\(\\delta^*(q_0, aba) = \\{q_0, q_1, q_3\\}\\) </li> <li>\\(\\delta^*(q_0, abab) = \\{q_0, q_2, q_4\\}\\) </li> </ul> <p>Ainsi lorsque je lis \\(abab\\) depuis \\(q_0\\) je peux me retrouver au choix en \\(q_0\\), en \\(q_2\\) ou en \\(q_4\\).</p> <p>Proposition</p> <p>Pour tout mot \\(u \\in \\Sigma^*\\), pour tout \u00e9tats \\(q, q' \\in Q\\),  \\(q' \\in \\delta^*(q, u)\\) si et seulement s'il existe au moins un chemin dans l'automate menant de \\(q\\) \u00e0 \\(q'\\) et \u00e9tiquet\u00e9 par \\(u\\).</p> D\u00e9monstration <p>La d\u00e9monstration par r\u00e9currence sur la longueur du mot \\(u\\) est laiss\u00e9e en exercice au lecteur ou \u00e0 la lectrice.</p> <p>Cette proposition nous invite naturellement \u00e0 noter \\(q \\rightarrow^u q'\\) lorsque \\(q' \\in \\delta^*(q, u)\\). Cela co\u00efncide avec nos notations pour les automates d\u00e9terministes.</p>"},{"location":"langages/automates/#c-langage-reconnu_1","title":"C. Langage reconnu","text":"<p>Nous pouvons maintenant d\u00e9crire les mots accept\u00e9s par un automate non d\u00e9terministe.</p> <p>D\u00e9finition (mot reconnu)</p> <p>Soit \\(A = (Q, I, F, T)\\) un automate fini non d\u00e9terministe. Un mot \\(u \\in \\Sigma^*\\) est reconnu (on dit aussi accept\u00e9) par \\(A\\) lorsqu'il existe au moins un \u00e9tat initial \\(q_0 \\in I\\) tel que \\(\\delta^*(q_0, u)\\) contienne au moins un \u00e9tat final. Autrement dit :</p> \\[ u \\text{ accept\u00e9 } \\Leftrightarrow \\exists q_0 \\in I, \\ \\delta^*(q_0, u) \\displaystyle \\cap F \\not = \\varnothing \\] <p>Deux autres fa\u00e7ons de dire la m\u00eame chose :     1. Un mot \\(u\\) est accept\u00e9 s'il existe au moins un chemin dans \\(A\\) menant d'un \u00e9tat initial \u00e0 un \u00e9tat final et etiquet\u00e9 par \\(u\\).     2. Un mot \\(u\\) est accept\u00e9 si l'un de mes clones (avec un clone par \u00e9tat initial ininitialement) aboutit sur un \u00e9tat final lors de la lecture de \\(u\\).</p> <p>D\u00e9finition (langage reconnu)</p> <p>Soit \\(A = (Q, I, F, T)\\) un automate fini d\u00e9terministe. Le langage reconnu (aussi appel\u00e9 langage accept\u00e9) par l'automate \\(A\\), not\u00e9 \\(\\mathcal{L}(A)\\) est :</p> \\[ \\mathcal{L}(A) = \\{ u \\in \\Sigma^*, A \\text{ accepte } u \\} \\]"},{"location":"langages/automates/#d-determinisation","title":"D. D\u00e9terminisation","text":"<p>Nous venons de d\u00e9finir les automates finis non d\u00e9terministes et d\u00e9crire leur fonctionnement. Deux questions se posent naturellement :</p> <ol> <li>L'avantage des automates \u00e9tait la simplicit\u00e9 de mise en oeuvre sur machine et l'efficacit\u00e9 du calcul. Or, on vient de perdre les deux avantages : le calcul n\u00e9cessite maintenant de m\u00e9moriser une liste d'\u00e9tats, de plus le calcul \\(\\delta^*(q, u)\\) est maintenant de complexit\u00e9 exponentielle en \\(|u|\\) alors qu'elle \u00e9tait lin\u00e9aire pour les automates finis d\u00e9terministes.</li> <li>Les langages reconnaissables par automate fini non d\u00e9terministes sont-ils les m\u00eames que ceux reconnus par automate fini d\u00e9terministe ? N'a-t-on pas cr\u00e9\u00e9 une machine plus puissante en introduisant le non d\u00e9terminisme ?</li> </ol> <p>La r\u00e9ponse \u00e0 la seconde question est remarquablement : non. Nous allons voir dans cette partie que les automates non d\u00e9terministes ont la m\u00eame puissance d'expression que les automates non d\u00e9terministes.</p> <p>D\u00e9finition (Automate des parties)</p> <p>Soit \\(A = (Q, I, F, T)\\) un automate fini non d\u00e9terministe, on d\u00e9finit l'automate fini d\u00e9terministe \\(A_p = (Q_p, q_0, F_p, \\delta_p)\\) suivant :</p> <ul> <li>\\(Q_p = \\mathfrak{P}(Q)\\)</li> <li>\\(q_0 = I\\)</li> <li>\\(F_p = \\{ X \\subset Q, X \\cap F \\not = \\varnothing\\}\\)</li> <li>\\(\\delta(X, c) = \\displaystyle \\bigcup_{x \\in X} \\delta(x, c)\\) o\u00f9 \\(\\delta\\) est la fonction de transtion de \\(A\\)</li> </ul> <p>Cet automate est appel\u00e9 automate des parties car ses \u00e9tats sont des parties de l'ensemble d'\u00e9tats \\(Q\\).</p> <p>Point m\u00e9thode : algorithme de d\u00e9terminisation</p> <p>Pour calculer \\(A_p\\) \u00e0 partir de \\(A\\), on proc\u00e8de pas \u00e0 pas en ne repr\u00e9sentant que les \u00e9tats accessibles.</p> <ol> <li>On commence par introduire l'\u00e9tat \\(q_0 = I\\).</li> <li>Pour chaque \u00e9tat \\(X\\) non trait\u00e9, pour chaque lettre \\(c \\in \\Sigma\\), on calcule \\(\\displaystyle\\cup_{x \\in X} \\delta(x, c)\\), c'est-\u00e0-dire les \u00e9tats qu'on peut atteindre depuis \\(X\\) en lisant une lettre \\(c\\).</li> <li>On dessine les nouveaux \u00e9tats et les nouvelles transitions obtenus.</li> <li>On recommence avec les \u00e9tats non trait\u00e9s.</li> </ol> <p>Il peut \u00eatre agr\u00e9able repr\u00e9senter cette d\u00e9marche sous forme d'une table.</p> <p>Exemple : d\u00e9terminisation d'un automate</p> <p>On veut d\u00e9terminiser l'automate qui reconna\u00eet les mots qui finissent par \\(ababa\\), c'est-\u00e0-dire calculer son automate des parties. Pour all\u00e9ger les \u00e9critures, on a not\u00e9 \\(\\{0, 1, 2, 3, 4, 5\\}\\) l'ensemble d'\u00e9tats :  </p> <p>On construit pas \u00e0 pas la table des transitions comme expliqu\u00e9 dans le point m\u00e9thode :</p> \u00e9tats \\(X\\) \u00a0lettre \\(c\\) \u00a0arriv\u00e9e \\(\\delta_p(X, c)\\) \\(\\{0\\}\\) \\(a\\) \\(\\{0, 1\\}\\) \\(\\{0\\}\\) \\(b\\) \\(\\{0\\}\\) \\(\\{0, 1\\}\\) \\(a\\) \\(\\{0, 1\\}\\) \\(\\{0, 1\\}\\) \\(b\\) \\(\\{0, 2\\}\\) \\(\\{0, 2\\}\\) \\(a\\) \\(\\{0, 1, 3\\}\\) \\(\\{0, 2\\}\\) \\(b\\) \\(\\{0\\}\\) \\(\\{0, 1, 3\\}\\) \\(a\\) \\(\\{0, 1\\}\\) \\(\\{0, 1, 3\\}\\) \\(b\\) \\(\\{0, 2, 4\\}\\) \\(\\{0, 2, 4\\}\\) \\(a\\) \\(\\{0, 1, 3, 5\\}\\) \\(\\{0, 2, 4\\}\\) \\(b\\) \\(\\{0\\}\\) \\(\\{0, 1, 3, 5\\}\\) \\(a\\) \\(\\{0, 1\\}\\) \\(\\{0, 1, 3, 5\\}\\) \\(b\\) \\(\\{0, 2, 4\\}\\) <p>On obtient l'automate suivant qui est isomorphe \u00e0 l'automate obtenu lorsqu'on a voulu directement concevoir un automate d\u00e9terministe pour ce langage. Il reconna\u00eet donc aussi les mots qui finissent par \\(ababa\\).   Encore une fois remarquons qu'on n'a repr\u00e9sent\u00e9 que les \u00e9tats accessibles de l'automate des parties qui en contient r\u00e9ellement \\(2^6 = 64\\) dans cet exemple.</p> <p>Proposition</p> <p>Soit \\(A\\) un automate fini non d\u00e9terministe, soit \\(A_p\\) son automate des parties alors :</p> \\[ \\mathcal{L}(A) = \\mathcal{L}(A_p) \\] D\u00e9monstration <p>On montre par r\u00e9currence sur la longueur du mot que pour tout mot \\(u \\in \\Sigma^*\\) et pour tout ensemble d'\u00e9tats \\(X \\subset Q\\), \\(\\delta_p^*(X, u) = \\displaystyle\\bigcup_{x \\in X} \\delta^*(x, u)\\). Ainsi avec l'ensemble de d\u00e9part \\(q_0\\) choisi le calcul dans l'automate des parties nous donne l'ensemble des \u00e9tats qu'on peut atteindre par la lecture de \\(u\\) dans \\(A\\) depuis un des \u00e9tats initiaux. L'ensemble \\(F_p\\) est choisi de telle sorte \u00e0 ce \\(A_p\\) n'accepte cet ensemble d'\u00e9tats que lorsqu'il contient au moins un \u00e9tat final.</p> <p>Corollaire</p> <p>La classe des langages sur \\(\\Sigma\\) reconnaissables par automate fini d\u00e9terministe et par automate fini non d\u00e9terministe sont les m\u00eames. On notera \\(\\rec{\\Sigma}\\) l'ensemble des langages reconnaissables par automate (d\u00e9terministe ou non).</p> <p>La conclusion de cette partie est que les automates non d\u00e9terministes reconnaissent exactement les m\u00eames langages que les automates d\u00e9terministes. Si on veut un automate d\u00e9terministe pour reconna\u00eetre efficacement un langage en machine, on peut le concevoir de mani\u00e8re non-d\u00e9terministe puis lui appliquer l'algorithme de d\u00e9terminisation. \u00c9videmment cet algorithme est tr\u00e8s co\u00fbteux dans le pire cas, car il peut produire \\(2^{|Q|}\\) \u00e9tats. Cependant on ne r\u00e9alise cette \u00e9tape qu'une seule fois, on peut ensuite utiliser l'automate d\u00e9terministe obtenu autant de fois que voulu.</p>"},{"location":"langages/automates/#4-langages-non-reconnaissables-par-automate","title":"4. Langages non reconnaissables par automate","text":"<p>Il existe des langages qui ne peuvent pas \u00eatre reconnus par un automate fini. Le th\u00e9or\u00e8me suivant permet de d\u00e9montrer que certains langages ne sont pas reconnaissables.</p> <p>Th\u00e9or\u00e8me (Lemme de l'\u00e9toile)</p> <p>Soit \\(L\\) un langage reconnu par un automate \u00e0 \\(N\\) \u00e9tats. Soit \\(u \\in L\\) un mot de longueur \\(|u| \\geq N\\), alors il existe 3 mots \\(x, y, z \\in \\Sigma^*\\) tels que \\(u\\) se d\u00e9compose en \\(u = xyz\\) et v\u00e9rifiant :</p> <ol> <li>\\(|xy| \\leq N\\)</li> <li>\\(y \\neq \\varepsilon\\)</li> <li>\\(\\forall k \\in \\mathbb{N},\\  xy^kz \\in L\\)</li> </ol> D\u00e9monstration <p>Soit \\(L\\) un langage reconnu par un automate \\(A = (Q, q_0, F, \\delta)\\) \u00e0 \\(N\\) \u00e9tats et \\(u \\in L\\) un mot de longueur \\(|u| \\geq N\\). Notons \\(p_k\\) (\\(0 \\leq k \\leq N\\)) le pr\u00e9fixe de \\(u\\) de longeur \\(k\\). On consid\u00e8re l'application</p> \\[ \\begin{align} \\varphi : [|0, N|] &amp;\\to Q \\\\ k &amp;\\mapsto \\delta^*(q_0, p_k)\\\\ \\end{align} \\] <p>Remarquons que cette application est bien d\u00e9finie, car \\(u\\) est reconnu par \\(A\\) donc il n'y a pas de blocage \u00e0 la lecture des pr\u00e9fixes de \\(u\\).</p> <p>Comme \\(\\text{Card}([|0, N|]) = N+1\\) et \\(\\text{Card}(Q) = N\\), l'application \\(\\varphi\\) n'est pas injective. Il existe donc deux entiers \\(0 \\leq k_1 &lt; k_2 \\leq N\\) tels que \\(\\varphi(k_1) = \\varphi(k_2)\\). Informellement, cela signifie que la lecture de \\(u\\) depuis l'\u00e9tat \\(q_0\\) va conduire au passage par un m\u00eame \u00e9tat \u00e0 deux instants \\(k_1\\) et \\(k_2\\) distincts. Notons \\(q' = \\varphi(k_1)\\) cet \u00e9tat qui est visit\u00e9 au moins deux fois.</p> <p>On pose alors \\(x = p_{k_1}\\), \\(y\\) tel que \\(xy = p_{k_2}\\) et \\(z\\) tel que \\(xyz = u\\). On a alors \\(\\delta^*(q_0, x) = \\delta^*(q_0, xy) = q'\\). V\u00e9rifions que cette d\u00e9composition fonctionne :</p> <ol> <li>\\(|xy| = |p_{k_2}| = k_2 \\in [|0, N|]\\)</li> <li>Si \\(y = \\varepsilon\\) alors \\(x = xy\\) ce qui implique \\(k_1 = k_2\\), c'est exclus.</li> <li> <p>On montre par r\u00e9currence sur \\(k\\) que \\(\\delta^*(q_0, xy^kz) = \\delta^*(q_0, u)\\) ce qui montre que \\(xy^kz\\) est reconnu car \\(u\\) l'est.</p> <p>a. Initialisation : \\(\\delta^*(q_0, xz) = \\delta^*(\\delta^*(q_0, x), z) = \\delta^*(q', z) = \\delta^*(\\delta^*(q_0, xy), z) = \\delta^*(q_0, xyz)\\)</p> <p>b. H\u00e9r\u00e9dit\u00e9 : on suppose la propri\u00e9t\u00e9 vraie au rang \\(k \\in \\mathbb{N}\\), montrons-l\u00e0 au rang \\(k+1\\) :</p> \\[ \\begin{align} \\delta^*(q_0, xy^{k+1}z) &amp;= \\delta^*(\\delta^*(\\delta^*(q_0, xy), y^k), z) = \\delta^*(\\delta^*(q', y), z) \\\\ &amp;= \\delta^*(\\delta^*(\\delta^*(q_0, x), y^k), z) = \\delta^*(q_0, xy^kz)\\\\ &amp;= \\delta^*(q_0, xyz) \\text{ par hypoth\u00e8se de r\u00e9currence} \\end{align} \\] </li> </ol> <p>Savoir d\u00e9montrer qu'un langage n'est pas reconnaissable ne s'improvise pas et il faut \u00e9tudier attentivement les m\u00e9thodes permettant d'obtenir ce r\u00e9sultat.</p> <p>Point m\u00e9thode : d\u00e9montrer qu'un langage \\(L\\) n'est pas reconnaissable avec le lemme de l'\u00e9toile</p> <ol> <li>On suppose par l'absurde que \\(L\\) est reconnu par un automate \u00e0 \\(N\\) \u00e9tats.</li> <li>On choisit judicieusement un mot \\(u \\in L\\) particulier de longueur \\(|u| \\geq N\\)</li> <li>On invoque le Lemme de l'\u00e9toile ce qui nous permet d'obtenir la d\u00e9compostion \\(u = xyz\\).</li> <li>\u00c0 l'aide des propri\u00e9t\u00e9s (1), (2) et (3) du lemme de l'\u00e9toile, on aboutit \u00e0 une absurdit\u00e9.</li> </ol> <p>Exemple cl\u00e9 : \\(\\{a^n b^n, n \\in \\mathbb{N}\\}\\)</p> <p>D\u00e9montrons que langage \\(L = \\{a^nb^n, n \\in \\mathbb{N}\\}\\) n'est pas reconnaissable.</p> <ol> <li>Supposons par l'absurde que \\(L\\) soit reconnaissable et qu'il est reconnu par un automate \u00e0 \\(N\\) \u00e9tats.</li> <li>Consid\u00e9rons le mot \\(u = a^N b^N\\), alors \\(u \\in L\\) et \\(|u| = 2N \\geq N\\).</li> <li>D'apr\u00e8s le lemme de l'\u00e9toile, il existe donc 3 mots \\(x, y, z \\in \\mathbb{N}\\) tels que<ol> <li>\\(|xy| \\leq N\\)</li> <li>\\(y \\neq \\varepsilon\\)</li> <li>\\(\\forall k \\in \\mathbb{N},\\ xy^kz \\in L\\)</li> </ol> </li> <li>D'apr\u00e8s (a), \\(x\\) et \\(y\\) ne contiennent que des lettres \\(a\\). De plus, d'apr\u00e8s (b), \\(y\\) contient au moins un \\(a\\). D'apr\u00e8s (c), on doit avoir \\(|xy^kz|_a = |xy^kz|_b\\) pour tout \\(k \\in \\mathbb{N}\\) car les mots de \\(L\\) contiennent autant de \\(a\\) que de \\(b\\). Ceci est absurde, car d'apr\u00e8s nos remarques :</li> </ol> \\[ |xy^kz|_a = |x|_a + k\\underbrace{|y|_a}_{&gt; 0} + |z|_a \\] \\[ |xy^kz|_b = |x|_b + |y^k|_b + |z|_b = |z|_b \\] <p>La premi\u00e8re quantit\u00e9 cro\u00eet strictement lorsque \\(k\\) cro\u00eet tandis que la seconde reste constante. C'est absurde. Donc \\(L\\) n'est pas reconnaissable.</p> <p>Point m\u00e9thode : d\u00e9montrer qu'un langage \\(L\\) n'est pas reconnaissable en utilisant les propri\u00e9t\u00e9s de cl\u00f4ture</p> <p>Pour utiliser cette m\u00e9thode, il faut exploiter un langage \\(L_2\\) dont on sait d\u00e9j\u00e0 qu'il n'est pas reconnaissable (hypoth\u00e8se de l'\u00e9nonc\u00e9 ou on l'a d\u00e9montr\u00e9 avant).</p> <ol> <li>On suppose par l'absurde que \\(L\\) est reconnaissable.</li> <li>On montre que \\(L_2\\) peut s'obtenir \u00e0 partir de \\(L\\) et d'autres langages reconnaissables en utilisant des op\u00e9rations qui pr\u00e9servent le caract\u00e8re reconnaissable (compl\u00e9mentaire, intersection finie, union finie, ...)</li> <li>On en d\u00e9duit que \\(L_2\\) est reconnaissable : c'est absurde.</li> </ol> <p>Exemple cl\u00e9 : \\(\\{ u \\in \\{a,b\\}^*, |u|_a = |u|_b \\}\\)</p> <p>Montrons que \\(L = \\{ u \\in \\{a,b\\}^*, |u|_a = |u|_b \\}\\) n'est pas reconnaissable. On sait que le langage \\(L_2 = \\{a^n b^n, n \\in \\mathbb{N} \\}\\) n'est pas reconnaissable (exemple pr\u00e9c\u00e9dent).</p> <ol> <li>Supposons par l'absurde que \\(L\\) est reconnaissable.</li> <li>On pose \\(K\\) le langage d\u00e9not\u00e9 par \\(a^*b^*\\), il est reconnaissable (il est facile de proposer un automate). On remarque de plus que \\(L \\cap K = L_2\\).</li> <li>Comme l'intersection de deux langages reconnaissable est reconnaissable, on en d\u00e9duit que \\(L_2\\) est reconnaissable : c'est absurde.</li> </ol> <p>Cette seconde m\u00e9thode, quand on peut l'appliquer, permet de gagner du temps en \u00e9vitant d'invoquer le lemme de l'\u00e9toile. La lectrice pourra v\u00e9rifier qu'on peut aussi r\u00e9soudre ce deuxi\u00e8me exemple en utilisant la premi\u00e8re m\u00e9thode.</p> <p>Raisonnements faux usuels</p> <p>On retrouve souvent les raisonnements faux suivants :</p> <ol> <li>Une sous-partie d'un langage non reconnaissable est non reconnaissable : \\(L \\subset L'\\) avec \\(L'\\) non reconnaissable donc \\(L\\) est non reconnaissable.</li> <li>Si je contiens une partie non reconnaissable alors je suis non reconnaissable : \\(L' \\subset L\\) avec \\(L'\\) non reconnaissable donc \\(L\\) est non reconnaissable.</li> </ol> <p>Dans le premier cas, cela montrerait par exemple que \\(\\varnothing\\) n'est pas reconnaissable. Dans le second cas, si on prend \\(L = \\Sigma^*\\) on obtiendrait que \\(\\Sigma^*\\) n'est pas reconnaissable. </p> <p>A RETENIR : les raisonnements par inclusion sont faux dans ce contexte</p>"},{"location":"langages/grammaires/","title":"Grammaires alg\u00e9briques","text":"<p>Nous avons d\u00e9j\u00e0 \u00e9tudi\u00e9 les expressions r\u00e9guli\u00e8res et les automates finis qui permettent de d\u00e9crire certains langages appel\u00e9s langages r\u00e9guliers. Nous avons aussi vu que tous les langages ne sont pas r\u00e9guliers, en particulier certains langages utiles en informatique comme les langages de mots bien parenth\u00e9s\u00e9s ne sont pas r\u00e9gulier.</p> <p>On s'int\u00e9resse donc dans ce chapitre \u00e0 une nouvelle mani\u00e8re de d\u00e9crire des langages \u00e0 l'aide de grammaires.</p>"},{"location":"langages/grammaires/#1-grammaires-algebriques","title":"1. Grammaires alg\u00e9briques","text":"<p>Dans ce cours on notera en g\u00e9n\u00e9ral :</p> <ul> <li>\\(\\Sigma\\) un alphabet fini de symboles appel\u00e9s symboles terminaux</li> <li>\\(V\\) un alphabet fini de symboles appel\u00e9s variables ou symboles non terminaux</li> </ul> <p>D\u00e9finition</p> <p>Une grammaire alg\u00e9brique est un quadruplet \\((\\Sigma, V, S, \\mathcal{R})\\) dans lequel :</p> <ul> <li>\\(\\Sigma\\) est l'alphabet des symboles terminaux</li> <li>\\(V\\) est l'alphabet des symboles non terminaux ou variables</li> <li>\\(S \\in V\\) est un non terminal sp\u00e9cial appel\u00e9 axiome ou symbole de d\u00e9part</li> <li>\\(\\mathcal{R}\\) est un ensemble fini de r\u00e8gles de production : une r\u00e8gle de production est un couple \\((X, u)\\) o\u00f9 \\(X\\) est une variable et \\(u\\) un mot sur \\(\\Sigma \\cup V\\).</li> </ul> <p>Une r\u00e8gle de production \\((X, u)\\) sera not\u00e9e \\(X \\to u\\). \\(X\\) est le membre gauche de la r\u00e8gle et \\(u\\) le membre droit.</p> <p>Lorsqu'une grammaire poss\u00e8de plusieurs r\u00e8gles avec m\u00eame membre gauche on peut condenser l'\u00e9criture de ces r\u00e8gles ainsi : \\(X \\to u \\ | \\ v \\ | \\ w\\) signifie qu'il existe trois r\u00e8gles de production \\(X \\to u\\), \\(X \\to v\\) et \\(X \\to w\\).</p> <p>Vocabulaire</p> <p>Les grammaires alg\u00e9briques sont aussi appel\u00e9es grammaires hors contexte ou encore grammaires non contextuelles.</p> <p>Exemple (grammaire en langage naturel)</p> <p>Voici une grammaire alg\u00e9brique pour d\u00e9crire ceraines phrases en fran\u00e7ais :  <pre><code>Phrase -&gt; Sujet Verbe Complement\nSujet -&gt; je | elle\nVerbe -&gt; programme | mange\nCompl\u00e9ment -&gt; Article Nom\nArticle -&gt; un | une | le | la\nNom -&gt; ordinateur | pomme | arbre \n</code></pre></p> <p>On remarque que pour donner une grammaire il suffit souvent de lister les r\u00e8gles de production. Une convention souvent utilis\u00e9e est que la premi\u00e8re r\u00e8gle de production correspond \u00e0 l'axiome, les variables commencent par une majuscule et les terminaux sont en minuscules. En cas de doute, pr\u00e9ciser la nature des symboles utilis\u00e9s.</p> <p>Cette grammaire permet de g\u00e9n\u00e9rer les phrases suivantes :</p> <ul> <li>elle programme un ordinateur</li> <li>je mange une pomme</li> <li>je programme un arbre</li> <li>elle programme le pomme</li> </ul> <p>Exemple (langage de balises)</p> <p>Voici une grammaire permettant de representer un langage balis\u00e9 <pre><code>Texte -&gt; epsilon | LettreTexte | &lt;Ident&gt;Texte&lt;/Ident&gt;Texte\nLettre -&gt; a | b | ... | z | (espace) (27 r\u00e8gles)\nIdent -&gt; gras | italique\n</code></pre> Ici, <code>epsilon</code> d\u00e9signe le mot vide. Les symboles non terminaux sont \\(V = \\{\\mathrm{Texte}, \\mathrm{Lettre}, \\mathrm{Ident}\\}\\) et les symboles terminaux sont \\(\\Sigma = \\{&lt;, &gt;, /, a, ..., z, (espace)\\}\\).</p> <p>Cette grammaire permet par exemple de r\u00e9pr\u00e9senter le texte balis\u00e9 suivant : <code>&lt;gras&gt; &lt;italique&gt; texte &lt;/italique&gt; &lt;/gras&gt; issu de notre &lt;gras&gt; grammaire &lt;/gras&gt;</code>.</p> <p>Attention</p> <p>Cette grammaire ne g\u00e9n\u00e8re pas n\u00e9cessairement de textes correctement balis\u00e9s : par exemple il est tout a fait possible d'\u00e9crire <code>&lt;gras&gt; vanille bourbon &lt;/italique&gt;</code> avec les r\u00e8gles de cette grammaire. Comment modifier cette grammaire pour obtenir des balises correctes ?</p> Exemple (langage de balises correct) <p>Pour avoir un parenth\u00e9sage correct des balises 'gras' et 'italique' on peut utiliser la grammaire suivante : <pre><code>Texte -&gt; epsilon | LettreTexte\nTexte -&gt; &lt;gras&gt;Texte&lt;/gras&gt;Texte\nTexte -&gt; &lt;italique&gt;Texte&lt;/italique&gt;Texte\nLettre -&gt; a | b | ... | z | (espace) (27 r\u00e8gles)\n</code></pre></p> <p>Exemple (expressions arithm\u00e9tiques)</p> <p>Les expressions arithm\u00e9tiques avec des constantes litt\u00e9rales binaires peuvent \u00eatre obtenues par une grammaire telle que : <pre><code>S -&gt; C\nS -&gt; S + S\nS -&gt; S x S\nC -&gt; 0D | 1D\nD -&gt; epsilon | 0D | 1D\n</code></pre> Par exemple on peut g\u00e9n\u00e9rer le texte : <code>111 + 10 x 1101</code> avec cette grammaire.</p> <p>Exemple (grammaire d'un langage de programmation)</p> <p>La lecture du manuel OCaml permet de s'apercevoir que la syntaxe des programmes <code>OCaml</code> est d\u00e9crite par une grammaire alg\u00e9brique. Une grammaire permet donc la sp\u00e9cification formelle de la syntaxe d'un langage de programmation ou d'un format de donn\u00e9es (html, xml, yaml, toml, json...)</p>"},{"location":"langages/grammaires/#2-derivations-et-langages-engendres","title":"2. D\u00e9rivations et langages engendr\u00e9s","text":"<p>Nous allons maintenant d\u00e9finir formellement ce qu'est le langage engendr\u00e9 par une grammaire. Pour cela, il nous faudra d'abord expliquer la notion de d\u00e9rivation.</p>"},{"location":"langages/grammaires/#a-derivations","title":"A. D\u00e9rivations","text":"<p>D\u00e9finition (d\u00e9rivation imm\u00e9diate)</p> <p>Soit \\(G = (\\Sigma, V, S, \\mathcal{R})\\) une grammaire alg\u00e9brique, soit \\(R = A \\to \\alpha\\) une r\u00e8gle de production de \\(G\\). Soit \\(u\\) et \\(v\\) deux mots sur \\(\\Sigma \\cup V\\). On dit que \\(u\\) se d\u00e9rive imm\u00e9diatement en \\(v\\) avec la r\u00e8gle \\(R\\) s'il existe deux mots \\(x\\) et \\(y\\) sur \\(\\Sigma \\cup V\\) tels que :</p> <ul> <li>\\(u = x A y\\)</li> <li>\\(v = x \\alpha y\\)</li> </ul> <p>Autrement dit, cette d\u00e9finition dit que \\(u\\) se d\u00e9rive en \\(v\\) avec la r\u00e8gle \\(R\\) si \\(u\\) contient quelque part le symbole non terminal \\(A\\) et qu'on peut obtient \\(v\\) lorsqu'on subsitue \\(A\\) par \\(\\alpha\\) dans \\(u\\).</p> <p>Notation : On notera \\(u \\Rightarrow v\\) pour dire que \\(u\\) se d\u00e9rive imm\u00e9diatement en \\(v\\).</p> <p>D\u00e9finition (d\u00e9rivation)</p> <p>Soit \\(G = (\\Sigma, V, S, \\mathcal{R})\\) une grammaire alg\u00e9brique. Soit \\(u\\) et \\(v\\) des mots sur \\(\\Sigma \\cup V\\). On dit que \\(u\\) se d\u00e9rive en \\(v\\) s'il existe une suite finie de \\(n\\) d\u00e9rivations imm\u00e9diates : \\(w_0 \\Rightarrow w_1 \\Rightarrow w_2 \\Rightarrow \\dots \\Rightarrow w_n\\) telle que :</p> <ul> <li>\\(w_0 = u\\)</li> <li>\\(w_n = v\\)</li> </ul> <p>Le nombre de d\u00e9rivations imm\u00e9diates \\(n \\in \\mathbb{N}\\) s'appelle la longueur de la d\u00e9rivation.</p> <p>Notation : \\(u \\Rightarrow^* v\\)</p> <p>Proposition</p> <p>La relation \\(\\Rightarrow^*\\) est r\u00e9flexive et transitive.</p> D\u00e9monstration <ol> <li>Il est \u00e9vident que tout mot \\(u\\) se d\u00e9rive en \\(u\\) par la suite de d\u00e9rivations de longueur nulle. Donc \\(\\Rightarrow^* {}\\) est transitive.</li> <li>On suppose qu'il existe trois mots \\(u\\), \\(v\\), \\(w\\) tels que \\(u \\Rightarrow^* v\\) et \\(v \\Rightarrow^* w\\). Donc il existe deux suites finies de d\u00e9rivations imm\u00e9diates \\(a_0 \\Rightarrow \\dots \\Rightarrow a_n\\) et \\(b_0 \\Rightarrow \\dots \\Rightarrow b_m\\) telles que \\(a_0 = u\\), \\(a_n = b_0 = v\\) et \\(b_m = w\\). Ainsi, il existe bien une d\u00e9rivation de \\(u\\) en \\(w\\) de longueur \\(n + m\\) : \\(u = a_0 \\Rightarrow \\dots \\Rightarrow a_n = b_0 \\Rightarrow \\dots \\Rightarrow b_m = w\\). Donc \\(u \\Rightarrow^* v\\).</li> </ol> <p>En informatique, on dit que la relation \\(\\Rightarrow^* {}\\) est la fermeture r\u00e9flexive transitive de la relation \\(\\Rightarrow\\).</p> <p>D\u00e9finition</p> <p>On dit qu'une d\u00e9rivation imm\u00e9diate xAy =&gt; x alpha y est une d\u00e9rivation imm\u00e9diate gauche (resp. d\u00e9rivation imm\u00e9diate droite) lorsque x (resp. y) ne contient pas de symbole non terminal.</p> <p>Notations: \\(u \\Rightarrow_g v\\) et \\(u \\Rightarrow_d v\\)</p> <p>Autrement dit, une d\u00e9rivation gauche est une d\u00e9rivation dans laquelle on applique une r\u00e8gle de production associ\u00e9e \u00e0 un symbole non terminal le plus \u00e0 gauche du mot. </p> <p>On d\u00e9finit de m\u00eame les relations de d\u00e9rivation gauche \\(\\Rightarrow_g^*\\) et de d\u00e9rivation droite \\(\\Rightarrow_d^*\\) lorsqu'on a une suite finie de d\u00e9rivations imm\u00e9diates gauche ou droite.</p>"},{"location":"langages/grammaires/#b-langage-engendre-par-une-grammaire","title":"B. Langage engendr\u00e9 par une grammaire","text":"<p>D\u00e9finition</p> <p>Soit \\(G = (\\Sigma, V, S, \\mathcal{R})\\) une grammaire alg\u00e9brique, on appelle langage engendr\u00e9 par \\(G\\) le langage des mots sur \\(\\Sigma\\) qu'on peut obtenir par d\u00e9rivation du symbole initial \\(S\\) : </p> \\[\\mathcal{L}(G) = \\{ u \\in \\Sigma^* \\text{ tels que } S \\Rightarrow^* u \\}\\] <p>Attention, le langage engendr\u00e9 par une grammaire n'est constitu\u00e9 que de mots form\u00e9s sur l'alphabet des terminaux.</p> <p>D\u00e9finition</p> <p>Un langage \\(L\\) est dit langage alg\u00e9brique s'il est engendr\u00e9 par une grammaire alg\u00e9brique. On d\u00e9signe aussi parfois cette classe de langage sous le terme de langages non contextuels.</p> <p>Exemple (langage de Dyck)</p> <p>Soit \\(G\\) la grammaire suivante :</p> \\[S \\rightarrow \\varepsilon \\ | \\ aSbS\\] <p>Alors \\(\\mathcal{L}(G)\\) est le langage des mots bien parenth\u00e9s\u00e9s dans lequel \\(a\\) repr\u00e9sente une parenth\u00e8se ouvrante et \\(b\\) une parenth\u00e8se fermante.</p> D\u00e9monstration <ol> <li>Montrons d'abord que tout mot correctement parenth\u00e9s\u00e9 peut se d\u00e9river depuis \\(S\\). On proc\u00e8de par r\u00e9currence forte sur la longueur de \\(u\\). Si \\(u = \\varepsilon\\) alors \\(S \\Rightarrow^* u\\). Si \\(u\\) un mot bien parenth\u00e9s\u00e9 non vide, il commence n\u00e9cessairement par une parenth\u00e8se ouvrante \\(a\\). On d\u00e9compose alors \\(u\\) en \\(u = avbw\\) o\u00f9 la lettre \\(b\\) de la d\u00e9composition correspond \u00e0 la parenth\u00e8se fermante associ\u00e9e \u00e0 la premi\u00e8re parenth\u00e8se ouvrante \\(a\\). Les mots \\(v\\) et \\(w\\) sont alors aussi bien parenth\u00e9s\u00e9s. Par hypoth\u00e8se de r\u00e9currence forte on a \\(S \\Rightarrow^* v\\) et \\(S \\Rightarrow^* w\\). Il vient alors : \\(S\u00a0\\Rightarrow aSbS \\Rightarrow^* avbS \\Rightarrow^* avbw = u\\). La r\u00e9currence forte est \u00e9tablie.</li> <li>R\u00e9ciproquement, montrons que tout mot \\(u\\) d\u00e9riv\u00e9 depuis \\(S\\) est bien parenth\u00e9s\u00e9. On proc\u00e8de par r\u00e9currence forte sur la longueur de la d\u00e9rivation. Si la d\u00e9rivation est de longueur 0 alors elle ne peut pas g\u00e9n\u00e9rer de mot sur \\(\\Sigma\\). Si la d\u00e9rivation est de longueur k &gt; 0. Alors soit elle commence par \\(S \\Rightarrow \\varepsilon\\) ce qui signifie que \\(u = \\varepsilon\\) qui est bien parenth\u00e9s\u00e9, soit elle commence par \\(S \\Rightarrow aSbS\\). Donc n\u00e9cessairement \\(u\\) est de la forme \\(u = avbw\\) avec \\(S \\Rightarrow^* v\\) et \\(S \\Rightarrow^* w\\). Par hypothese de recurrence forte, \\(v\\) et \\(w\\) sont bien parenth\u00e9s\u00e9s. On en d\u00e9duit que \\(avb\\) est bien parenth\u00e9s\u00e9 et que \\(u = avb \\cdot w\\) est bien parenth\u00e9s\u00e9 par concat\u00e9nation de deux mots bien parenth\u00e9s\u00e9s. La r\u00e9currence forte est \u00e9tablie.</li> </ol> <p>Une d\u00e9monstration plus formelle (mais pas n\u00e9cessairement plus claire) n\u00e9cessiterait de d\u00e9finir proprement le langage de Dyck comme les mots ayant autant de \\(a\\) que de \\(b\\) et dans lesquels tout pr\u00e9fixe contient plus de \\(a\\) que de \\(b\\). Aussi, le 2e sens de la preuve peut \u00eatre clarifi\u00e9 en utilisant les arbres de d\u00e9rivations pr\u00e9sent\u00e9s dans la partie suivante.</p> <p>D\u00e9finition</p> <p>Deux grammaires \\(G_1\\) et \\(G_2\\) sont dites faiblement \u00e9quivalentes lorsqu'elles engendrent le m\u00eame langage : \\(\\mathcal{L}(G_1) = \\mathcal{L}(G_2)\\).</p> <p>Exemple</p> <p>La grammaire suivante </p> \\[ \\begin{align} S &amp; \\to SS \\ |\\  \\varepsilon \\\\ S &amp; \\to aSb \\end{align} \\] <p>engendre aussi le langage de Dyck et est donc faiblement \u00e9quivalente \u00e0 la grammaire propos\u00e9e pr\u00e9c\u00e9demment.</p> D\u00e9monstration <p>Notons \\(G_1\\) la grammaire initialement propos\u00e9e et \\(G_2\\) cette nouvelle grammaire.</p> <ol> <li> <p>On remarque que pour \\(G_2\\), \\(S \\Rightarrow \\varepsilon\\) et \\(S \\Rightarrow SS \\Rightarrow aSbS\\). Donc toute suite de d\u00e9rivation imm\u00e9diates pour la grammaire \\(G_1\\) peut \u00eatre traduite en suite de d\u00e9rivations pour la grammaire \\(G_2\\). Cela signifie que \\(\\mathcal{L}(G_1) \\subset \\mathcal{L}(G_2)\\).</p> </li> <li> <p>Pour montrer l'inclusion r\u00e9ciproque : \\(\\mathcal{L}(G_2) \\subset \\mathcal{L}(G_1)\\), il suffit de montrer que les mots engendr\u00e9s par \\(G_2\\) sont bien parent\u00e9s\u00e9s. On peut le montrer par r\u00e9currence forte sur la longueur de la d\u00e9rivation : cela fonctionne car \\(\\varepsilon\\) est bien parenth\u00e9s\u00e9, si \\(u\\) est bien parenth\u00e9s\u00e9 alors \\(aub\\) aussi et que le langage de Dyck est stable par concat\u00e9nation.</p> </li> </ol>"},{"location":"langages/grammaires/#c-non-contextualite-des-langages-reguliers","title":"C. Non contextualit\u00e9 des langages r\u00e9guliers","text":"<p>Proposition</p> <p>Les langages r\u00e9guliers sont alg\u00e9briques.</p> <p>Deux autres mani\u00e8res de le dire : </p> <ul> <li>Tout langage d\u00e9not\u00e9 par une expression r\u00e9guli\u00e8re est engendr\u00e9 par une grammaire alg\u00e9brique</li> <li>Tout langage accept\u00e9 par un automate fini (d\u00e9terministe ou non) est engendr\u00e9 par une grammaire alg\u00e9brique</li> </ul> D\u00e9monstration <p>On proc\u00e8de par induction sur les langages r\u00e9guliers qui sont d\u00e9finis inductivement. Montrons la propri\u00e9t\u00e9</p> \\[P(L) : \\text{\"Il existe une grammaire alg\u00e9brique $G$ telle que $\\mathcal{L}(G) = L$\"}\\] <p>sur tous les langages \\(L\\) r\u00e9guliers.</p> <ul> <li>Cas de base<ul> <li>\\(L = \\varnothing\\) : une grammaire ne contenant aucune r\u00e8gle de production convient</li> <li>\\(L = \\{ \\varepsilon \\}\\) : la grammaire poss\u00e9dant uniquement la r\u00e8gle \\(S \\to \\varepsilon\\) convient</li> <li>\\(L = \\{ a \\}\\) avec \\(a \\in \\Sigma\\) : la grammaire poss\u00e9dant uniquement la r\u00e8gle \\(S \\to a\\) convient</li> </ul> </li> <li>H\u00e9r\u00e9dit\u00e9<ul> <li>\\(L = L_1.L_2\\) avec \\(P(L_1)\\) et \\(P(L_2)\\) vraies. Il existe alors deux grammaires alg\u00e9briques \\(G_1 = (\\Sigma, V_1, S_1, \\mathcal{R}_1)\\) et \\(G_2 = (\\Sigma, V_2, S_2, \\mathcal{R}_2)\\) telles que \\(\\mathcal{L}(G_1) = L_1\\) et \\(\\mathcal{L}(G_2) = L_2\\). Quitte \u00e0 renommer les symboles non terminaux, on peut supposer \\(V_1 \\cap V_2 = \\varnothing\\). On pose alors \\(G = (\\Sigma, V_1 \\cup V_2 \\cup \\{S\\}, \\mathcal{R}_1 \\cup \\mathcal{R}_2 \\cup \\{ S \\to S_1S_2\\})\\) o\u00f9 \\(S\\) est un symbole non terminal nouveau. Dans la grammaire obtenue, la seule d\u00e9rivation imm\u00e9diate initiale possible est \\(S \\Rightarrow S_1S_2\\) ce qui signifie que les mots d\u00e9riv\u00e9s depuis \\(S\\) seront de la forme \\(u_1.u_2\\) avec \\(u_1 \\in L_1\\) et \\(u_2 \\in L_2\\). Donc \\(\\mathcal{L}(G) = L_1.L_2 = L\\).</li> <li>\\(L = L_1 \\cup L_2\\) avec \\(P(L_1)\\) et \\(P(L_2)\\) vraies. On proc\u00e8de comme dans le cas pr\u00e9c\u00e9dent et on pose cette fois la grammaire : \\(G = (\\Sigma, V_1 \\cup V_2 \\cup \\{S\\}, \\mathcal{R}_1 \\cup \\mathcal{R}_2 \\cup \\{S \\to S_1, S \\to S_2\\})\\). Une d\u00e9rivation de \\(S\\) dans cette grammaire d\u00e9bute soit par \\(S \\Rightarrow S_1\\) et alors un mot de \\(L_1\\) sera ultimement g\u00e9n\u00e9r\u00e9, soit \\(S \\Rightarrow S_2\\) et alors un mot de \\(L_2\\) sera ultimement g\u00e9n\u00e9r\u00e9. On en d\u00e9duit que \\(\\mathcal{L}(G) = L_1 \\cup L_2 = L\\).</li> <li>\\(L = L_1^*\\) avec \\(P(L_1)\\) vrai. Il existe donc une grammaire \\(G_1 = (\\Sigma, V_1, S_1, \\mathcal{R}_1)\\) engendrant \\(L_1\\). On pose la grammaire \\(G = (\\Sigma, V_1 \\cup \\{S\\}, \\mathcal{R}_1 \\cup \\{S \\to S_1S, S \\to \\varepsilon\\})\\). Les r\u00e8gles introduites permettent initialement de d\u00e9river tout mot de la forme \\(S_1^k\\) depuis \\(S\\) : \\(S \\Rightarrow S_1^k\\) pour tout \\(k \\in \\mathbb{N}\\). Chaque non terminal \\(S_1\\) se d\u00e9rivera ensuite en un mot de \\(L_1\\). Donc le langage engendr\u00e9 par cette grammaire est \\(\\mathcal{L}(G) = L_1^* = L\\).</li> </ul> </li> </ul>"},{"location":"langages/grammaires/#3-arbres-de-derivation-et-ambiguite","title":"3. Arbres de d\u00e9rivation et ambigu\u00eft\u00e9","text":"<p>Exemple introductif (L'inconv\u00e9nient des suites de d\u00e9rivations)</p> <p>Pour la grammaire du langage de Dyck introduite pr\u00e9c\u00e9demment :</p> \\[ S \\to aSbS \\ | \\  \\varepsilon\\] <p>On peut d\u00e9river depuis \\(S\\) le mot \\(aabbab\\) de deux mani\u00e8res diff\u00e9rentes :</p> <ol> <li>\\(S \\Rightarrow a\\mathbf{S}bS \\Rightarrow aaSbSb\\mathbf{S} \\Rightarrow aaSbSbaSbS \\Rightarrow^* aabbab\\)</li> <li>\\(S \\Rightarrow aSb\\mathbf{S} \\Rightarrow a\\mathbf{S}baSbS \\Rightarrow aaSbSbaSbS \\Rightarrow^* aabbab\\)</li> </ol> <p>Pourtant ces deux d\u00e9rivations utilisent les m\u00eames r\u00e8gles de production, qui sont simplement appliqu\u00e9es dans un ordre diff\u00e9rent. Il n'est pas ais\u00e9 de constater ce fait lorsqu'on repr\u00e9sente une d\u00e9rivation par une suite de d\u00e9rivations imm\u00e9diates. Dans cette partie on va montrer comment repr\u00e9senter les d\u00e9rivations \u00e0 l'aide d'arbres. </p>"},{"location":"langages/grammaires/#a-arbres-de-derivation","title":"A. Arbres de d\u00e9rivation","text":"<p>D\u00e9finition</p> <p>Soit \\(G = (\\Sigma, V, S, \\mathcal{R})\\) une grammaire alg\u00e9brique. Soit \\(X \\in V\\) un symbole non terminal. Un arbre de d\u00e9rivation de racine \\(X\\) est un arbre enracin\u00e9 dont les noeuds et feuilles sont \u00e9tiquet\u00e9s dans \\(\\Sigma \\cup V \\cup \\{\\varepsilon\\}\\) et qui v\u00e9rifie :</p> <ol> <li>La racine est \u00e9tiquet\u00e9e par \\(X\\)</li> <li>Les noeuds internes sont \u00e9tiquet\u00e9s par des variables</li> <li>Si une feuille est \u00e9tiquet\u00e9e par \\(\\varepsilon\\), elle n'a pas de soeurs, et si \\(A\\) est l'\u00e9tiquette de son parent alors \\(A \\to \\varepsilon\\) est une r\u00e8gle de production de \\(G\\)</li> <li>Pour tout noeud interne \u00e9tiquet\u00e9 par \\(A\\) ayant pour fils des noeuds et feuilles \u00e9tiquet\u00e9es de gauche \u00e0 droite par \\(\\alpha_1 \\dots \\alpha_n\\), alors \\(A \\to \\alpha_1 \\dots \\alpha_n\\) est une r\u00e8gle de production de \\(G\\)</li> </ol> <p>Un tel arbre repr\u00e9sente une suite de d\u00e9rivations imm\u00e9diates effectu\u00e9e depuis \\(X\\). Chaque noeud interne de l'arbre correspond \u00e0 l'application d'une r\u00e8gle de production de la grammaire.</p> <p>Vocabulaire</p> <p>Les arbres de d\u00e9rivation sont aussi appel\u00e9s arbres d'analyse.</p> <p>Vocabulaire</p> <p>Lorsque les feuilles de l'arbre contiennent encore des non terminaux on dit que c'est un arbre de d\u00e9rivation partielle.</p> <p>Exemple (langage de Dyck)</p> <p>Reprenons l'exemple de la grammaire g\u00e9n\u00e9rant le langage de Dyck :</p> \\[ S \\to aSbS \\ | \\  \\varepsilon\\] <p>Voici un exemple d'arbre de d\u00e9rivation qui repr\u00e9sente les d\u00e9rivations utilis\u00e9es dans l'introduction de la partie pour engendrer \\(aabbab\\) :</p> <p> </p> <p>On constate que chaque noeud interne correspond \u00e0 l'application d'une r\u00e8gle de production.</p> <p>D\u00e9finition</p> <p>Soit un arbre de d\u00e9rivation, on appelle fronti\u00e8re de l'arbre le mot obtenu en concat\u00e9nant toutes ses feuilles de gauche \u00e0 droite.</p> <p>Notation: \\(\\mathrm{Fr}(A)\\) o\u00f9 \\(A\\) est l'arbre de d\u00e9rivation.</p> <p>On peut remarquer que si l'arbre de d\u00e9rivation n'est pas partiel alors la fronti\u00e8re est un mot sur \\(\\Sigma\\).</p> <p>Th\u00e9or\u00e8me</p> <p>Soit \\(G = (\\Sigma, V, S, \\mathcal{R})\\) une grammaire alg\u00e9brique, \\(u\\) un mot sur \\(\\Sigma \\cup V\\) et \\(X\\) un symbole non terminal alors \\(X \\Rightarrow^* u\\) si et seulement s'il existe un arbre de d\u00e9rivation de racine \\(X\\) dont la fronti\u00e8re est \\(u\\).</p> D\u00e9monstration <ol> <li>Sens direct : On proc\u00e8de par r\u00e9currence sur la longueur de la d\u00e9rivation. <ul> <li>Initialisation : Si la d\u00e9rivation est de longueur 0, c'est-\u00e0-dire \\(X \\Rightarrow^* X\\), l'arbre ayant un seul noeud \\(X\\) convient. </li> <li>H\u00e9r\u00e9dit\u00e9 : La d\u00e9rivation se d\u00e9compose en \\(X \\Rightarrow^* v\\) de longueur \\(k\\) et \\(v \\Rightarrow u\\). Par hypoth\u00e8se de r\u00e9currence, il existe un arbre de d\u00e9rivation \\(A_1\\) de racine \\(X\\) dont la fronti\u00e8re est \\(v\\). Puisque \\(v \\Rightarrow u\\), \\(v\\) se d\u00e9compose en \\(v = s Y t\\) et \\(u\\) en \\(s y_1 ... y_n t\\) avec \\(Y \\to y_1 ... y_n\\) la r\u00e8gle de production utilis\u00e9e dans la derni\u00e8re d\u00e9rivation imm\u00e9diate. Il suffit alors de remplacer la feuille \\(Y\\) dans \\(A_1\\) par un noeud \u00e9tiquet\u00e9 par \\(Y\\) et ayant des feuilles \u00e9tiquet\u00e9es de gauche \u00e0 droite par \\(y_1 ... y_n\\), on obtient un nouvel arbre \\(A\\). Il est facile de v\u00e9rifier que \\(A\\) est bien un arbre de d\u00e9rivation dont la fronti\u00e8re est \\(s y_1 ... y_n t = u\\).</li> </ul> </li> <li>Sens r\u00e9ciproque : On proc\u00e8de par induction sur les arbres : \\(P(A)\\) : \"Si \\(A\\) est un arbre de d\u00e9rivation de racine \\(X\\) et de fronti\u00e8re \\(u\\) alors \\(X \\Rightarrow^* u\\)\".<ul> <li>Cas de base : Si l'arbre est une feuille alors on a bien \\(X \\Rightarrow^* X\\).</li> <li> <p>H\u00e9r\u00e9dit\u00e9 : La racine poss\u00e8de un ou plusieurs fils qui v\u00e9rifient l'hypoth\u00e8se d'induction. On a deux cas :</p> <ul> <li>soit la racine poss\u00e8de un unique fils \\(\\varepsilon\\) et alors d'apr\u00e8s le point 3 de la d\u00e9finition, \\(X \\to \\varepsilon\\) est une r\u00e8gle de la grammaire donc \\(X \\Rightarrow^* \\varepsilon = \\mathrm{Fr}(A)\\). </li> <li>Sinon il poss\u00e8de des fils \\(A_1, \\dots,  A_n\\) de racines respectives d'\u00e9tiquettes \\(a_1, \\dots, a_n\\) distinctes de \\(\\varepsilon\\). Si \\(a_i\\) est un symbole terminal alors \\(a_i \\Rightarrow^* a_i = \\mathrm{Fr}(A_i)\\). Si \\(a_i\\) est un symbole non terminal alors \\(a_i \\Rightarrow^* \\mathrm{Fr}(A_i)\\) par hypoth\u00e8se d'induction. Dans tous les cas on a donc \\(a_i \\Rightarrow^* \\mathrm{Fr}(A_i)\\). D'apr\u00e8s le point 4 de la d\u00e9finition, on sait que \\(X \\to a_1 \\dots a_n\\) est une r\u00e8gle de la grammaire, donc on a : \\(X \\Rightarrow^* a_1 \\dots a_n \\Rightarrow^* \\mathrm{Fr}(A_1) a_2 \\dots a_n \\Rightarrow^* \\cdots \\Rightarrow^* \\mathrm{Fr}(A_1)\\dots \\mathrm{Fr}(A_n) = \\mathrm{Fr}(A) = u\\).</li> </ul> </li> </ul> </li> </ol> <p>Corollaire</p> <p>Soit \\(G = (\\Sigma, V, S, \\mathcal{R})\\) une grammaire alg\u00e9brique, \\(u\\) un mot sur \\(\\Sigma\\) alors \\(u \\in \\mathcal{L}(G)\\) si et seulement s'il existe un arbre de d\u00e9rivation de racine \\(S\\) dont la fronti\u00e8re est \\(u\\).</p> <p>La d\u00e9monstration de ce th\u00e9or\u00e8me est importante car elle nous donne un algorithme pour convertir une suite de d\u00e9rivations imm\u00e9diates en arbre de d\u00e9rivation et r\u00e9ciproquement :</p> <ul> <li>Pour construire un arbre de d\u00e9rivation \u00e0 partir d'une suite de d\u00e9rivations imm\u00e9diates depuis \\(X\\) : on commence par construire le noeud racine \\(X\\), puis on lit les d\u00e9rivations dans l'ordre, pour chaque d\u00e9rivation utilisant une r\u00e8gle \\(A \\to a_1\\dots a_n\\), on ajoute au noeud d'\u00e9tiquette \\(A\\) concern\u00e9 \\(n\\) fils d'\u00e9tiquettes \\(a_1, \\dots, a_n\\).</li> <li>Pour obtenir une suite de d\u00e9rivations imm\u00e9diates \u00e0 partir d'un arbre de d\u00e9rivation on proc\u00e8de par parcours en profondeur de l'arbre de d\u00e9rivation : \u00e0 chaque noeud interne rencontr\u00e9, on \u00e9crit une d\u00e9rivation imm\u00e9diate correspondant \u00e0 la r\u00e8gle utilis\u00e9e pour ce noeud.</li> </ul> <p>Proposition</p> <p>Soit \\(G = (\\Sigma, V, S, \\mathcal{R})\\) une grammaire alg\u00e9brique, \\(X\\) un symbole non terminal et \\(u\\) un mot sur \\(\\Sigma\\) alors on a \u00e9quivalence entre :</p> <ol> <li>\\(X \\Rightarrow^* u\\)</li> <li>\\(X \\Rightarrow_g^* u\\)</li> <li>\\(X \\Rightarrow_d^* u\\)</li> </ol> D\u00e9monstration <ul> <li>(2) implique (1) et (3) implique (1) d\u00e9coulent directement des d\u00e9finitions.</li> <li>Si \\(X \\Rightarrow^* u\\) d'apr\u00e8s la proposition pr\u00e9c\u00e9dente, il existe un arbre de d\u00e9rivation de racine \\(X\\) et de fronti\u00e8re \\(u\\). De plus, si on suit la d\u00e9monstration de cette m\u00eame proposition, on s'aper\u00e7oit que la suite de d\u00e9rivations imm\u00e9diates propos\u00e9es pour passer d'un arbre \u00e0 une suite de d\u00e9rivation n'utilise que des d\u00e9rivations gauche (car les fronti\u00e8res des sous-arbres ne contiennent alors que des symboles terminaux). On a donc \\(X \\rightarrow_g^* u\\). Donc (1) implique (2).</li> <li>(1) implique (3) se montre de la m\u00eame mani\u00e8re mais en consid\u00e9rant un parcours en profondeur o\u00f9 les fils sont explor\u00e9s de droite \u00e0 gauche.</li> <li>On montre de m\u00eame que (1) implique (3) en construisant la suite de d\u00e9rivations \u00e0 l'aide d'un parcours en profondeur en consid\u00e9rant les fils de droite \u00e0 gauche.</li> </ul> <p>Une cons\u00e9quence est que si on se restreint \u00e0 utiliser des d\u00e9rivations gauche (resp. droite) alors le langage engendr\u00e9 par une grammaire est inchang\u00e9. Un autre int\u00e9r\u00eat de cette proposition est qu'il est toujours possible supposer dans une d\u00e9monstration dans la quelle on sait que $X \\Rightarrow^ u \\in \\Sigma^ $ que toutes les d\u00e9rivations utilis\u00e9es sont gauche (ou droite).</p>"},{"location":"langages/grammaires/#b-ambiguite","title":"B. Ambigu\u00eft\u00e9","text":"<p>D\u00e9finition</p> <p>Une grammaire \\(G\\) est dite ambigu\u00eb s'il existe un mot \\(u\\) dans \\(\\mathcal{L}(G)\\) tel qu'il existe deux arbres de d\u00e9rivation distincts de racine \\(S\\) et de fronti\u00e8re \\(u\\).</p> <p>Ainsi une grammaire est ambigu\u00eb lorsqu'elle permet de produire un mot \\(u\\) de deux mani\u00e8res diff\u00e9rentes.</p> <p>Exemple</p> <p>On consid\u00e8re la grammaire suivante permettant de d\u00e9crire certaines formules propositionnelles sur l'ensemble de variables propositionnelles \\({x, y, z}\\).</p> \\[\\begin{align}     S &amp;\\to C \\ | \\ (S) \\\\     S &amp;\\to \\neg S\\\\     S &amp;\\to S \\lor S \\ | \\ S \\land S\\\\      C &amp;\\to x \\ |\\  y\\  |\\  z \\end{align} \\] <p>Cette grammaire est ambigu\u00eb, un exemple peut \u00eatre obtenu avec le mot \\(u = x \\lor y \\land z\\) qui est fronti\u00e8re des deux arbres de d\u00e9rivations suivants :</p> <p> </p> <p> </p> <p>On note \u00e9galement que l'ambigu\u00eft\u00e9 n'est en g\u00e9n\u00e9ral pas une propri\u00e9t\u00e9 souhaitable pour une grammaire. Dans cet exemple, elle signifie qu'il est impossible de donner un sens \u00e0 la formule \\(x \\lor y \\land z\\) (on ne sait pas si cette formule et un OU ou un ET).</p> <p>Exemple : le th\u00e9or\u00e8me de lecture unique</p> <p>Avec l'exemple pr\u00e9c\u00e9dent, on comprend l'int\u00e9r\u00eat de d\u00e9finir des grammaires non ambigu\u00ebs pour d\u00e9crire les formules propositionnelles. Cela est possible avec la grammaire suivante :</p> \\[ \\begin{align} S &amp;\\to \\neg S\\\\ S &amp;\\to (S \\lor S) \\ |\\  (S \\land S) \\ |\\  (S \\rightarrow S) \\ |\\  (S \\leftrightarrow S)\\\\ S &amp;\\to C \\\\ C &amp;\\to \\textrm{variables propositionnelles} \\end{align} \\] <p>En logique propositionnelle, le th\u00e9or\u00e8me de lecture unique \u00e9nonce que cette grammaire est non ambigu\u00eb. Autrement dit, si on se sert de ces r\u00e8gles pour \u00e9crire les formules alors on pourra les interpr\u00e9ter sous forme d'arbre sans ambigu\u00eft\u00e9.</p> <p>Si l'on souhaite \"r\u00e9soudre\" les probl\u00e8mes d'ambigu\u00eft\u00e9 deux solutions sont en g\u00e9n\u00e9ral utilis\u00e9es :</p> <ul> <li>D\u00e9finir une grammaire non ambigu\u00eb pour le langage souhait\u00e9 en utilisant un bon syst\u00e8me de parenth\u00e9sage : c'est ce qui a \u00e9t\u00e9 fait dans l'exemple pr\u00e9c\u00e9dent.</li> <li>Utiliser une grammaire ambigu\u00eb mais d\u00e9finir des priorit\u00e9s d'op\u00e9rateurs et/ou des r\u00e8gles d'associativit\u00e9 pour lever l'ambiguit\u00e9 sur l'arbre d'analyse \u00e0 choisir quand il y en a plusieurs : c'est souvent ce que l'on fait pour les expressions arithm\u00e9tiques et plus g\u00e9n\u00e9ralement les langages de programmation.</li> </ul> <p>Exemple : une autre grammaire pour le langage de Dyck</p> <p>On peut v\u00e9rifier que la grammaire suivante :</p> \\[ S \\to SS \\ |\\  aSb \\ |\\  \\varepsilon \\] <p>engendre \u00e9galement le langage de Dyck mais qu'elle est ambigu\u00eb. Saurez-vous trouver un mot de Dyck poss\u00e9dant deux arbres d'analyse distincts pour cette grammaire ?</p> <p>Il n'est pas toujours possible d'obtenir une grammaire non ambigu\u00eb pour d\u00e9crire un langage alg\u00e9brique, autrement dit, il existe des langages alg\u00e9briques dits inh\u00e9remment ambig\u00fcs pour lesquels toutes les grammaires qui les d\u00e9crivent sont ambigu\u00ebs. Un exemple est \\(L = \\{a^n b^n c^m,\\  (n, m) \\in \\mathbb{N}^2\\} \\cup \\{a^n b^m c^m,\\  (n, m) \\in \\mathbb{N}^2\\}\\) mais les outils pour le d\u00e9montrer sont hors programme.</p>"},{"location":"langages/grammaires/#c-lexemple-du-sinon-pendant-dangling-else","title":"C. L'exemple du \"sinon pendant\" (dangling else)","text":"<p>Un cas d'\u00e9cole classique d'illustration des grammaires et de l'ambigu\u00eft\u00e9 est le probl\u00e8me du sinon pendant. Le probl\u00e8me survient lorsque l'on d\u00e9cide de d\u00e9finir pour un langage de programmation, une structure conditionnelle Si ... Alors ... Sinon ... avec un Sinon optionnel. Par exemple consid\u00e9rons la grammaire simplifi\u00e9e suivante :</p> \\[ \\begin{align} I &amp;\\to \\mathbf{si}\\  B\\  \\mathbf{alors}\\  I\\\\     &amp;|\\  \\mathbf{si}\\  B\\ \\mathbf{alors}\\  I\\  \\mathbf{sinon}\\  I \\\\     &amp;|\\ a \\\\ B &amp;\\to b \\end{align} \\] <p>Dans cette grammaire, \\(B\\) sert \u00e0 d\u00e9crire une expression bool\u00e9enne (ici volontairement simplifi\u00e9e \u00e0 \\(b\\) par simplicit\u00e9) et \\(a\\) sert \u00e0 d\u00e9crire une instruction ou un bloc d'instructions (ici volontairement r\u00e9duit \u00e0 \\(a\\)). On remarque alors qu'il existe deux interpr\u00e9tations diff\u00e9rentes du programme :</p> \\[ \\mathbf{si}\\  b\\  \\mathbf{alors}\\  \\mathbf{si}\\  b\\  \\mathbf{alors}\\  a\\  \\mathbf{sinon}\\  a  \\] <p>autrement dit, la grammaire utilis\u00e9e est ambigu\u00eb.</p> <p>Voyons comment le probl\u00e8me pourrait se traduire en langage C. Imaginons un langage proche du C dans lequel il n'y a pas d'accolade, et consid\u00e9rons le programme :</p> <pre><code>int a = 5;\nint b = 2;\nif (a == 1)\n    if (b == 1)\n        a = 42;\nelse\n    b = 42;\nprintf(\"%d, %d\", a, b);\n</code></pre> <p>Alors avec la premi\u00e8re interpr\u00e9tation du sinon pendant, le programme affiche <code>(5, 42)</code> avec la seconde interpr\u00e9tation il affiche <code>(5, 2)</code>. Autrement dit, il est impossible de savoir si le <code>else</code> appartient au premier ou au second <code>if</code>... La syntaxe du langage C permet de lever l'ambiguit\u00e9 gr\u00e2ce \u00e0 l'utilisation des accolades.</p> <p>Voyons maintenant ce qu'il se passe en OCaml.  <pre><code>let a = 7;;\nlet b = 1;;\nif a = 1 then\n    print_string \"UN\";\n    if b = 1 then\n        print_string \"DEUX\"\nelse\n    print_string \"TROIS\"\n;;\n</code></pre> Ce programme affiche <code>DEUX</code> \u00e0 l'\u00e9cran.</p> <p>On constate donc que OCaml d\u00e9cide de faire le choix que le dernier <code>else</code> correspond au 2e <code>if</code>. Si on regarde la mani\u00e8re dont le code est indent\u00e9, on constate que l'auteur est probablement dans l'erreur dans ce qu'il imagine \u00eatre le comportement du programme (erreur classique d'utilisation du <code>if</code> en OCaml).</p>"},{"location":"langages/grammaires/#d-analyse-syntaxique","title":"D. Analyse syntaxique","text":"<p>L'analyse syntaxique consiste \u00e0 partir d'une grammaire et d'un texte appartenant au langage de cette grammaire \u00e0 construire un arbre d'analyse pour ce texte. Cet arbre repr\u00e9sentera alors le texte sous une forme structur\u00e9e qui sera plus facile \u00e0 manipuler par un programme.</p> <p>Par exemple, on peut vouloir obtenir le r\u00e9sultat du calcul de l'expression arithm\u00e9tique <code>(1 + 3) * (5 + 7)</code>. On utilise alors un analyseur syntaxique pour obtenir un arbre de d\u00e9rivation correspondant \u00e0 cette expression, puis on calcule la valeur de l'expression \u00e0 partir de l'arbre.</p> <p>Un autre exemple classique est celui de la compilation. En g\u00e9n\u00e9ral, un compilateur commence par une premi\u00e8re phrase d'analyse textuelle du code source afin de repr\u00e9senter le programme sous forme d'un arbre appel\u00e9 arbre de syntaxe abstraite. C'est \u00e0 partir de cet arbre que le compilateur va pouvoir produire du code vers le langage cible.</p> <p>Aucune technique sp\u00e9cifique d'analyse syntaxique n'est au programme mais il faut savoir r\u00e9aliser cette d\u00e9marche dans le cas de grammaires simples. Voir TP : pour une analyse syntaxique descendante des expressions arithm\u00e9tiques simples.</p>"},{"location":"langages/kleene/","title":"Th\u00e9or\u00e8me de Kleene","text":"<p>Dans ce chapitre, on fait le lien entre les langages r\u00e9guliers, qu'on peut d\u00e9noter par expression r\u00e9guli\u00e8re, et les langages reconnaissables par automate fini. Ce lien a \u00e9t\u00e9 explicit\u00e9 par Stephen C. Kleene en 1956 :</p> <p>Th\u00e9or\u00e8me de Kleene</p> <p>Un langage \\(L\\) est r\u00e9gulier (ou rationnel) si et seulement s'il est reconnaissable par automate fini.</p> <p>Ainsi il y a \u00e9galit\u00e9 entre la classe des langages r\u00e9guliers \\(\\def\\rat#1{{\\text{RAT}(#1)}} \\rat{\\Sigma}\\) et la classe des langages reconnaissables  par automate fini \\(\\def\\rec#1{{\\text{REC}(#1)}} \\rec{\\Sigma}\\) sur un alphabet \\(\\Sigma\\).</p> \\[ \\rat{\\Sigma} = \\rec{\\Sigma} \\] <p>Nous allons d\u00e9montrer ce th\u00e9or\u00e8me de mani\u00e8re constructive :</p> <ul> <li>on pr\u00e9sente deux algorithmes pour construire un automate reconnaissant le langage d\u00e9not\u00e9 par une expression r\u00e9guli\u00e8re donn\u00e9e</li> <li>on pr\u00e9sente un algorithme pour construire une expression r\u00e9guli\u00e8re qui d\u00e9note le langage reconnu par un automate fini donn\u00e9</li> </ul> <p>Nous verrons ensuite quelques cons\u00e9quences importantes.</p>"},{"location":"langages/kleene/#1-des-expressions-regulieres-vers-les-automates","title":"1. Des expressions r\u00e9guli\u00e8res vers les automates","text":""},{"location":"langages/kleene/#a-algorithme-de-berry-sethi","title":"A. Algorithme de Berry-S\u00e9thi","text":""},{"location":"langages/kleene/#langages-locaux","title":"Langages locaux","text":"<p>Soit \\(L\\) un langage sur l'alphabet \\(\\Sigma\\), on d\u00e9finit les ensembles suivants :</p> <ul> <li>\\(P(L) = \\{ a \\in \\Sigma \\ /\\ a\\Sigma^* \\cap L \\neq \\varnothing\\}\\)</li> <li>\\(D(L) = \\{ a \\in \\Sigma \\ /\\ \\Sigma^*a \\cap L \\neq \\varnothing\\}\\)</li> <li>\\(T(L) = \\{ u \\in \\Sigma^2 \\ /\\ \\Sigma^* u \\Sigma^* \\cap L \\neq \\varnothing\\}\\)</li> </ul> <p>Autrement dit \\(P(L)\\) est l'ensemble des lettres qui sont au d\u00e9but d'un des mots de \\(L\\), \\(D(L)\\) est l'ensemble des lettres qui terminent l'un des mots de \\(L\\), et \\(T(L)\\) est l'ensemble des facteurs de longueur 2 qui apparaissent dans l'un des mots de \\(L\\).</p> <p>Exemples</p> <ul> <li>\\(L_1 = \\{a, abb, aabbb\\}\\)<ul> <li>\\(P(L_1) = \\{a\\}\\)</li> <li>\\(D(L_1) = \\{a, b\\}\\)</li> <li>\\(T(L_1) = \\{aa, ab, bb\\}\\)</li> </ul> </li> <li>\\(L_2 = \\{u \\in \\{a,b\\}^* \\ /\\ |u|_a \\text{ est pair}\\}\\)<ul> <li>\\(P(L_2) = \\{a, b\\}\\)</li> <li>\\(D(L_2) = \\{a, b\\}\\)</li> <li>\\(T(L_2) = \\{aa, ab, ba, bb\\}\\)</li> </ul> </li> <li>\\(L_3 = \\{ \\text{mots sur } \\{a,b\\} \\text{ o\u00f9 tout } b \\text{ est suivi d'un } a\\}\\)<ul> <li>\\(P(L_3) = \\{a, b\\}\\)</li> <li>\\(D(L_3) = \\{a\\}\\)</li> <li>\\(T(L_3) = \\{aa, ab, ba\\}\\)</li> </ul> </li> </ul> <p>D\u00e9finition (langage local)</p> <p>Un langage \\(L\\) sur l'alphabet \\(\\Sigma\\) est dit local lorsque</p> \\[ L \\setminus \\{\\varepsilon \\} = \\left(P(L)\\Sigma^* \\cap \\Sigma^*D(L)\\right) \\setminus \\left( \\Sigma^*\\left( \\Sigma^2 \\setminus T(L) \\right) \\Sigma^* \\right)\\] <p>Cette expression math\u00e9matique peut para\u00eetre un peu barbare mais elle signifie simplement qu'un langage local est un langage dont l'ensemble des mots peuvent \u00eatre d\u00e9crits exactement en donnant :</p> <ul> <li>les premi\u00e8res lettres autoris\u00e9es,</li> <li>les derni\u00e8res lettres autoris\u00e9es,</li> <li>les paires de lettres cons\u00e9cutives autoris\u00e9es;</li> <li>et en pr\u00e9cisant si \\(\\varepsilon \\in L\\)</li> </ul> <p>Ainsi pour savoir si un mot appartient \u00e0 un langage local il suffit de l'observer localement.</p> <p>Remarquons que pour tout langage l'inclusion :</p> \\[ L \\setminus \\{\\varepsilon \\} \\subset \\left(P(L)\\Sigma^* \\cap \\Sigma^*D(L)\\right) \\setminus \\left( \\Sigma^*\\left( \\Sigma^2 \\setminus T(L) \\right) \\Sigma^* \\right)\\] <p>est vraie. En effet, un mot de \\(L\\) non vide commence bien par une lettre qui est n\u00e9cessairement dans \\(P(L)\\), termine par une lettre qui doit \u00eatre dans \\(D(L)\\) et ne contient aucun facteur de longueur 2 qui ne serait pas dans \\(T(L)\\). C'est donc l'inclusion r\u00e9ciproque qui caract\u00e9rise les langages locaux.</p> <p>Exemples</p> <ul> <li>\\(L_1\\) n'est pas local car par exemple \\(ab\\) commence par \\(a \\in P(L_1)\\) finit par \\(b \\in D(L_1)\\) et poss\u00e8de pour seul facteur de longueur 2 \\(ab \\in T(L_1)\\), mais pourtant \\(ab \\not \\in L_1\\). </li> <li>\\(L_2\\) n'est pas local car par exemple \\(a\\) commence par \\(a \\in P(L_2)\\) finit par \\(a \\in D(L_2)\\) et ne poss\u00e8de pas de facteur de longueur 2, mais pourtant \\(a \\not \\in L_2\\). </li> <li>\\(L_3\\) est local : soit en effet un mot \\(u\\) dans \\(\\left(P(L)\\Sigma^* \\cap \\Sigma^*D(L)\\right) \\setminus \\left( \\Sigma^*\\left( \\Sigma^2 \\setminus T(L) \\right) \\Sigma^* \\right)\\) alors si \\(b\\) appara\u00eet dans \\(u\\) il ne peut appara\u00eetre \u00e0 la derni\u00e8re place car \\(b \\not \\in D(L_3)\\), donc il est suivi par une lettre qui ne peut pas \u00eatre un \\(b\\) car \\(bb \\not \\in T(L_3)\\), donc il est n\u00e9cessairement suivi d'un \\(a\\). Ainsi \\(u \\in L_3\\) l'inclusion r\u00e9ciproque est vraie. </li> </ul>"},{"location":"langages/kleene/#automate-de-glushkov","title":"Automate de Glushkov","text":"<p>Une propri\u00e9t\u00e9 bien sympathique d'un langage local est qu'il est tr\u00e8s facile de concevoir un automate fini qui le reconnait. En effet, il suffit d'imaginer un automate qui m\u00e9morise \u00e0 tout instant la derni\u00e8re lettre lue, pour savoir si la prochaine lettre est autoris\u00e9e ou non. On appelle cette construction automate de Glushkov.</p> <p>D\u00e9finition (automate de Glushkov)</p> <p>Soit \\(L\\) un langage local sur \\(\\Sigma\\), on d\u00e9finit l'automate de Glushkov comme l'automate fini d\u00e9terministe \\(A = (Q, q_0, F, \\delta)\\) suivant :</p> <ul> <li>\\(Q = \\Sigma \\cup \\{ q_0 \\}\\)</li> <li>\\(q_0 = q_0\\)</li> <li>\\(F = D(L) \\cup \\{q_0\\}\\) si \\(\\varepsilon \\in L\\), \\(F = D(L)\\) sinon</li> <li>\\(\\delta : Q \\times \\Sigma \\to Q\\) est d\u00e9finie ainsi :<ul> <li>\\(\\forall x \\in \\Sigma, \\delta(q_0, x) = x\\) si \\(x \\in P(L)\\), bloque sinon</li> <li>\\(\\forall x,y \\in \\Sigma, \\delta(x, y) = y\\) si \\(xy \\in T(L)\\), bloque sinon </li> </ul> </li> </ul> <p>Voici un exemple pour le langage \\(L_3\\).</p>"},{"location":"langages/kleene/#algorithme-de-berry-sethi","title":"Algorithme de Berry-S\u00e9thi","text":"<p>On voudrait utiliser la construction de Glushkov pour produire un automate \u00e0 partir de n'importe quelle expression r\u00e9guli\u00e8re. H\u00e9las, on a vu que les expressions r\u00e9guli\u00e8res ne d\u00e9notent pas un langage r\u00e9gulier dans tous les cas.</p> <p>D\u00e9finition : expression r\u00e9guli\u00e8re lin\u00e9aire</p> <p>Une expression r\u00e9guli\u00e8re lin\u00e9aire est une expression r\u00e9guli\u00e8re qui ne contient pas deux fois une m\u00eame lettre.</p> <p>Proposition</p> <p>Toute expression r\u00e9guli\u00e8re lin\u00e9aire d\u00e9note un langage local.</p> <p>C'est un peu fastidieux mais on peut le d\u00e9montrer par induction sur les expressions r\u00e9guli\u00e8res.</p> <p>Example</p> <ol> <li>Lin\u00e9ariser \\(e\\) en num\u00e9rotant chacune de ses lettres (avec des num\u00e9ros distincts)</li> <li>D\u00e9terminer les param\u00e8tres \\(P(L')\\), \\(D(L')\\) et \\(T(L')\\) \u00e0 partir de l'expression r\u00e9guli\u00e8re \\(e'\\)</li> <li>D\u00e9terminer \u00e0 partir de \\(e'\\) si \\(\\varepsilon \\in L'\\)</li> <li>Construire l'automate de Glushkov \\(A'\\) pour \\(L'\\)</li> <li>Effacer les num\u00e9ros de lettres sur les transitions pour revenir \u00e0 un automate \\(A\\) qui reconna\u00eet \\(L\\)</li> </ol> <p>Remarques :</p> <ul> <li>L'automate obtenu contient \\(1 + |e|_{\\Sigma}\\) \u00e9tats.</li> <li>L'automate n'est pas n\u00e9cessairement d\u00e9terministe (donc peu pratique d'un point de vue calcul) mais on peut toujours le d\u00e9terminiser pour obtenir un automate efficace qui reconna\u00eet les mots de \\(L\\) en temps lin\u00e9aire. C'est co\u00fbteux mais on ne le fait qu'une seule fois (\\(\\simeq\\) proc\u00e9d\u00e9 de compilation).</li> </ul>"},{"location":"langages/kleene/#b-automates-de-thomson","title":"B. Automates de Thomson","text":"<p>L'algorithme de Thomson se propose de construire un automate \\(A\\) qui reconna\u00eet \\(\\mu(e)\\) en proc\u00e9dant par induction sur \\(e\\).</p>"},{"location":"langages/kleene/#automates-normalises","title":"Automates normalis\u00e9s","text":"<p>D\u00e9finition : automate normalis\u00e9</p> <p>Un automate fini non d\u00e9terministe (\\(\\varepsilon\\)-afnd) est dit normalis\u00e9 si :     - (i) il poss\u00e8de un unique \u00e9tat initial \\(q_0\\)     - (ii) \\(q_0\\) ne poss\u00e8de que des transitions sortantes     - (iii) il poss\u00e8de un unique \u00e9tat final \\(q_f \\neq q_0\\)     - (iv) \\(q_f\\) ne poss\u00e8de que des transitions entrantes</p> <p>Il est toujours possible de normaliser un automate donn\u00e9 en ajoutant une paire d'\u00e9tats initiaux et finaux et des \\(\\varepsilon\\)-ransitions allant de \\(q_0\\) vers les \u00e9tats initiaux de l'automate et des \u00e9tats finaux vers \\(q_f\\).</p>"},{"location":"langages/kleene/#automates-de-thomson","title":"Automates de Thomson","text":"<p>Proposition</p> <p>Pour toute expression r\u00e9guli\u00e8re \\(e\\), il existe un automate normalis\u00e9 qui reconna\u00eet le langage d\u00e9not\u00e9 par \\(e\\).</p> <ul> <li> <p>Cas de base</p> <ul> <li>\\(e = \\varnothing\\)</li> <li>\\(e = \\varepsilon\\)</li> <li>\\(e = x (x \\in \\Sigma)\\)</li> </ul> </li> <li> <p>Cas construits</p> <ul> <li>\\(e = e_1.e_2\\) : on fusionne l'\u00e9tat final de \\(e_1\\) avec l'\u00e9tat initial de \\(e_2\\)</li> <li>\\(e = (e_1 | e_2)\\) : on utilise une bifurcation pour s\u00e9parer les deux cas possibles</li> <li>\\(e = e_1\\star\\) : on proc\u00e8de ainsi :</li> </ul> </li> </ul> <p>Attention \u00e0 respecter scrupuleusement la construction pr\u00e9c\u00e9dente... n'improvisez pas sous peine d'\u00e9crire des automates faux.</p> <p>Exemple : \\(e = a(a|ab)\\star\\).</p>"},{"location":"langages/kleene/#suppression-des-transitions-spontanees","title":"Suppression des transitions spontan\u00e9es","text":"<p>On remarque que les automates de Thomson poss\u00e8dent un grand nombre d'\\(\\epsilon\\)-transitions. Voici un petit algorithme simple permettant de se d\u00e9barrasser des transitions instantan\u00e9es sans avoir besoin de d\u00e9terminiser l'automate.</p> <ol> <li>Marquer comme \u00e9tat initial tous les \u00e9tats de \\(\\eta(q)\\) avec \\(q \\in I\\).</li> <li>Pour toute transition \\((q, x, q')\\) avec \\(x \\in Sigma\\), on ajoute des transitions \\((q, x, q'')\\) pour tout \\(q'' \\in \\eta(q)\\).</li> </ol>"},{"location":"langages/kleene/#2-des-automates-vers-les-expressions-regulieres","title":"2. Des automates vers les expressions r\u00e9guli\u00e8res","text":""},{"location":"langages/kleene/#a-algorithme-par-elimination-des-etats","title":"A. Algorithme par \u00e9limination des \u00e9tats","text":""},{"location":"langages/regexp/","title":"Langages r\u00e9guliers, expressions r\u00e9guli\u00e8res","text":"<p>Dans ce chapitre on introduit les notions de mots et de langages formels en informatique. Il est important d'acqu\u00e9rir une bonne ma\u00eetrise des concepts pr\u00e9sent\u00e9s ici car ils seront utilis\u00e9s tout au long de l'ann\u00e9e de MPI.</p> <p>On pr\u00e9sente \u00e9galement une classe particuli\u00e8re de langages dits r\u00e9guliers qui ont une grande importance th\u00e9orique et pratique en informatique. Les expressions r\u00e9guli\u00e8res permettent de d\u00e9crire facilement ces langages.</p>"},{"location":"langages/regexp/#1-alphabets-et-mots","title":"1. Alphabets et mots","text":"<p>D\u00e9finition (alphabet)</p> <p>Un alphabet est un ensemble fini de symboles appel\u00e9s lettres.</p> <p>Exemples</p> <ul> <li>\\(\\Sigma = \\{a, b, c\\}\\) est un alphabet de 3 lettres</li> <li>\\(\\Sigma = \\{a, b, \\dots, z\\}\\) est l'alphabet qu'on apprend \u00e0 l'\u00e9cole</li> <li>\\(\\Sigma = \\{0, 1\\}\\) est un alphabet binaire</li> <li>\\(\\Sigma = \\{\\text{caract\u00e8res ASCII}\\}\\) est un alphabet permettant d'\u00e9crire des textes en informatique</li> </ul> <p>D\u00e9finition (mot)</p> <p>Un mot \\(m\\) sur un alphabet \\(\\Sigma\\) est une suite finie de lettres de \\(\\Sigma\\) : \\(m = m_1m_2\\dots m_n\\). Le nombre de lettres \\(n\\) de la suite est appel\u00e9 longueur du mot. Le seul mot de longueur 0 est appel\u00e9 mot vide et not\u00e9 \\(\\varepsilon\\).</p> <p>Exemples</p> <ul> <li>\\(aabbaa\\) est un mot sur \\(\\Sigma = \\{a, b\\}\\) mais aussi un mot sur \\(\\Sigma = \\{a, b, c\\}\\)</li> <li>\\(1101\\) est un mot sur \\(\\Sigma = \\{0, 1\\}\\)</li> <li>\\(\\varepsilon\\) est un mot</li> </ul> <p>Notations On notera :</p> <ul> <li>\\(|m|\\) la longueur du mot \\(m\\)</li> <li>\\(|m|_{a}\\) le nombre d'occurrences de la lettre \\(a\\) dans le mot \\(m\\)</li> </ul> <p>Notations</p> <p>Soit \\(\\Sigma\\) un alphabet.</p> <ul> <li>L'ensemble de tous les mots de longueur exactement \\(p \\in \\mathbb{N}\\) sur \\(\\Sigma\\) est not\u00e9 \\(\\Sigma^p\\)</li> <li>L'ensemble de tous les mots sur \\(\\Sigma\\) est not\u00e9 \\(\\Sigma^*\\)</li> </ul>"},{"location":"langages/regexp/#a-concatenation-de-mots","title":"A. Concat\u00e9nation de mots","text":"<p>D\u00e9finition (concat\u00e9nation)</p> <p>Soit \\(\\Sigma\\) un alphabet. Soit \\(u = u_1 \\dots u_p \\in \\Sigma^p\\) un mot de longueur \\(p\\) et \\(v = v_1 \\dots v_q \\in \\Sigma^q\\) un mot de longueur \\(q\\). La concat\u00e9nation de \\(u\\) et \\(v\\), not\u00e9e \\(u.v\\), est le mot \\(u.v = u_1 \\dots u_p v_1 \\dots v_q\\) de longueur \\(p + q\\).</p> <p>Proposition</p> <p>La concat\u00e9nation \\(.\\) est une loi de composition interne sur \\(\\Sigma^*\\) admettant les prori\u00e9t\u00e9s suivantes :</p> <ul> <li>Le mot vide \\(\\varepsilon\\) est neutre pour la concat\u00e9nation : \\(\\forall u \\in \\Sigma^*, \\varepsilon . u = u . \\varepsilon = u\\). </li> <li>La concat\u00e9nation est associative : \\(\\forall u \\in \\Sigma^*, \\forall v \\in \\Sigma^*, \\forall w \\in \\Sigma^*,(u.v).w = u.(v.w)\\). </li> <li>La concat\u00e9nation n'est pas commutative en g\u00e9n\u00e9ral.</li> </ul> <p>On dit que \\(\\left(\\Sigma^*, .\\right)\\) poss\u00e8de la structure alg\u00e9brique de mono\u00efde.</p> <p>Notations</p> <p>On adopte les m\u00eames conventions que pour la structure de groupe en math\u00e9matiques :</p> <ul> <li>On peut ommettre l'op\u00e9rateur \\(.\\) et \u00e9crire simplement \\(uv\\)</li> <li>On peut \u00e9crire \\(uvw\\) au lieu de \\((u.v).w\\) </li> <li> <p>On d\u00e9finit la puissance d'un mot comme l'it\u00e9r\u00e9 de la concat\u00e9nation :</p> <ul> <li>\\(u^0 = \\varepsilon\\)</li> <li>\\(u^p = \\underbrace{u.\\cdots.u}_{p \\text{ fois}}\\)</li> </ul> </li> </ul> <p>Ces conventions nous permettent d'\u00e9crire les mots de fa\u00e7on compacte par exemple :</p> <ul> <li>\\(aaaaaab = a^6b\\)</li> <li>\\(aabbaabbaabb = (a^2b^2)^3\\)</li> </ul> <p>Exercice</p> <p>On d\u00e9finit en OCaml le type suivant permettant de d\u00e9crire un mot : <pre><code>type mot =\n    | Epsilon\n    | Lettre of char\n    | Puissance of mot * int\n    | Concat of mot * mot\n</code></pre> Questions</p> <ol> <li>\u00c9crire une expression OCaml pour d\u00e9finir le mot \\(aaabbbaaabbb\\)</li> <li>\u00c9crire la fonction <code>longueur : mot -&gt; int</code></li> <li>\u00c9crire la fonction <code>occ : char -&gt; mot -&gt; int</code> qui compte le nombre d'occurrences d'une lettre dans un mot</li> </ol>"},{"location":"langages/regexp/#b-prefixes-suffixes-facteurs-sous-mots","title":"B. Pr\u00e9fixes, suffixes, facteurs, sous-mots","text":"<p>D\u00e9finition</p> <p>Soit \\(w\\) un mot sur l'alphabet \\(\\Sigma\\).</p> <ul> <li>S'il existe deux mots \\(u, v\\) tels que \\(w = u.v\\) alors on dit que \\(u\\) est un pr\u00e9fixe de \\(w\\). De plus, si \\(u \\neq w\\), on dit que c'est un pr\u00e9fixe propre.</li> <li>S'il existe deux mots \\(u, v\\) tels que \\(w = u.v\\) alors on dit que \\(v\\) est un suffixe de \\(w\\). De plus, si \\(v \\neq w\\), on dit que c'est un suffixe propre.</li> <li>S'il existe trois mots \\(u, v, t\\) tels que \\(w = u.t.v\\) alors on dit que \\(t\\) est un facteur de \\(w\\). De plus, si \\(t \\neq w\\) on dit que le facteur est propre.</li> </ul> <p>D'apr\u00e8s la d\u00e9finition, un pr\u00e9fixe d'un mot est aussi un facteur de ce mot, un suffixe d'un mot est aussi un facteur de ce mot.</p> <p>D\u00e9finition</p> <p>Soit \\(w = w_1 \\dots w_n (w_i \\in \\Sigma)\\) un mot de longueur \\(n\\). Soit un entier naturel \\(p \\leq n\\). Soit \\(\\varphi :\u00a0\\{1, \\dots, p\\} \\to \\{1, \\dots, n\\}\\) une application strictement croissante. Alors le mot \\(u = w_{\\varphi(1)}w_{\\varphi(2)}\\dots w_{\\varphi(p)}\\) est un sous-mot de \\(w\\).</p> <p>Intuitivement les sous-mots de \\(w\\) sont les mots qu'on peut former en s\u00e9letionnant certaines lettres de \\(w\\) sans en changer l'ordre relatif. Il est clair qu'un suffixe, un pr\u00e9fixe, ou un facteur d'un mot est aussi un sous-mot.</p> <p>Exemples</p> <p>Soit \\(w = alienation\\) alors</p> <ul> <li>\\(alien\\) est un prefixe (propre) de \\(w\\)</li> <li>\\(nation\\) est un suffixe (propre) de \\(w\\)</li> <li>\\(lien\\) est un facteur (propre) de \\(w\\)</li> <li>\\(latin\\) et \\(anion\\) sont des sous-mots de \\(w\\)</li> </ul>"},{"location":"langages/regexp/#2-langages","title":"2. Langages","text":"<p>D\u00e9finition (langage)</p> <p>Un langage sur l'aphabet \\(\\Sigma\\) est un ensemble (fini ou non) de mots sur \\(\\Sigma\\)</p> <p>Une autre mani\u00e8re de le dire est que les langages sur \\(\\Sigma\\) sont les parties de \\(\\Sigma^*\\).</p> <p>Exemples</p> <ul> <li>\\(\\varnothing\\) : le langage vide</li> <li>\\(\\Sigma^*\\) : langage contenant tous les mots possibles sur \\(\\Sigma\\), </li> <li>\\(\\{a, ab, baba\\}\\) : un langage fini sur \\(\\Sigma=\\{a, b\\}\\) </li> <li>\\(\\{\\varepsilon, a, a^2, a^3, a^4, \\dots \\}\\) : mots ne contenant que des \\(a\\). </li> <li>On peut aussi d\u00e9finir un langage par une propri\u00e9t\u00e9 sur les mots qui lui appartiennent : langage des mots finissant par \\(ababa\\), langage des mots contenant autant de \\(a\\) que de \\(b\\), etc.</li> </ul> <p>Erreur fr\u00e9quente</p> <p>Attention \u00e0 ne pas confondre :</p> <ul> <li>Le mot vide \\(\\varepsilon\\)</li> <li>Le langage vide \\(\\varnothing\\)</li> <li>Le langage ne contenant que le mot vide \\(\\{ \\varepsilon \\}\\)</li> </ul> <p>Les langages sont des ensembles</p> <p>Les langages \u00e9tant des ensembles, on peut les manipuler en tant que tels, en particulier on peut utiliser les outils ensemblistes classiques :</p> <ul> <li>L'union \\(L_1 \\cup L_2\\) est le langage des mots qui sont dans \\(L_1\\) ou dans \\(L_2\\). </li> <li>L'intersection \\(L_1 \\cap L_2\\) est le langage des mots qui sont dans \\(L_1\\) et dans \\(L_2\\). </li> <li>L'inclusion : on dit que \\(L_1 \\subseteq L_2\\) si tout mot de \\(L_1\\) est un mot de \\(L_2\\).</li> <li>La diff\u00e9rence \\(L_1 \\setminus L_2\\) est le langage des mots qui sont dans \\(L_1\\) mais pas dans \\(L_2\\).</li> <li>Le compl\u00e9mentaire \\(\\overline{L_1} = \\Sigma^* \\setminus L_1\\) est l'ensemble des mots sur \\(\\Sigma\\) qui ne sont pas dans \\(L_1\\). </li> </ul> <p>L'ensemble de tous les langages sur \\(\\Sigma\\) est \\(\\mathfrak P(\\Sigma^*)\\) (ensemble des parties de \\(\\Sigma^*\\)), il est partiellement ordonn\u00e9 par \\(\\subseteq\\), le plus petit des langages est \\(\\varnothing\\), le plus grand des langages est \\(\\Sigma^*\\). </p> <p>Exemple sur \\(\\Sigma =\\{a, b\\}\\) : </p> \\[\\varnothing \\subseteq \\{a\\} \\subseteq \\{a, aba\\} \\subseteq \\{ \\text{mots finissant par $a$}\\} \\subseteq \\Sigma^*.\\]"},{"location":"langages/regexp/#concatenation-puissance-etoile-de-langages","title":"Concat\u00e9nation, puissance, \u00e9toile de langages","text":"<p>D\u00e9finition (concat\u00e9nation)</p> <p>Soit \\(L_1\\) et \\(L_2\\) deux langages sur \\(\\Sigma\\). La concat\u00e9nation de \\(L_1\\) et \\(L_2\\) est </p> \\[L_1.L_2 = \\{ u.v, \\, u \\in L_1 \\text{ et } v \\in L_2. \\}\\] <p>C'est le langage des mots obtenus en prenant un mot de \\(L_1\\), un mot de \\(L_2\\), et en les concat\u00e9nant dans cet ordre. </p> <p>Attention \u00e0 ne pas confondre concat\u00e9nation de mots et concat\u00e9nation de langages. On remarque que c'est le m\u00eame type de d\u00e9finition que l'on a en math\u00e9matiques lorsqu'on d\u00e9finit, par exemple, la somme de deux sous-espaces vectoriels.</p> <p>D\u00e9finition (puissance)</p> <p>Soit \\(L\\) un langage et \\(p \\in \\mathbb{N}\\) on d\u00e9finit les puissances de \\(L\\) par :</p> <ul> <li>\\(L^0 = \\{ \\varepsilon \\}\\)</li> <li>\\(L^p = \\underbrace{L.\\cdots.L}_{p \\text{ fois}}\\)</li> </ul> <p>Exercice</p> <p>Soit \\(L = \\{a, ab\\}\\) un langage sur \\(\\{a, b\\}\\). Comparer \\(L_1 = L^3\\) et \\(L_2 = \\{u^3, \\, u \\in L\\}\\)</p> <p>D\u00e9finition (\u00e9toile)</p> <p>L'\u00e9toile d'un langage \\(L\\) est d\u00e9finie par </p> \\[L^* = \\bigcup_{p \\in \\mathbb N} L^p = \\{\\varepsilon\\} \\cup L \\cup L^2 \\cup \\dots\\] <p>Intuituivement \\(L^*\\) est le langage des mots qu'on peut former en prenant des mots de \\(L\\) et en les concat\u00e9nants.</p> <p>On pourra remarquer que cette d\u00e9finition est coh\u00e9rente avec la notation \\(\\Sigma^*\\) d\u00e9finie pr\u00e9c\u00e9demment.</p> <p>Exercice</p> <p>Soit \\(L = \\{M, P, I\\}\\), lister les premiers mots de \\(L^* = \\{M, P, I\\}^*\\) par ordre de longueur.</p> <p>Exercice</p> <p>Soit \\(L\\) un langage quelconque. Comparer \\(L^*\\) et \\((L^*)^*\\).</p>"},{"location":"langages/regexp/#3-langages-reguliers","title":"3. Langages r\u00e9guliers","text":"<p>Les langages r\u00e9guliers sont une classe particuli\u00e8re de langages, c'est-\u00e0-dire un ensemble de langages. Elle est d\u00e9finie par induction.</p> <p>D\u00e9finition (langages r\u00e9guliers)</p> <p>Soit \\(\\Sigma\\) un alphabet. L'ensemble des langages r\u00e9guliers sur \\(\\Sigma\\), aussi appel\u00e9s langages rationnels, not\u00e9 \\(\\def\\rat#1{{\\text{RAT}(#1)}} \\rat{\\Sigma}\\), est d\u00e9fini inductivement par</p> <ul> <li> <p>Axiomes :</p> <ul> <li>\\(\\varnothing \\in \\rat{\\Sigma}\\)</li> <li>\\(\\{\\varepsilon\\} \\in \\rat{\\Sigma}\\)</li> <li>Pour tout \\(x \\in \\Sigma\\), \\(\\{x\\} \\in \\rat{\\Sigma}\\)</li> </ul> </li> <li> <p>R\u00e8gles d'inf\u00e9rence :</p> <ul> <li>Si \\(L_1 \\in \\rat{\\Sigma}\\) et \\(L_2 \\in \\rat{\\Sigma}\\) alors \\(L_1.L_2 \\in \\rat{\\Sigma}\\)</li> <li>Si \\(L_1 \\in \\rat{\\Sigma}\\) et \\(L_2 \\in \\rat{\\Sigma}\\) alors \\(L_1 \\cup L_2 \\in \\rat{\\Sigma}\\)</li> <li>Si \\(L \\in \\rat{\\Sigma}\\) alors \\(L^* \\in \\rat{\\Sigma}\\)</li> </ul> </li> </ul> <p>Autrement dit, \\(\\rat{\\Sigma}\\) est la plus petite classe de langages contenant le langage vide, le langage contenant uniquement le mot vide, les langages contenant uniquement un mot d'une lettre, et stable par concat\u00e9nation, union finie et \u00e9toile.</p> <p>Comme toute d\u00e9finition inductive, cela signifie que les langages r\u00e9guliers peuvent se repr\u00e9senter sous forme d'arbres o\u00f9 les feuilles sont des axiomes et o\u00f9 les noeuds (ici binaires pour \\(\\cup\\) et \\(.\\) et unaires pour \\(*\\)) repr\u00e9sentent l'application d'une r\u00e8gle d'inf\u00e9rence.</p> <p>Exemples</p> <ol> <li>Montrer que \\(L = \\{a, aba\\}\\) est un langage r\u00e9gulier.</li> <li>Montrer que le langage des mots non vides sur \\(\\{a, b\\}\\) ne contenant que des \\(a\\) est r\u00e9gulier. </li> <li>Montrer que le langage des mots sur \\(\\{a, b\\}\\) finissant par \\(ba\\) est r\u00e9gulier. </li> <li>Montrer que le langage des mots sur \\(\\{0, 1\\}\\) contenant deux \\(1\\) cons\u00e9cutifs est r\u00e9gulier.</li> <li>Montrer que le langage des mots sur \\(\\{a, b\\}\\) dans lesquels tout \\(a\\) est suivi d'un \\(b\\) est r\u00e9gulier.</li> </ol> <p>Proposition</p> <ul> <li>L'union d'une famille finie de langages r\u00e9guliers est r\u00e9gulier.</li> <li>La concat\u00e9nation d'une suite finie de langages r\u00e9guliers est r\u00e9gulier.</li> <li>(admis) L'intersection d'une famille finie de langages r\u00e9guliers est r\u00e9gulier.</li> <li>(admis) Le compl\u00e9mentaire d'un langage r\u00e9gulier est r\u00e9gulier.</li> </ul> <p>Nous verrons plus tard que l'union/intersection d'une famille infinie de langages r\u00e9guliers n'est pas n\u00e9cessairement un langage r\u00e9gulier, m\u00eame lorsqu'elle est suppos\u00e9e d\u00e9nombrable.</p> <p>Les deux propri\u00e9t\u00e9s pour le moment admises sont la cons\u00e9quence du th\u00e9or\u00e8me de Kleene que nous \u00e9tudierons plus tard.</p> <p>Proposition</p> <p>Tout langage fini est r\u00e9gulier.</p> <p>Pour rappel, nous avons donn\u00e9 des exemples de langages r\u00e9guliers infinis ci-dessus.</p>"},{"location":"langages/regexp/#4-expressions-regulieres","title":"4. Expressions r\u00e9guli\u00e8res","text":"<p>Nous introduisons ici un formalisme qui permet de d\u00e9crire simplement les langages r\u00e9guliers comme les langages des mots qui correspondent \u00e0 un certain motif. Voici un exemple d'un tel motif qui pourrait correspondre au langage des num\u00e9ros de t\u00e9l\u00e9phone portable \u00e0 la R\u00e9union</p> \\[ 069(2|3) (0|1|2|3|4|5|6|7|8|9)^6\\] <p>Ce formalisme est d'autant plus important qu'il est largement utilis\u00e9 en informatique pour les documentations (sp\u00e9cifications) et dans la manipulation de certains programmes (shell, grep, etc).</p> <p>D\u00e9finition (expressions r\u00e9guli\u00e8res)</p> <p>Soit \\(\\Sigma\\) un alphabet. L'ensemble des \\notion{expressions r\u00e9guli\u00e8res} sur \\(\\Sigma\\), not\u00e9 \\(\\def\\regexp#1{{\\text{REGEXP}(#1)}} \\regexp{\\Sigma}\\), est d\u00e9fini inductivement par</p> <ul> <li> <p>Axiomes :</p> <ul> <li>\\(\\varnothing \\in \\regexp{\\Sigma}\\)</li> <li>\\(\\varepsilon \\in \\regexp{\\Sigma}\\)</li> <li>Pour tout \\(x \\in \\Sigma\\), \\(x \\in \\regexp{\\Sigma}\\)</li> </ul> </li> <li> <p>R\u00e8gles d'inf\u00e9rence :</p> <ul> <li>Si \\(e_1 \\in \\regexp{\\Sigma}\\) et \\(e_2 \\in \\regexp{\\Sigma}\\) alors \\((e_1.e_2) \\in \\regexp{\\Sigma}\\)</li> <li>Si \\(e_1 \\in \\regexp{\\Sigma}\\) et \\(e_2 \\in \\regexp{\\Sigma}\\) alors \\((e_1|e_2) \\in \\regexp{\\Sigma}\\)</li> <li>Si \\(e \\in \\regexp{\\Sigma}\\) alors \\(e* \\in \\regexp{\\Sigma}\\)</li> </ul> </li> </ul> <p>Exemples</p> <p>Voici quelques exemples d'expressions r\u00e9guli\u00e8res suivies de leur signification intuitive :</p> <ul> <li>\\((a|b)*\\) : mots ne contenant que des \\(a\\) ou des \\(b\\).</li> <li>\\((a|b)*baba\\) : mots sur \\(\\Sigma = \\{a, b\\}\\) finissant par \\(baba\\).</li> <li>\\(bac(a|b|c)*\\) : mots sur \\(\\Sigma = \\{a, b, c\\}\\) commen\u00e7ant par \\(bac\\).</li> <li>\\((+|-|\\varepsilon)(1|\\dots|9)(0|\\dots|9)*\\) : mots repr\u00e9sentant une constante litt\u00e9rale enti\u00e8re</li> </ul> <p>\u00c9critures simplifi\u00e9es : pour simplifier les \u00e9critures, on pourra </p> <ul> <li>s'abstenir d'\u00e9crire certaines parenth\u00e8ses, par exemple \u00e9crire \\((a|b|c)\\) au lieu de \\(((a|b)|c)\\), </li> <li>ommettre le \\(.\\) de la concat\u00e9nation : par exemple \u00e9crire \\(baba\\) \u00e0 la place de \\((b.(a.(b.a)))\\).</li> <li>utiliser les puissances : par exemple, \u00e9crire \\((a|b)^3\\) pour \\((a|b)(a|b)(a|b)\\)</li> </ul>"},{"location":"langages/regexp/#a-denotation","title":"A. D\u00e9notation","text":"<p>Nous remarquons sur les exemples pr\u00e9c\u00e9dents que les expressions r\u00e9guli\u00e8res sont des motifs qui correspondent (match) \u00e0 un ensemble de mots. Le langage des mots qui correspondent \u00e0 une expression r\u00e9guli\u00e8re est appel\u00e9 langage d\u00e9not\u00e9 par l'expression r\u00e9guli\u00e8re. En voici une d\u00e9finition formelle : </p> <p>D\u00e9finition (langage d\u00e9not\u00e9)</p> <p>Le langage d\u00e9not\u00e9 par une expression r\u00e9guli\u00e8re \\(e \\in \\regexp{\\Sigma}\\) est not\u00e9 \\(\\mu(e)\\) et est d\u00e9fini inductivement par :</p> <ul> <li> <p>Axiomes :</p> <ul> <li>\\(\\mu(\\varnothing) = \\varnothing\\)</li> <li>\\(\\mu(\\varepsilon) = \\{ \\varepsilon \\}\\)</li> <li>Pour tout \\(x \\in \\Sigma\\), \\(\\mu(x) = \\{ x \\}\\)</li> </ul> </li> <li> <p>R\u00e8gles d'inf\u00e9rence :</p> <ul> <li>Si \\(e_1 \\in \\regexp{\\Sigma}\\) et \\(e_2 \\in \\regexp{\\Sigma}\\) alors \\(\\mu(e_1.e_2) = \\mu(e_1).\\mu(e_2)\\)</li> <li>Si \\(e_1 \\in \\regexp{\\Sigma}\\) et \\(e_2 \\in \\regexp{\\Sigma}\\) alors \\(\\mu(e_1|e_2) = \\mu(e_1) \\cup \\mu(e_2)\\)</li> <li>\\(e \\in \\regexp{\\Sigma}\\) alors \\(\\mu(e*) = \\mu(e)^*\\)</li> </ul> </li> </ul> <p>Exemple</p> <p>Le langage d\u00e9not\u00e9 par \\(e = (a|b)*ba\\) est le langage des mots sur \\(\\Sigma = \\{a, b\\}\\) qui finissent par \\(ba\\).</p> <p>Proposition</p> <p>Un langage \\(L\\) est r\u00e9gulier si et seulement s'il existe une expression r\u00e9guli\u00e8re \\(e\\) qui d\u00e9note \\(L\\), c'est-\u00e0-dire telle que \\(L = \\mu(e)\\). On peut l'\u00e9crire :</p> \\[ \\forall L \\subseteq \\Sigma^*, \\quad L \\in \\rat{\\Sigma} \\Leftrightarrow \\exists e \\in \\regexp{\\Sigma} : \\mu(e) = L\\] <p>Cette proposition nous \u00e9claire sur la classe des langages r\u00e9guliers : il s'agit en fait des langages qu'on peut d\u00e9noter par expression r\u00e9guli\u00e8re, nous verrons que ce n'est pas le cas de tous les langages.</p> <p>Point m\u00e9thode</p> <p>Pour r\u00e9sumer, nous avons vu pour l'instant ces 3 m\u00e9thodes pour d\u00e9montrer qu'un langage est r\u00e9gulier :</p> <ul> <li>s'il s'obtient comme application des r\u00e8gles d'inf\u00e9rence sur les axiomes, il est r\u00e9gulier</li> <li>s'il est fini, il est r\u00e9gulier</li> <li>s'il est d\u00e9not\u00e9 par une expression r\u00e9guli\u00e8re, il est r\u00e9gulier</li> </ul>"},{"location":"langages/regexp/#b-equivalence","title":"B. \u00c9quivalence","text":"<p>On peut remarquer qu'il n'y a pas unicit\u00e9 de l'expression r\u00e9guli\u00e8re permettant de d\u00e9noter un langage r\u00e9gulier. Par exemple \\(e_1 = b(ab)*\\) et \\(e_2 = (ba)*b\\) d\u00e9notent le m\u00eame langage : celui des mots commen\u00e7ant et finissant par \\(b\\) et qui alternent entre \\(a\\) et \\(b\\). Dans ce cas \\(\\mu(e_1) = \\mu(e_2)\\) et on dira que les expressions r\u00e9guli\u00e8res sont \u00e9quivalentes.</p> <p>D\u00e9finition</p> <p>Deux expressions r\u00e9guli\u00e8res \\(e_1\\) et \\(e_2\\) sont dites \u00e9quivalentes si elles d\u00e9notent le m\u00eame langage c'est-\u00e0-dire lorsque \\(\\mu(e_1) = \\mu(e_2)\\). On notera \\(e_1 \\equiv e_2\\).</p> <p>Comme en logique, l'\u00e9quivalence des expressions r\u00e9guli\u00e8res nous permet de calculer sur les expressions r\u00e9guli\u00e8res sans changer leur sens c'est-\u00e0-dire sans changer le langage d\u00e9not\u00e9. Voici quelques \u00e9quivalences usuelles (liste non exhaustive) :</p> <ul> <li>\\(\\forall e \\in \\regexp{\\Sigma}, \\ \\varepsilon.e \\equiv e.\\varepsilon \\equiv e\\)</li> <li>\\(\\forall e \\in \\regexp{\\Sigma}, \\ e** \\equiv e*\\)</li> <li>\\(\\forall e, f, g \\in \\regexp{\\Sigma}^3, \\  e.(f | g) \\equiv (e.f | e.g)\\)</li> <li>\\(\\forall e \\in \\regexp{\\Sigma}, \\ \\varnothing.e \\equiv e.\\varnothing \\equiv \\varnothing\\) </li> <li>\\(\\forall e \\in \\regexp{\\Sigma}, \\ e* | ee* \\equiv (\\varepsilon | e)e* \\equiv e*\\)</li> </ul> <p>On remarquera que d\u00e9cider l'\u00e9quivalence de deux expressions r\u00e9guli\u00e8res ou simplifier une expression r\u00e9guli\u00e8re sont des probl\u00e8mes difficiles en g\u00e9n\u00e9ral.</p>"},{"location":"langages/regexp/#5-applications-pratiques","title":"5. Applications pratiques","text":"<p>Les expressions r\u00e9guli\u00e8res sont largement utilis\u00e9es en informatique, voici quelques exemples concrets :</p> <ul> <li> <p>Les interpr\u00e8tes de commande (shells) dans les syst\u00e8mes d'exploitation de type Unix acceptent certains param\u00e8tres sous forme d'expressions r\u00e9guli\u00e8res ayant une syntaxe propre. Par exemple :</p> <ul> <li><code>ls *.ml</code> : affiche la liste de tous les fichiers source Caml dans le r\u00e9pertoire courant</li> <li><code>rm jeu*.o</code> : supprime les fichiers compil\u00e9s commen\u00e7ant par <code>jeu</code></li> <li><code>rm *.(c\\|h)</code> : supprime tous les fichiers sources et d'en-t\u00eate du r\u00e9pertoire actuel (id\u00e9al pour perdre tout son travail).</li> </ul> </li> <li> <p>L'utilitaire grep permet de lire un fichier ligne par ligne et d'afficher toutes les lignes qui correspondent \u00e0 un motif donn\u00e9 sous forme d'expression r\u00e9guli\u00e8re :</p> <ul> <li><code>grep -E 'L_(1|2)' regexp.md</code> trouve toutes les lignes de ce r\u00e9sum\u00e9 de cours contenant \\(L_1\\) ou \\(L_2\\).</li> </ul> </li> <li> <p>Le langage Awk permet d'\u00e9crire des programmes qui lisent les fichiers ligne par ligne et d'effectuer certaines actions si la ligne correspond \u00e0 un motif d\u00e9not\u00e9 par expression r\u00e9guli\u00e8re \u00e9tendue. Il a inspir\u00e9 en partie le langage Perl dans lequel les expressions r\u00e9guli\u00e8res ont une place importante.</p> </li> <li> <p>Pour sp\u00e9cifier un langage de programmation il faut commencer par d\u00e9finir sa syntaxe : quels sont mots-clefs du langage, \u00e0 quoi ressemble une variable, une constante litt\u00e9rale flottante ? Ces d\u00e9finitions se font \u00e0 l'aide d'expressions r\u00e9guli\u00e8res. C'est la premi\u00e8re \u00e9tape pour d\u00e9finir un langage de programmation et permet ensuite de faciliter la conception des compilateurs et interpr\u00e8tes pour ce langage.</p> <ul> <li>Par exemple le manuel OCaml d\u00e9crit les constantes litt\u00e9rales enti\u00e8res \u00e0 l'aide d'expressions r\u00e9guli\u00e8res.</li> </ul> </li> </ul>"},{"location":"langages/regexp/#expressions-regulieres-etendues-posix","title":"Expressions r\u00e9guli\u00e8res \u00e9tendues POSIX","text":"<p>Malheureusement il n'existe pas de syntaxe unifi\u00e9e pour les expressions r\u00e9guli\u00e8res et chaque logiciel a tendance \u00e0 utiliser ses propres conventions syntaxiques. La norme POSIX tente d'uniformiser ces notations, on parle alores d'expressions r\u00e9guli\u00e8res \u00e9tendues POSIX. Voici par exemple ce qu'on peut utiliser dans les expressions r\u00e9guli\u00e8res \u00e9tendues :</p> Motif Signification <code>m*</code> \\(m\\) r\u00e9p\u00e9t\u00e9 0 ou plusieurs fois <code>m+</code> \\(m\\) r\u00e9p\u00e9t\u00e9 1 ou plusieurs fois <code>m?</code> \\(m\\)  0 ou 1 fois <code>m{5}</code> \\(m\\) exactement 5 fois <code>m{3,7}</code> \\(m\\) entre 3 et 7 fois <code>m{3,}</code> \\(m\\) au moins 3 fois <code>.</code> 1 caract\u00e8re <code>(a\\|b)</code> \\(a\\) ou \\(b\\) <code>[abc]</code> \\(a\\),\\(b\\) ou \\(c\\) <code>[a-z]</code> un caract\u00e8re entre \\(a\\) et \\(z\\) <code>\\w</code> un caract\u00e8re alphanum\u00e9rique <p>Il est important de comprendre que chacune de ces r\u00e8gles peut s'obtenir sous forme d'une expression r\u00e9guli\u00e8re vue dans notre cours, elles n'apportent donc techniquement rien de plus si ce n'est un plus grand confort dans l'\u00e9criture des motifs.</p> <p>Par exemple, le langage des num\u00e9ros de t\u00e9l\u00e9phone portable r\u00e9unionnais peut \u00eatre d\u00e9crit avec l'expression reguli\u00e8re POSIX :</p> \\[ (06-9)(2\\backslash|3)(-[0-9]\\{2\\})\\{3\\} \\]"},{"location":"langc/tableaux/","title":"Les tableaux en langage C","text":"<p>Nous abordons ici la gestion des tableaux en langage C. Bien que les tableaux ne constituent pas un concept difficile en soi, leur mise en oeuvre en langage C se d\u00e9marque de celle des langages de haut niveau et est souvent source d'erreurs ou d'incompr\u00e9hensions chez les \u00e9tudiants.</p> <p>Une autre source de difficult\u00e9s est la compr\u00e9hension du lien entre tableaux et pointeurs. Le fait qu'en langage C on puisse parfois remplacer <code>int t[]</code> par <code>int *t</code> conduit certains \u00e9tudiants \u00e0 se m\u00e9prendre en imaginant qu'un tableau est la m\u00eame chose qu'un pointeur. Disons-le maintenant haut et fort :</p> <p>Les tableaux ne sont pas des pointeurs et les pointeurs ne sont pas des tableaux !</p>"},{"location":"langc/tableaux/#1-les-tableaux-en-langage-c","title":"1. Les tableaux en langage C","text":"<p>Les tableaux sont un espace de m\u00e9moire contig\u00fc. La mani\u00e8re la plus simple d'utiliser un tableau est de d\u00e9clarer un tableau statique sur la pile : <pre><code>int t[4];\n</code></pre> Cette d\u00e9claration r\u00e9serve sur la pile un bloc de m\u00e9moire permettant de stocker 4 entiers. Sur ma machine, les entiers <code>int</code> sont stock\u00e9s sur 4 octets, ce qui signifie que le bloc de m\u00e9moire r\u00e9serv\u00e9 fera 16 octets en tout. On peut ensuite acc\u00e9der en lecture ou en \u00e9crtiure \u00e0 chacun des emplacements par la syntaxe <code>t[i]</code>. Nous reviendrons plus tard sur la signification pr\u00e9cise de cette syntaxe, mais voyons d'abord un exemple <pre><code>int t[4];\nt[1] = 17;\nt[3] = 12;\nt[0] = t[1] + t[3];\n</code></pre></p> <p>La premi\u00e8re case du tableau d'indice 0 contiendra le valeur 29, les cases d'indice 1 et 3 auront pour valeur 17 et 12, et la case d'indice 2 aura une valeur ind\u00e9finie.</p> <p>Remarquons imm\u00e9diatement qu'un tableau n'est pas un pointeur. Ainsi, \u00e9crire : <pre><code>int *t;\nt[1] = 17;\nt[3] = 12;\nt[0] = t[1] + t[3];\n</code></pre> ne provoquera pas d'erreur de compilation mais conduira \u00e0 une ex\u00e9cution au comportant ind\u00e9fini, tr\u00e8s probablement \u00e0 une erreur de segmentation. En effet, la d\u00e9claration <code>int *t</code> r\u00e9serve sur la pile un espace m\u00e9moire pour stocker un pointeur d'entiers, c'est-\u00e0-dire une seule valeur d'adresse. Sur ma machine, les adresses ont une taille de 8 octets, on r\u00e9serve donc 2 fois moins d'espace que lors de la d\u00e9claration de tableau. Mais la quantit\u00e9 de m\u00e9moire r\u00e9serv\u00e9e n'est pas la seule raison pour laquelle ce code ne fonctionne pas.</p>"},{"location":"langc/tableaux/#comprendre-la-syntaxe-ti","title":"Comprendre la syntaxe t[i]","text":"<p>Dans le dernier exemple, on est en droit de se demander pourquoi diable le compilateur accepte d'\u00e9crire <code>t[i]</code> lorsque <code>t</code> n'est pas un tableau mais un pointeur... Pour cela il suffit de bien comprendre deux r\u00e8gles essentielles.</p> <p>La premi\u00e8re r\u00e8gle est que lorsque <code>t</code> est un tableau alors l'expression <code>t</code> peut \u00eatre implicitement traduite en pointeur de m\u00eame type que celui des \u00e9l\u00e9ments du tableau. La valeur de ce pointeur est alors l'adresse m\u00e9moire \u00e0 laquelle d\u00e9bute le tableau, ou autrement dit, l'adresse de l'\u00e9l\u00e9ment <code>t[0]</code>. </p> <p>La seconde r\u00e8gle est que lorsque <code>p</code> est un pointeur de type <code>type</code>, \u00e9crire <code>p[i]</code> permet d'acc\u00e9der \u00e0 la valeur de type <code>type</code> situ\u00e9e \u00e0 l'adresse m\u00e9moire <code>p + i * sizeof(type)</code>.</p> <p>Ainsi lorsqu'on \u00e9crit <code>t[i]</code> il se passe deux choses : <code>t</code> est d'abord interpr\u00e9t\u00e9 comme un pointeur contenant l'adresse de d\u00e9but du tableau, on ajoute \u00e0 cette adresse <code>i</code> fois le nombre d'octets occup\u00e9s par un \u00e9l\u00e9ment du tableau, puis on acc\u00e8de \u00e0 la valeur inscrite \u00e0 cette nouvelle adresse. Ainsi, cette m\u00e9thode permet bien d'acc\u00e9der au i-\u00e8me \u00e9l\u00e9ment du tableau ! </p> <p>C'est un peu compliqu\u00e9 ? Mettons en pratique ces deux r\u00e8gles sur l'exemple suivant.</p> <p>On comprend \u00e9galement mieux pourquoi l'exemple : <pre><code>int *t;\nt[1] = 17;\nt[3] = 12;\nt[0] = t[1] + t[3];\n</code></pre> ne fonctionne pas du tout. Le pointeur <code>t</code> n'est pas initialis\u00e9, donc la valeur qu'il contient est ind\u00e9finie. Lorsqu'on \u00e9crit <code>t[i]</code> il y a donc fort \u00e0 parier que l'on tente d'acc\u00e9der \u00e0 une adresse m\u00e9moire interdite.</p>"},{"location":"mpi/colles/","title":"Programmes de colle","text":"<ul> <li>Induction, r\u00e9currences, langages r\u00e9guliers [ Programme semaine 1]</li> <li>Induction, r\u00e9currences, langages r\u00e9guliers (tout) [ Programme semaine 2]</li> <li>Induction, langages r\u00e9guliers, parcours de graphes [ Programme semaine 3]</li> <li>Induction, langages r\u00e9guliers, parcours de graphes, Algorithme A \u00e9toile [ Programme semaine 4]</li> <li>Induction, langages r\u00e9guliers, parcours de graphes, Automates finis (d\u00e9but) [ Programme semaine 5]</li> <li>Induction, langages r\u00e9guliers, parcours de graphes, Automates finis d\u00e9terminstes, non d\u00e9terministes, \u00e0 transitions instantan\u00e9es [ Programme semaine 6]</li> <li>Semaine 7 : pas de changements, voir programme pr\u00e9c\u00e9dent</li> <li>Langages r\u00e9guliers et automates, parcours de graphes, arbres couvrants de poids minimal [ Programme semaine 8]</li> <li>Langages r\u00e9guliers et automates, arbres couvrants de poids minimal, th\u00e9or\u00e8me de Kleene (d\u00e9but) [ Programme semaine 9]</li> <li>Semaine 10 : pas de changements, voir programme pr\u00e9c\u00e9dent</li> <li>Automates, arbres couvrants de poids minimal, th\u00e9or\u00e8me de Kleene, Apprentissage supervis\u00e9 (d\u00e9but) [ Programme semaine 11]</li> <li>Automates, arbres couvrants de poids minimal, th\u00e9or\u00e8me de Kleene, Apprentissage supervis\u00e9 [ Programme semaine 12]</li> <li>Arbres couvrants de poids minimal, th\u00e9or\u00e8me de Kleene (et cons\u00e9quences), Apprentissage supervis\u00e9, logique propositionnelle [ Programme semaine 13]</li> <li>Arbres couvrants de poids minimal, th\u00e9or\u00e8me de Kleene (et cons\u00e9quences), Apprentissage supervis\u00e9, logique, d\u00e9duction naturelle (propositionnelle) [ Programme semaine 14]</li> <li>Logique, d\u00e9duction naturelle; d\u00e9cidabilit\u00e9 et complexit\u00e9 (d\u00e9but) [ Programme semaine 17]</li> <li>D\u00e9cidabilit\u00e9 et complexit\u00e9 : tout le chapitre [ Programme semaine 18]</li> <li>D\u00e9cidabilit\u00e9 et complexit\u00e9; Grammaires alg\u00e9brique (le d\u00e9but) [ Programme semaine 19]</li> <li>D\u00e9cidabilit\u00e9 et complexit\u00e9; Grammaires alg\u00e9brique [ Programme semaine 20]</li> <li>D\u00e9cidabilit\u00e9 et complexit\u00e9; Grammaires alg\u00e9brique; Composantes fortement connexes [ Programme semaine 21]</li> </ul>"},{"location":"mpi/cours/","title":"Cours MPI","text":"<p>Work in progress</p> <p>Ce section est en cours de construction. Merci de me signaler les erreurs \u00e9ventuelles.</p>"},{"location":"mpi/cours/#resumes-des-chapitres","title":"R\u00e9sum\u00e9s des chapitres","text":"<p>Avertissement</p> <p>Les r\u00e9sum\u00e9s num\u00e9riques suivants vous permettent de revoir le cours. Ils ne sont en aucun cas exhaustifs et ne dispensent certainement pas d'une \u00e9coute et d'une prise de notes actives en cours. En cas de manque de prises de notes, je retirerai l'acc\u00e8s \u00e0 ces documents.</p> <ol> <li> Induction et r\u00e9currence</li> <li> Langages r\u00e9guliers, expressions r\u00e9guli\u00e8res</li> <li> Parcours de graphes et algorithme A<ul> <li>Parcours : illustrations</li> </ul> </li> <li> Automates finis</li> <li> Arbres couvrants de poids minimal</li> <li> Th\u00e9or\u00e8me de Kleene</li> <li> Apprentissage supervis\u00e9<ul> <li>Algorithme ID3 : le choixpeau magique</li> <li>Arbres k-dimensionnels : illustrations</li> </ul> </li> <li> Logique propositionnelle, logique des pr\u00e9dicats, d\u00e9duction naturelle</li> <li> D\u00e9cidabilit\u00e9 et complexit\u00e9</li> <li> Grammaires alg\u00e9briques</li> <li> Composantes fortement connexes</li> <li> Programmation concurrente</li> <li> Apprentissage non supervis\u00e9</li> <li> Algorithmes probabilistes</li> <li> Couplages dans les graphes<ul> <li>Chemin augmentants, graphe r\u00e9siduel : exemple</li> </ul> </li> <li> Jeux d'accessibilit\u00e9</li> </ol>"},{"location":"mpi/cours/#notions-de-mp2i","title":"Notions de MP2I","text":"<p>Je mets \u00e9galement ici des documents li\u00e9s concernant les notions de MP2I. Il est toujours utile de les r\u00e9viser car elles peuvent \u00e9videmment tomber aux concours.</p> <ul> <li> Bases de donn\u00e9es et SQL</li> <li> Complexit\u00e9 amortie</li> <li> Programmation dynamique (en Python)</li> </ul>"},{"location":"mpi/cours/#complements-hors-programme","title":"Compl\u00e9ments (hors-programme)","text":"<p>Les documents suivants permettent, \u00e0 celles et ceux qui le veulent, d'aller un peu plus loin sur les notions vues en cours. Leur lecture est vivement conseill\u00e9e \u00e0 celles et ceux qui pr\u00e9parent les concours les plus s\u00e9lectifs.</p> <ul> <li> Arbres et tas binomiaux</li> <li> Langages r\u00e9guliers et reconnaissance par mono\u00efde</li> <li> Programmation par continuation</li> <li> Machines de Turing</li> <li> Th\u00e9or\u00e8me de Myhill-Nerode et applications</li> </ul>"},{"location":"mpi/td/","title":"Travaux dirig\u00e9s","text":"<ul> <li>Expressions r\u00e9guli\u00e8res [ planche]</li> <li>Automates finis d\u00e9terministes [ planche]</li> <li>Graphes et parcours [ planche]</li> <li>Automates finis non d\u00e9terministes [ planche]</li> <li>Graphes pond\u00e9r\u00e9s, chemins optimaux [ planche]</li> <li>Arbres couvrants [ planche]</li> <li>Th\u00e9or\u00e8me de Kleene [ planche]</li> <li>Logique propositionnelle [ planche]</li> <li>D\u00e9duction naturelle [ planche]</li> <li>D\u00e9cidabilit\u00e9 et complexit\u00e9 (P, NP, ...) [ planche]</li> <li>NP-compl\u00e9tude de VERTEX-COVER [ \u00e9nonc\u00e9]</li> <li>Grammaires non contextuelles [ planche]</li> </ul>"},{"location":"mpi/tp/","title":"Travaux pratiques","text":""},{"location":"mpi/tp/#sujets-traites-en-classe","title":"Sujets trait\u00e9s en classe","text":"<ul> <li> R\u00e9visions sur le langage OCaml : listes [ sujet]</li> <li> R\u00e9visions sur le langage C : calculatrice RPN [ sujet] [ corrig\u00e9]</li> <li> Expressions r\u00e9guli\u00e8res [ sujet] [ ressources]</li> <li> Algorithme A* sur une grille [ sujet] [ ressources] [ corrig\u00e9] Algorithme de path-finding avec A* (recherche inform\u00e9e)  </li> <li> Automates finis d\u00e9terministes [ sujet][ graphviewer] [ corrig\u00e9]</li> <li> Automates finis non d\u00e9terministes [ sujet]</li> <li> Segmentation d'images avec la structure Union-Find [ sujet] [ ressources] [ corrig\u00e9]</li> <li> Algorithme de Kruskal [ sujet] </li> <li> Automates de Glushkov [ sujet] </li> <li> Coloration de graphes d'intervalles [ sujet] </li> <li> D\u00e9tection automatique de langue [ sujet] [ ressources] </li> <li> Algorithme ID3 [ sujet] [ ressources] [ corrig\u00e9]</li> <li> Le probl\u00e8me de l'\u00e2ne rouge [ sujet] [ ressources] [ corrig\u00e9]</li> <li> Les perles de Dijkstra [ sujet] </li> <li> Analyse syntaxique : expressions arithm\u00e9tiques [ sujet] [ ressources] </li> </ul>"},{"location":"mpi/tp/#sujets-pouvant-etre-traites-en-autonomie-a-la-maison","title":"Sujets pouvant \u00eatre trait\u00e9s en autonomie \u00e0 la maison","text":""},{"location":"mpi/vacancesnoel/","title":"Travail pour les vacances de No\u00ebl","text":"<p>Je r\u00e9unis sur cette page les documents utiles pour votre travail pendant les vacances de No\u00ebl.</p> <ul> <li>Devoir en temps libre 2 : automate racine [ sujet]</li> <li>Devoir en temps libre 3 : syst\u00e8me de d\u00e9duction de Hilbert [ sujet]</li> <li> <p>Projet de programmation en C (sujet CCINP) [ sujet]</p> </li> <li> <p>Checklist de r\u00e9visions [ checklist] Avertissement : certains items n'ont pas encore \u00e9t\u00e9 abord\u00e9s en cours (d\u00e9cidabilit\u00e9 et complexit\u00e9, programmation concurrente, s\u00e9paration \u00e9valuation, grammaires alg\u00e9briques, th\u00e9orie des jeux...)</p> </li> </ul>"},{"location":"test/test/","title":"Test","text":"<p>Ceci est une page test</p> <p>Voici une liste non ordonn\u00e9e :</p> <ul> <li>Un</li> <li>Deux</li> <li>Trois</li> </ul> <p>Voici du code python :</p> <p><pre><code>import numpy as np\n</code></pre> fin code python</p> <p>Un code OCaml : <pre><code>let rec fact n =\n    if n &lt;= 1 then\n        1\n    else\n        n * fact (n - 1)\n;;\n</code></pre></p> <p>Un code en langage C : <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    printf(\"Hello world !\\n\");\n    return EXIT_SUCCESS;\n}\n</code></pre></p> <p>Voici une formule de maths :</p> \\[  \\int_0^\\pi \\cos(t) dt  \\] <p>Il est aussi possible d'\u00e9crire des formules dans les lignes comme \\(x \\mapsto x + 1\\).</p> <p>Une admonition personnelle :</p> <p>Proposition</p> <p>Voici une proposition int\u00e9ressante !</p>"}]}